/**
 * \file
 *
 * \brief AUTOSAR Dcm
 *
 * This file contains the implementation of the AUTOSAR
 * module Dcm.
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2017 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */

#if (!defined DCM_TYPES_H)
#define DCM_TYPES_H

/* !LINKSTO Dcm.Dsn.File.Dcm.Types,1 */
/* This file is part of othe public API of the Dcm. It contains all type definitions. */

/*==================[inclusions]=================================================================*/

#include <ComStack_Types.h>                                           /* AUTOSAR Com Stack types */

#include <Dcm_Cfg.h>                                                  /* Generated configuration */

#include <Dcm_Types_Cfg.h>                                       /* Configuration dependent types*/

#if (DCM_INCLUDE_RTE == STD_ON)
#include <Rte_Dcm_Type.h>                                               /* APIs generated by RTE */
#endif

/*==================[macros]=====================================================================*/

/** @defgroup Macro_Dcm_StatusType Macros for Dcm_StatusType
 **  \brief   These macros are used as values for Dcm_StatusType
 **  @{
 */

#if (defined DCM_E_OK)
#error DCM_E_OK already defined
#endif /* if (defined DCM_E_OK) */

/** \brief This value is representing a successful operation. */
#define DCM_E_OK 0x00U

#if (defined DCM_E_NOT_OK)
#error DCM_E_NOT_OK already defined
#endif /* if (defined DCM_E_NOT_OK) */

/** \brief This value is representing a unsuccessful operation. */
#define DCM_E_NOT_OK 0x01U


#if (defined DCM_E_TI_PREPARE_LIMITS)
#error DCM_E_TI_PREPARE_LIMITS already defined
#endif /* if (defined DCM_E_TI_PREPARE_LIMITS) */

/** \brief New timing parameter are not ok, since requested values are not within the defined
 **        limits (used by API: Dcm_PrepareSesTiming-Values()) */
#define DCM_E_TI_PREPARE_LIMITS 0x02U


#if (defined DCM_E_TI_PREPARE_INCONSTENT)
#error DCM_E_TI_PREPARE_INCONSTENT already defined
#endif /* if (defined DCM_E_TI_PREPARE_INCONSTENT) */

/** \brief New timing parameter are not ok, since requested values are not consistent
 **  (e.g. P2min not smaller than P2max) (used by API: Dcm_PrepareSesTiming-Values ()) */
#define DCM_E_TI_PREPARE_INCONSTENT 0x03U

#if (defined DCM_E_SESSION_NOT_ALLOWED)
#error DCM_E_SESSION_NOT_ALLOWED already defined
#endif /* if (defined DCM_E_SESSION_NOT_ALLOWED) */

/** \brief Application does not allow start of requested session (used by API:
 **        XXX_DcmGetSesChgPermission()) */
#define DCM_E_SESSION_NOT_ALLOWED 0x04U

#if (defined DCM_E_PROTOCOL_NOT_ALLOWED)
#error DCM_E_PROTOCOL_NOT_ALLOWED already defined
#endif /* if (defined DCM_E_PROTOCOL_NOT_ALLOWED) */

/** \brief Application does not allow start of requested protocol
 **       (used by API: XXX_DcmStartProtocol()) */
#define DCM_E_PROTOCOL_NOT_ALLOWED 0x05U

/* !LINKSTO SWS_Dcm_00976,1 */

#if (defined DCM_E_ROE_NOT_ACCEPTED)
#error DCM_E_ROE_NOT_ACCEPTED already defined
#endif /* if (defined DCM_E_ROE_NOT_ACCEPTED) */

/** \brief ResponseOnOneEvent request is not accepted by DCM (e.g. old ResponseOnOneEvent is not
 **        finished) (used by API: Dcm_DslInternal_ResponseOnOneEvent()) */
#define DCM_E_ROE_NOT_ACCEPTED 0x06U


#if (defined DCM_E_PERIODICID_NOT_ACCEPTED)
#error DCM_E_PERIODICID_NOT_ACCEPTED already defined
#endif /* if (defined DCM_E_PERIODICID_NOT_ACCEPTED) */

/** \brief Periodic transmission request is not accepted by DCM (e.g. old Periodic transmission is
 *         not finished) (used by API: DslInternal_ResponseOnOneDataByPeriodicId()) */
#define DCM_E_PERIODICID_NOT_ACCEPTED 0x07U

#if (defined DCM_E_REQUEST_NOT_ACCEPTED)
#error DCM_E_REQUEST_NOT_ACCEPTED already defined
#endif /* if (defined DCM_E_REQUEST_NOT_ACCEPTED) */

/** \brief Application rejects diagnostic request -> (used by API: XXX_DcmIndication()) */
#define DCM_E_REQUEST_NOT_ACCEPTED 0x08U

#if (defined DCM_E_REQUEST_ENV_NOK)
#error DCM_E_REQUEST_ENV_NOK already defined
#endif /* if (defined DCM_E_REQUEST_ENV_NOK) */

/** \brief Diagnostic request is not allowed by application because of not fitting environmental
 **        conditions -> (used by API: XXX_DcmIndication()) Base item type to transport status
 **        information. */
#define DCM_E_REQUEST_ENV_NOK 0x09U

#if (defined DCM_E_COMPARE_KEY_FAILED)
#error DCM_E_COMPARE_KEY_FAILED already defined
#endif /* if (defined E_COMPARE_KEY_FAILED) */

/** \brief ECU compares by tester requested key with own calculated key When comparison fails this
 **        definition is used. (used by API:  Xxx_CompareKey() within processing of security
 **        access service) */
#define DCM_E_COMPARE_KEY_FAILED 0x0BU

#if (defined DCM_E_WRONG_RECORD_NUM)
#error DCM_E_WRONG_RECORD_NUM already defined
#endif /* if (defined DCM_E_WRONG_RECORD_NUM) */

/** \brief Wrong record number is passed for getting FReeze frame or Extended Data Record */
#define DCM_E_WRONG_RECORD_NUM 0x11U

/* @} */ /* End of macros definitions for Dcm_StatusType */

/** @defgroup Macro_Dcm_ProtocolType Macros for Dcm_ProtocolType
 ** \brief These macro definitions are used as values for Dcm_ProtocolType
 **  @{
 */

#if (DCM_INCLUDE_RTE == STD_OFF)

/* !LINKSTO SWS_Dcm_00979,1, SWS_Dcm_01005,1 */

#if (defined DCM_OBD_ON_CAN)
#error DCM_OBD_ON_CAN already defined
#endif /* if (defined DCM_OBD_ON_CAN) */

/** \brief OBD protocol on CAN (ISO15765-4; ISO15031-5) */
#define DCM_OBD_ON_CAN 0x00U

#if (defined DCM_OBD_ON_FLEXRAY)
#error DCM_OBD_ON_FLEXRAY already defined
#endif /* if (defined DCM_OBD_ON_FLEXRAY) */

/** \brief OBD protocol on Flexray (Manufacturer specific; ISO15031-5) */
#define DCM_OBD_ON_FLEXRAY 0x01U

#if (defined DCM_OBD_ON_IP)
#error DCM_OBD_ON_IP already defined
#endif /* if (defined DCM_OBD_ON_IP) */

/** \brief OBD on Internet Protocol (Manufacturer specific; ISO15031-5)**/
#define DCM_OBD_ON_IP 0x02U

#if (defined DCM_UDS_ON_CAN)
#error DCM_UDS_ON_CAN already defined
#endif /* if (defined DCM_UDS_ON_CAN) */

/** \brief UDS Protocol on CAN (ISO15765-3; ISO14229-1) */
#define DCM_UDS_ON_CAN 0x03U


#if (defined DCM_UDS_ON_FLEXRAY)
#error DCM_UDS_ON_FLEXRAY already defined
#endif /* if (defined DCM_UDS_ON_FLEXRAY) */

/** \brief UDS Protocol on FlexRay (Manufacturer specific; ISO14229-1)**/
#define DCM_UDS_ON_FLEXRAY 0x04U

#if (defined DCM_UDS_ON_IP)
#error DCM_UDS_ON_IP already defined
#endif /* if (defined DCM_UDS_ON_IP) */

/** \brief UDS on Internet Protocol (Manufacturer specific; ISO14229-1) */
#define DCM_UDS_ON_IP 0x05U

#if (defined DCM_ROE_ON_CAN)
#error DCM_ROE_ON_CAN already defined
#endif /* if (defined DCM_ROE_ON_CAN) */

/** \brief Response On Event on CAN */
#define DCM_ROE_ON_CAN 0x06U

#if (defined DCM_ROE_ON_FLEXRAY)
#error DCM_ROE_ON_FLEXRAY already defined
#endif /* if (defined DCM_ROE_ON_FLEXRAY) */

/** \brief Response On Event on FlexRay */
#define DCM_ROE_ON_FLEXRAY 0x07U

#if (defined DCM_ROE_ON_IP)
#error DCM_ROE_ON_IP already defined
#endif /* if (defined DCM_ROE_ON_IP) */

/** \brief Response on Event on Internet Protocol */
#define DCM_ROE_ON_IP 0x08U

#if (defined DCM_PERIODICTRANS_ON_CAN)
#error DCM_PERIODICTRANS_ON_CAN already defined
#endif /* if (defined DCM_PERIODICTRANS_ON_CAN) */

/** \brief Periodic Transmission on CAN*/
#define DCM_PERIODICTRANS_ON_CAN 0x09U

#if (defined DCM_PERIODICTRANS_ON_FLEXRAY)
#error DCM_PERIODICTRANS_ON_FLEXRAY already defined
#endif /* if (defined DCM_PERIODICTRANS_ON_FLEXRAY) */

/** \brief Periodic Transmission on FlexRay */
#define DCM_PERIODICTRANS_ON_FLEXRAY 0x0AU

#if (defined DCM_PERIODICTRANS_ON_IP)
#error DCM_PERIODICTRANS_ON_IP already defined
#endif /* if (defined DCM_PERIODICTRANS_ON_IP) */

/** \brief Periodic Transmission on Internet Protocol */
#define DCM_PERIODICTRANS_ON_IP 0x0BU

#if (defined DCM_NO_ACTIVE_PROTOCOL)
#error DCM_NO_ACTIVE_PROTOCOL already defined
#endif /* if (defined DCM_NO_ACTIVE_PROTOCOL) */

/** \brief No protocol has been started */
#define DCM_NO_ACTIVE_PROTOCOL 0x0CU

#if (defined DCM_SUPPLIER_1)
#error DCM_SUPPLIER_1 already defined
#endif /* if (defined DCM_SUPPLIER_1) */

/** \brief SW Suppler Specific Protocol 1 */
#define DCM_SUPPLIER_1 0xF0U

#if (defined DCM_SUPPLIER_2)
#error DCM_SUPPLIER_2 already defined
#endif /* if (defined DCM_SUPPLIER_2) */

/** \brief SW Suppler Specific Protocol 2 */
#define DCM_SUPPLIER_2 0xF1U

#if (defined DCM_SUPPLIER_3)
#error DCM_SUPPLIER_3 already defined
#endif /* if (defined DCM_SUPPLIER_3) */

/** \brief SW Suppler Specific Protocol 3 */
#define DCM_SUPPLIER_3 0xF2U

#if (defined DCM_SUPPLIER_4)
#error DCM_SUPPLIER_4 already defined
#endif /* if (defined DCM_SUPPLIER_4) */

/** \brief SW Suppler Specific Protocol 4 */
#define DCM_SUPPLIER_4 0xF3U

#if (defined DCM_SUPPLIER_5)
#error DCM_SUPPLIER_5 already defined
#endif /* if (defined DCM_SUPPLIER_5) */

/** \brief SW Suppler Specific Protocol 5 */
#define DCM_SUPPLIER_5 0xF4U

#if (defined DCM_SUPPLIER_6)
#error DCM_SUPPLIER_6 already defined
#endif /* if (defined DCM_SUPPLIER_6) */

/** \brief SW Suppler Specific Protocol 6 */
#define DCM_SUPPLIER_6 0xF5U

#if (defined DCM_SUPPLIER_7)
#error DCM_SUPPLIER_7 already defined
#endif /* if (defined DCM_SUPPLIER_7) */

/** \brief SW Suppler Specific Protocol 7 */
#define DCM_SUPPLIER_7 0xF6U

#if (defined DCM_SUPPLIER_8)
#error DCM_SUPPLIER_8 already defined
#endif /* if (defined DCM_SUPPLIER_8) */

/** \brief SW Suppler Specific Protocol 8 */
#define DCM_SUPPLIER_8 0xF7U

#if (defined DCM_SUPPLIER_9)
#error DCM_SUPPLIER_9 already defined
#endif /* if (defined DCM_SUPPLIER_9) */

/** \brief SW Suppler Specific Protocol 9 */
#define DCM_SUPPLIER_9 0xF8U

#if (defined DCM_SUPPLIER_10)
#error DCM_SUPPLIER_10 already defined
#endif /* if (defined DCM_SUPPLIER_10) */

/** \brief SW Suppler Specific Protocol 10 */
#define DCM_SUPPLIER_10 0xF9U

#if (defined DCM_SUPPLIER_11)
#error DCM_SUPPLIER_11 already defined
#endif /* if (defined DCM_SUPPLIER_11) */

/** \brief SW Suppler Specific Protocol 11 */
#define DCM_SUPPLIER_11 0xFAU

#if (defined DCM_SUPPLIER_12)
#error DCM_SUPPLIER_12 already defined
#endif /* if (defined DCM_SUPPLIER_12) */

/** \brief SW Suppler Specific Protocol 12 */
#define DCM_SUPPLIER_12 0xFBU

#if (defined DCM_SUPPLIER_13)
#error DCM_SUPPLIER_13 already defined
#endif /* if (defined DCM_SUPPLIER_13) */

/** \brief SW Suppler Specific Protocol 13 */
#define DCM_SUPPLIER_13 0xFCU

#if (defined DCM_SUPPLIER_14)
#error DCM_SUPPLIER_14 already defined
#endif /* if (defined DCM_SUPPLIER_14) */

/** \brief SW Suppler Specific Protocol 14 */
#define DCM_SUPPLIER_14 0xFDU

#if (defined DCM_SUPPLIER_15)
#error DCM_SUPPLIER_15 already defined
#endif /* if (defined DCM_SUPPLIER_15) */

/** \brief SW Suppler Specific Protocol 15 */
#define DCM_SUPPLIER_15 0xFEU

/* @} *//* End of macros definitions for Dcm_ProtocolType */

/** @defgroup Macro_Dcm_ConfirmationStatusType Macros for Dcm_ConfirmationStatusType
 ** \brief These macros are used as values for Dcm_ConfirmationStatusType
 **  @{
 */

#if (defined DCM_RES_POS_OK)
#error DCM_RES_POS_OK already defined
#endif /* if (defined DCM_RES_POS_OK) */

/** \brief Status passed via Xxx_DcmConfirmation if a positive response was sent and status of
 **        Dcm_TpTxConfirmation was OK.
 */
#define DCM_RES_POS_OK 0U


#if (defined DCM_RES_POS_NOT_OK)
#error DCM_RES_POS_NOT_OK already defined
#endif /* if (defined DCM_RES_POS_NOT_OK) */

/** \brief Status passed via Xxx_DcmConfirmation if a positive response was sent and status of
 **        Dcm_TpTxConfirmation was NOT OK.
 */
#define DCM_RES_POS_NOT_OK 1U


#if (defined DCM_RES_NEG_OK)
#error DCM_RES_NEG_OK already defined
#endif /* if (defined DCM_RES_NEG_OK) */

/** \brief Status passed via Xxx_DcmConfirmation if a negative response was sent and status of
 **        Dcm_TpTxConfirmation was OK.
 */
#define DCM_RES_NEG_OK 2U


#if (defined DCM_RES_NEG_NOT_OK)
#error DCM_RES_NEG_NOT_OK already defined
#endif /* if (defined DCM_RES_NEG_NOT_OK) */

/** \brief Status passed via Xxx_DcmConfirmation if a negative response was sent and status of
 **        Dcm_TpTxConfirmation was NOT OK.
 */
#define DCM_RES_NEG_NOT_OK 3U

/* @} *//* End of macros definitions for Dcm_ConfirmationStatusType */

/** @defgroup Macro_Dcm_NegativeResponseCodeType Macros for Dcm_NegativeResponseCodeType
 ** \brief    These macros are used as values for Dcm_NegativeResponseCodeType
 **  @{
 */

#if (defined DCM_E_POSITIVERESPONSE)
#error DCM_E_POSITIVERESPONSE already defined
#endif /* if (defined DCM_E_POSITIVERESPONSE) */

/** \brief This response code shall not be used in a negative response message. This
 **        positiveResponse parameter value is reserved for server-internal implementation */
#define DCM_E_POSITIVERESPONSE 0x00U


#if (defined DCM_E_GENERALREJECT)
#error DCM_E_GENERALREJECT already defined
#endif /* if (defined DCM_E_GENERALREJECT) */

/** \brief This return value indicates that the requested action has been rejected by the
 **        application. The generalReject return value shall only be implemented in the application
 **        if none of the negative return values defined in this document meet the needs of the
 **        implementation. At no means shall this return value be a general replacement for the
 **        return values defined in this document. */
#define DCM_E_GENERALREJECT 0x10U


#if (defined DCM_E_SERVICENOTSUPPORTED)
#error DCM_E_SERVICENOTSUPPORTED already defined
#endif /* if (defined DCM_E_SERVICENOTSUPPORTED) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application does not support the requested service. The application shall send this
 **        return value in case the client has sent a request message with a service identifier,
 **        which is either unknown or not supported by the application. Therefore this negative
 **        return value is not shown in the list of negative return values to be supported for a
 **        diagnostic service, because this negative return value is not applicable for supported
 **        services. */
#define DCM_E_SERVICENOTSUPPORTED 0x11U


#if (defined DCM_E_SUBFUNCTIONNOTSUPPORTED)
#error DCM_E_SUBFUNCTIONNOTSUPPORTED already defined
#endif /* if (defined DCM_E_SUBFUNCTIONNOTSUPPORTED) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application does not support the service specific parameters of the request message. The
 **        application shall send this return value in case the client has sent a request message
 **        with a known and supported service identifier but with "sub function" which is either
 **        unknown or not supported. */
#define DCM_E_SUBFUNCTIONNOTSUPPORTED 0x12U


#if (defined DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT)
#error DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT already defined
#endif /* if (defined DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        length of the received request message does not match the prescribed length for the
 **        specified service or the format of the paramters do not match the prescribed format for
 **        the specified service. */
#define DCM_E_INCORRECTMESSAGELENGTHORINVALIDFORMAT 0x13U


#if (defined DCM_E_RESPONSETOOLONG)
#error DCM_E_RESPONSETOOLONG already defined
#endif /* if (defined DCM_E_RESPONSETOOLONG) */

/** \brief This return value indicates that the buffer of the lower layer is not large enough to
 **        transmit all data of the response */
#define DCM_E_RESPONSETOOLONG 0x14U


#if (defined DCM_E_BUSYREPEATREQUEST)
#error DCM_E_BUSYREPEATREQUEST already defined
#endif /* if (defined DCM_E_BUSYREPEATREQUEST) */

/** \brief This return value indicates that the application is temporarily too busy to perform the
 **        requested operation. In this circumstance the client shall perform repetition of the
 **        "identical request message" or "another request message". The repetition of the request
 **        shall be delayed by a time specified in the respective implementation documents. Example:
 **        In a multi-client environment the diagnostic request of one client might be blocked
 **        temporarily by a NRC 0x21 while a different client finishes a diagnostic task. Note: If
 **        the application is able to perform the diagnostic task but needs additional time to
 **        finish the task and prepare the response, the NRC 0x78 shall be used instead of
 **        NRC 0x21.
 **        This return value is in general supported by each diagnostic service, as not otherwise
 **        stated in the data link specific implementation document, therefore it is not listed in
 **        the list of applicable return values of the diagnostic services. */
#define DCM_E_BUSYREPEATREQUEST 0x21U


#if (defined DCM_E_CONDITIONSNOTCORRECT)
#error DCM_E_CONDITIONSNOTCORRECT already defined
#endif /* if (defined DCM_E_CONDITIONSNOTCORRECT) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite conditions are not met. */
#define DCM_E_CONDITIONSNOTCORRECT 0x22U


#if (defined DCM_E_REQUESTSEQUENCEERROR)
#error DCM_E_REQUESTSEQUENCEERROR already defined
#endif /* if (defined DCM_E_REQUESTSEQUENCEERROR) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application expects a different sequence of request messages or message as sent by the
 **        client. This may occur when sequence sensitive requests are issued in the wrong order.
 **        EXAMPLE A successful SecurityAccess service specifies a sequence of requestSeed and
 **        sendKey as susb-fuctions in the request messages. If the sequence is sent different by
 **        the client the application shall send a negative response essage with the negative r
 **        return value 0x24- . requestSequenceError. */
#define DCM_E_REQUESTSEQUENCEERROR 0x24U

#if (defined DCM_E_NORESPONSEFROMSUBNETCOMPONENT)
#error DCM_E_NORESPONSEFROMSUBNETCOMPONENT already defined
#endif /* if (defined DCM_E_NORESPONSEFROMSUBNETCOMPONENT) */

/** \brief This response code indicates that the server has received the request but the
 **        requested action could not be performed by the server, as a subnet component
 **        which is necessary to supply the requested information did not respond within the
 **        specified time. */
#define DCM_E_NORESPONSEFROMSUBNETCOMPONENT 0x25U

#if (defined DCM_E_FAILUREPREVENTSEXECUTIONOFREQUESTEDACTION)
#error DCM_E_FAILUREPREVENTSEXECUTIONOFREQUESTEDACTION already defined
#endif /* if (defined DCM_E_FAILUREPREVENTSEXECUTIONOFREQUESTEDACTION) */

/** \brief This response code indicates that the requested action will not be taken because a
 **        failure condition, identified by a DTC (with at least one DTC status bit for TestFailed,
 **        Pending, Confirmed or TestFailedSinceLastClear set to 1), has occurred and that
 **        this failure condition prevents the server from performing the requested action.  */
#define DCM_E_FAILUREPREVENTSEXECUTIONOFREQUESTEDACTION 0x26U

#if (defined DCM_E_REQUESTOUTOFRANGE)
#error DCM_E_REQUESTOUTOFRANGE already defined
#endif /* if (defined DCM_E_REQUESTOUTOFRANGE) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application has detected that the request message contains a parameter which attempts to
 **        substitute a value beyond its range of authority (e.g. attempting to substitute a data
 **        byte of 111 when the data is only defined to 100), or which attempts to access a
 **        dataIdentifier_routineIdentifer that is not supported or not supported
 **        in active session.
 **        This return value shall be implemented for all services, which allow the client to read
 **        data, write data or adjust functions by data in the application. */
#define DCM_E_REQUESTOUTOFRANGE 0x31U


#if (defined DCM_E_SECURITYACCESSDENIED)
#error DCM_E_SECURITYACCESSDENIED already defined
#endif /* if (defined DCM_E_SECURITYACCESSDENIED) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application's security strategy has not been satisfied by the client. The application
 **        shall send this return value if one of the following cases occur: - the test conditions
 **        of the application are not met, - the required message sequence e.g.
 **        DiagnosticSessionControl, securityAccess is not met, - the client has sent a request
 **        message which requires an unlocked application.
 **
 **        Beside the mandatory use of this negative return value as specified in the applicable
 **        services within this standard, this negative return value can also be used for any case
 **        where security is required and is not yet granted to perform the required service. */
#define DCM_E_SECURITYACCESSDENIED 0x33U


#if (defined DCM_E_INVALIDKEY)
#error DCM_E_INVALIDKEY already defined
#endif /* if (defined DCM_E_INVALIDKEY) */

/** \brief This return value indicates that the application has not given security access because
 **        the key sent by the client did not match with the key in the application's memory. This
 **        counts as an attempt to gain security. The application shall remain locked and increment
 **        is internal securityAccessFailed counter. */
#define DCM_E_INVALIDKEY 0x35U


#if (defined DCM_E_EXCEEDNUMBEROFATTEMPTS)
#error DCM_E_EXCEEDNUMBEROFATTEMPTS already defined
#endif /* if (defined DCM_E_EXCEEDNUMBEROFATTEMPTS) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        client has unsuccessfully attempted to gain security access more times than the
 **        application's security strategy will allow. */
#define DCM_E_EXCEEDNUMBEROFATTEMPTS 0x36U


#if (defined DCM_E_REQUIREDTIMEDELAYNOTEXPIRED)
#error DCM_E_REQUIREDTIMEDELAYNOTEXPIRED already defined
#endif /* if (defined DCM_E_REQUIREDTIMEDELAYNOTEXPIRED) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        client's latest attempt to gain security access was initiated before the application's
 **        required timeout period had elapsed. */
#define DCM_E_REQUIREDTIMEDELAYNOTEXPIRED 0x37U


#if (defined DCM_E_UPLOADDOWNLOADNOTACCEPTED)
#error DCM_E_UPLOADDOWNLOADNOTACCEPTED already defined
#endif /* if (defined DCM_E_UPLOADDOWNLOADNOTACCEPTED) */

/** \brief This return value indicates that an attempt to download to a application's memory cannot
 **        be accomplished due to some fault conditions. */
#define DCM_E_UPLOADDOWNLOADNOTACCEPTED 0x70U


#if (defined DCM_E_TRANSFERDATASUSPENDED)
#error DCM_E_TRANSFERDATASUSPENDED already defined
#endif /* if (defined DCM_E_TRANSFERDATASUSPENDED) */

/** \brief This return value indicates that a data transfer operation was halted due to some fault.
 */
#define DCM_E_TRANSFERDATASUSPENDED 0x71U


#if (defined DCM_E_GENERALPROGRAMMINGFAILURE)
#error DCM_E_GENERALPROGRAMMINGFAILURE already defined
#endif /* if (defined DCM_E_GENERALPROGRAMMINGFAILURE) */

/** \brief This return value indicates that the application detected an error when erasing or
 **        programming a memory location in the permanent memory device (e.g. Flash Memory). */
#define DCM_E_GENERALPROGRAMMINGFAILURE 0x72U


#if (defined DCM_E_WRONGBLOCKSEQUENCECOUNTER)
#error DCM_E_WRONGBLOCKSEQUENCECOUNTER already defined
#endif /* if (defined DCM_E_WRONGBLOCKSEQUENCECOUNTER) */

/** \brief This return value indicates that the application detected an error in the sequence of
 **        blockSequenceCounter values. Note that the repetition of a TransferData request message
 **        with a blockSequenceCounter equal to the one included in the previous TransferData
 **        request message shall be accepted by the application. */
#define DCM_E_WRONGBLOCKSEQUENCECOUNTER 0x73U


#if (defined DCM_E_REQUESTCORRECTLYRECEIVEDRESPONSEPENDING)
#error DCM_E_REQUESTCORRECTLYRECEIVEDRESPONSEPENDING already defined
#endif /* if (defined DCM_E_REQUESTCORRECTLYRECEIVEDRESPONSEPENDING) */

/** \brief This return value indicates that the request message was received correctly, and that
 **        all parameters in the request message were valid, but the action to be performed is not
 **        yet completed and the application is not yet ready to receive another request. As soon
 **        as the requested service has been completed, the application shall send a positive
 **        response message or negative response message with a return value different from this.
 **        The negative response message with this return value may be repeated by the application
 **        until the requested service is completed and the final response message is sent.This
 **        return value might impact the application layer timing parameter values. The detailed
 **        specification shall be included in the data link specific implementation document.This
 **        return value shall only be used in a negative response message if the application will
 **        not be able to receive further request messages from the client while completing the
 **        requested diagnostic service. When this return value is used, the application shall
 **        always send a final response (positive or negative) independent of the
 **        suppressPosRspMsgIndicationBit value. A typical example where this return value may be
 **        used is when the client has sent a request message, which includes data to be programmed
 **        or erased in flash memory of the application.If the programming_erasing routine (usually
 **        executed out of RAM) is not able to support serial communication while writing to the
 **        flash memory the application shall send a negative response message with this return
 **        value. This return value is in general supported by each diagnostic service, as not
 **        otherwise stated in the data link specific implementation document, therefore it is not
 **        listed in the list of applicable return values of the diagnostic services */
#define DCM_E_REQUESTCORRECTLYRECEIVEDRESPONSEPENDING 0x78U


#if (defined DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION)
#error DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION already defined
#endif /* if (defined DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application does not support the requested sub-function in the session currently active.
 **        This return value shall only be used when the requested sub-function is known to be
 **        supported in another session, otherwise return value SFNS (subFunctionNotSupported)
 **        shall be used. This return value shall be supported by each diagnostic service with a
 **        sub-function parameter, if not otherwise stated in the data link specific implementation
 **        document, therefore it is not listed in the list of applicable return values of the
 **        diagnostic services. */
#define DCM_E_SUBFUNCTIONNOTSUPPORTEDINACTIVESESSION 0x7EU


#if (defined DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION)
#error DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION already defined
#endif /* if (defined DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application does not support the requested service in the session currently active. This
 **        return value shall only be used when the requested service is known to be supported in
 **        another session, otherwise return value SNS (serviceNotSupported) shall be used. This
 **        return value is in general supported by each diagnostic service, as not otherwise stated
 **        in the data link specific implementation document, therefore it is not listed in the
 **        list of applicable return values of the diagnostic services. */
#define DCM_E_SERVICENOTSUPPORTEDINACTIVESESSION 0x7FU


#if (defined DCM_E_RPMTOOHIGH)
#error DCM_E_RPMTOOHIGH already defined
#endif /* if (defined DCM_E_RPMTOOHIGH) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for RPM is not met (current RPM is above a
 **        pre-programmed maximum threshold). */
#define DCM_E_RPMTOOHIGH 0x81U


#if (defined DCM_E_RPMTOOLOW)
#error DCM_E_RPMTOOLOW already defined
#endif /* if (defined DCM_E_RPMTOOLOW) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for RPM is not met (current RPM is below a
 **        pre-programmed minimum threshold). */
#define DCM_E_RPMTOOLOW 0x82U


#if (defined DCM_E_ENGINEISRUNNING)
#error DCM_E_ENGINEISRUNNING already defined
#endif /* if (defined DCM_E_ENGINEISRUNNING) */

/** \brief This is required for those actuator tests which cannot be actuated while the Engine is
 **        running. This is different from RPM too high negative response, and needs to be allowed.
 */
#define DCM_E_ENGINEISRUNNING 0x83U


#if (defined DCM_E_ENGINEISNOTRUNNING)
#error DCM_E_ENGINEISNOTRUNNING already defined
#endif /* if (defined DCM_E_ENGINEISNOTRUNNING) */

/** \brief This is required for those actuator tests which cannot be actuated unless the Engine is
 **        running. This is different from RPM too low negative response, and needs to be allowed.
 */
#define DCM_E_ENGINEISNOTRUNNING 0x84U


#if (defined DCM_E_ENGINERUNTIMETOOLOW)
#error DCM_E_ENGINERUNTIMETOOLOW already defined
#endif /* if (defined DCM_E_ENGINERUNTIMETOOLOW) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for engine run time is not met (current engine run
 **        time is below a pre-programmed limit). */
#define DCM_E_ENGINERUNTIMETOOLOW 0x85U


#if (defined DCM_E_TEMPERATURETOOHIGH)
#error DCM_E_TEMPERATURETOOHIGH already defined
#endif /* if (defined DCM_E_TEMPERATURETOOHIGH) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for temperature is not met (current temperature is
 **        above a pre-programmed maximum threshold). */
#define DCM_E_TEMPERATURETOOHIGH 0x86U


#if (defined DCM_E_TEMPERATURETOOLOW)
#error DCM_E_TEMPERATURETOOLOW already defined
#endif /* if (defined DCM_E_TEMPERATURETOOLOW) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for temperature is not met (current temperature is
 **        below a pre-programmed minimum threshold). */
#define DCM_E_TEMPERATURETOOLOW 0x87U


#if (defined DCM_E_VEHICLESPEEDTOOHIGH)
#error DCM_E_VEHICLESPEEDTOOHIGH already defined
#endif /* if (defined DCM_E_VEHICLESPEEDTOOHIGH) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for vehicle speed is not met (current VS is above a
 **        pre-programmed maximum threshold). */
#define DCM_E_VEHICLESPEEDTOOHIGH 0x88U


#if (defined DCM_E_VEHICLESPEEDTOOLOW)
#error DCM_E_VEHICLESPEEDTOOLOW already defined
#endif /* if (defined DCM_E_VEHICLESPEEDTOOLOW) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for vehicle speed is not met (current VS is below a
 **        pre-programmed minimum threshold). */
#define DCM_E_VEHICLESPEEDTOOLOW 0x89U


#if (defined DCM_E_THROTTLE_PEDALTOOHIGH)
#error DCM_E_THROTTLE_PEDALTOOHIGH already defined
#endif /* if (defined DCM_E_THROTTLE_PEDALTOOHIGH) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for throttle/pedal position is not met
 **        (current TP/APP is above a pre-programmed maximum threshold). */
#define DCM_E_THROTTLE_PEDALTOOHIGH 0x8aU


#if (defined DCM_E_THROTTLE_PEDALTOOLOW)
#error DCM_E_THROTTLE_PEDALTOOLOW already defined
#endif /* if (defined DCM_E_THROTTLE_PEDALTOOLOW) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for throttle/pedal position is not met
 **        (current TP/APP is below a pre-programmed minimum threshold). */
#define DCM_E_THROTTLE_PEDALTOOLOW 0x8bU


#if (defined DCM_E_TRANSMISSIONRANGENOTINNEUTRAL)
#error DCM_E_TRANSMISSIONRANGENOTINNEUTRAL already defined
#endif /* if (defined DCM_E_TRANSMISSIONRANGENOTINNEUTRAL) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for being in neutral is not met (current transmission
 **        range is not in neutral). */
#define DCM_E_TRANSMISSIONRANGENOTINNEUTRAL 0x8cU


#if (defined DCM_E_TRANSMISSIONRANGENOTINGEAR)
#error DCM_E_TRANSMISSIONRANGENOTINGEAR already defined
#endif /* if (defined DCM_E_TRANSMISSIONRANGENOTINGEAR) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for being in gear is not met (current transmission
 *         range is not in gear). */
#define DCM_E_TRANSMISSIONRANGENOTINGEAR 0x8dU


#if (defined DCM_E_BRAKESWITCH_NOTCLOSED)
#error DCM_E_BRAKESWITCH_NOTCLOSED already defined
#endif /* if (defined DCM_E_BRAKESWITCH_NOTCLOSED) */

/** \brief For safety reasons, this is required for certain tests before it begins, and must be
 **        maintained for the entire duration of the test. */
#define DCM_E_BRAKESWITCH_NOTCLOSED 0x8fU


#if (defined DCM_E_SHIFTERLEVERNOTINPARK)
#error DCM_E_SHIFTERLEVERNOTINPARK already defined
#endif /* if (defined DCM_E_SHIFTERLEVERNOTINPARK) */

/** \brief For safety reasons, this is required for certain tests before it begins, and must be
 **        maintained for the entire duration of the test. */
#define DCM_E_SHIFTERLEVERNOTINPARK 0x90U


#if (defined DCM_E_TORQUECONVERTERCLUTCHLOCKED)
#error DCM_E_TORQUECONVERTERCLUTCHLOCKED already defined
#endif /* if (defined DCM_E_TORQUECONVERTERCLUTCHLOCKED) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for torque converter clutch is not met (current TCC
 **        status above a pre-programmed limit or locked). */
#define DCM_E_TORQUECONVERTERCLUTCHLOCKED 0x91U


#if (defined DCM_E_VOLTAGETOOHIGH)
#error DCM_E_VOLTAGETOOHIGH already defined
#endif /* if (defined DCM_E_VOLTAGETOOHIGH) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for voltage at the primary pin of the application
 **        (ECU) is not met (current voltage is above a pre-programmed maximum threshold). */
#define DCM_E_VOLTAGETOOHIGH 0x92U


#if (defined DCM_E_VOLTAGETOOLOW)
#error DCM_E_VOLTAGETOOLOW already defined
#endif /* if (defined DCM_E_VOLTAGETOOLOW) */

/** \brief This return value indicates that the requested action will not be taken because the
 **        application prerequisite condition for voltage at the primary pin of the application
 **        (ECU) is not met (current voltage is below a pre-programmed maximum threshold). */
#define DCM_E_VOLTAGETOOLOW 0x93U

#if (defined DCM_DTRSTATUS_VISIBLE)
#error DCM_DTRSTATUS_VISIBLE already defined
#endif /* #if (defined DCM_DTRSTATUS_VISIBLE) */
/** \brief Test Id is available for execution */
#define DCM_DTRSTATUS_VISIBLE     0U

#if (defined DCM_DTRSTATUS_INVISIBLE)
#error DCM_DTRSTATUS_INVISIBLE already defined
#endif /* #if (defined DCM_DTRSTATUS_INVISIBLE) */
/** \brief Test Id is not available for execution */
#define DCM_DTRSTATUS_INVISIBLE   1U

#if (defined DCM_DID_SUPPORTED)
#error DCM_DID_SUPPORTED already defined
#endif
/* !LINKSTO SWS_Dcm_01138,1 */
/** \brief Value of Dcm_DidSupportedType: Did is supported */
#define DCM_DID_SUPPORTED ((uint8)0U)

#if (defined DCM_DID_NOT_SUPPORTED)
#error DCM_DID_NOT_SUPPORTED already defined
#endif
/* !LINKSTO SWS_Dcm_01138,1 */
/** \brief Value of Dcm_DidSupportedType: Did is not supported */
#define DCM_DID_NOT_SUPPORTED ((uint8)1U)


#endif /* if (DCM_INCLUDE_RTE == STD_OFF) */


/* @} *//* End of macros definitions for Dcm_NegativeResponseCodeType */

/** @defgroup Macro_Std_ReturnType Macros for Std_ReturnType
 ** \brief    These macros are used as values for Std_ReturnType (in addition to E_OK and
 **           E_NOT_OK defined in Std_Types.h)
 **  @{
 */

#if (defined DCM_E_PENDING)
#error DCM_E_PENDING already defined
#endif /* if (defined DCM_E_PENDING) */

/** \brief Session change is allowed but the DCM is not allowed to send a positive reponse.
 **  Instead a response pending must be send back and the Bootloader must finish the service. */
/* !LINKSTO Dcm.EB.Std_ReturnTypeExtended.DCM_E_PENDING,1 */
#define DCM_E_PENDING 0x0AU

#if (defined DCM_E_FORCE_RCRRP)
#error DCM_E_FORCE_RCRRP already defined
#endif /* if (defined DCM_E_FORCE_RCRRP) */

/** \brief Application request the transmission of a response Response Pending (NRC 0x78)
 **        (used by API: XXX_DcmGetSesChgPermission()) */
/* !LINKSTO Dcm.EB.Std_ReturnTypeExtended.DCM_E_FORCE_RCRRP,1 */
#define DCM_E_FORCE_RCRRP 0x0CU

#if (defined DCM_E_NO_DATA)
#error DCM_E_NO_DATA already defined
#endif /* if (defined DCM_E_NO_DATA) */

/** \brief RTE interface call returned no data.(This is not error) */
/* !LINKSTO Dcm.EB.Std_ReturnTypeExtended.DCM_E_NO_DATA,1 */
#define DCM_E_NO_DATA 0x83U

#if (defined DCM_E_DONE)
#error DCM_E_DONE already defined
#endif /* if (defined DCM_E_DONE) */

/** \brief Value indicates Operation Completed for the execution status of types of Dcm Service
    function*/
/* !LINKSTO Dcm.EB.Std_ReturnTypeExtended.DCM_E_DONE,1 */
#define DCM_E_DONE 0x1AU

#if (defined DCM_E_PROCESS_PAGE)
#error DCM_E_PROCESS_PAGE already defined
#endif /* if (defined DCM_E_PROCESS_PAGE) */

/** \brief The DCM shall send an "response pending" immediately */
/* !LINKSTO Dcm.EB.Std_ReturnTypeExtended.DCM_E_PROCESS_PAGE,1 */
#define DCM_E_PROCESS_PAGE 0x1DU

#if (defined DCM_E_ABORT)
#error DCM_E_ABORT already defined
#endif /* if (defined DCM_E_ABORT) */

  /** \brief Operation aborted */
/* !LINKSTO Dcm.EB.Std_ReturnTypeExtended.DCM_E_ABORT,1 */
#define DCM_E_ABORT 0x1EU

/* @} *//* End of macros definitions for Std_ReturnType */

/** @defgroup Macro_Dcm_ReturnWriteMemoryType Macros for Dcm_ReturnWriteMemoryType
 ** \brief    These macros are used as values for Dcm_ReturnWriteMemoryType
 **  @{
 */

#if (defined DCM_WRITE_OK)
#error DCM_WRITE_OK already defined
#endif /* if (defined DCM_WRITE_OK) */

/** \brief Write is done for the service 0x36 */
#define DCM_WRITE_OK 0x00U

#if (defined DCM_WRITE_PENDING)
#error DCM_WRITE_PENDING already defined
#endif /* if (defined DCM_WRITE_PENDING) */

/** \brief Write is pending for the service 0x36 */
#define DCM_WRITE_PENDING 0x01U

#if (defined DCM_WRITE_FAILED)
#error DCM_WRITE_FAILED already defined
#endif /* if (defined DCM_WRITE_FAILED) */

/** \brief Write failed for the service 0x36 */
#define DCM_WRITE_FAILED 0x02U

#if (defined DCM_WRITE_FORCE_RCRRP)
#error DCM_WRITE_FORCE_RCRRP already defined
#endif /* if (defined DCM_WRITE_FORCE_RCRRP) */

/** \brief Application request the transmission of a Response Pending (NRC 0x78)
 **        (used by API: Dcm_WriteMemory()) */
#define DCM_WRITE_FORCE_RCRRP 0x03U

/* @} **//* End of macros definitions for Dcm_ReturnWriteMemoryType */

/** @defgroup Macro_Dcm_ReturnReadMemoryType Macros for Dcm_ReturnReadMemoryType
 ** \brief    These macros are used as values for Dcm_ReturnReadMemoryType
 **  @{
 */

#if (defined DCM_READ_OK)
#error DCM_READ_OK already defined
#endif /* if (defined DCM_READ_OK) */

/** \brief Read is done for the service 0x36 */
#define DCM_READ_OK 0x00U

#if (defined DCM_READ_PENDING)
#error DCM_READ_PENDING already defined
#endif /* if (defined DCM_READ_PENDING) */

/** \brief Read is pending for the service 0x36 */
#define DCM_READ_PENDING 0x01U

#if (defined DCM_READ_FAILED)
#error DCM_READ_FAILED already defined
#endif /* if (defined DCM_READ_FAILED) */

/** \brief Read failed for the service 0x36 */
#define DCM_READ_FAILED 0x02U

#if (defined DCM_READ_FORCE_RCRRP)
#error DCM_READ_FORCE_RCRRP already defined
#endif /* if (defined DCM_READ_FORCE_RCRRP) */

/** \brief Application request the transmission of a Response Pending (NRC 0x78)
 **        (used by API: Dcm_WriteMemory()) */
#define DCM_READ_FORCE_RCRRP 0x03U
/* @} **//* End of macros definitions for Dcm_ReturnReadMemoryType */

#if (defined DCM_SEC_LEV_LOCKED)
#error DCM_SEC_LEV_LOCKED already defined
#endif /* if (defined DCM_SEC_LEV_LOCKED) */

/** \brief Value for locked security state */
#define DCM_SEC_LEV_LOCKED                       0x00U

#ifndef DCM_ALL_SESSION_LEVEL
/** \brief Value for ALL session level */
#define DCM_ALL_SESSION_LEVEL                    0xFFU
#endif /* #ifndef DCM_ALL_SESSION_LEVEL */

/** @defgroup Macro_Dcm_ResetModeType Macros for Dcm_ResetModeType
 ** \brief    These macros are used as values for Dcm_ResetModeType
 **  @{
 */

#if (defined DCM_NO_RESET)
#error DCM_NO_RESET already defined
#endif/* #if (defined DCM_NO_RESET) */

/** \brief Reset mode type is 'No Reset'  */
#define DCM_NO_RESET 0U


#if (defined DCM_HARD_RESET)
#error DCM_HARD_RESET already defined
#endif/* #if (defined DCM_HARD_RESET) */

/** \brief Reset mode type is 'Hard Reset'  */
#define DCM_HARD_RESET 1U


#if (defined DCM_KEY_ON_OFF_RESET)
#error DCM_KEY_ON_OFF_RESET already defined
#endif/* #if (defined DCM_KEY_ON_OFF_RESET) */

/** \brief Reset mode type is 'Key ON/OFF reset'  */
#define DCM_KEY_ON_OFF_RESET 2U


#if (defined DCM_SOFT_RESET)
#error DCM_SOFT_RESET already defined
#endif/* #if (defined DCM_SOFT_RESET) */

/** \brief Reset mode type is 'Software reset'  */
#define DCM_SOFT_RESET 3U


#if (defined DCM_ENABLE_RAPID_POWER_SHUTDOWN_RESET)
#error DCM_ENABLE_RAPID_POWER_SHUTDOWN_RESET already defined
#endif/* #if (defined DCM_ENABLE_RAPID_POWER_SHUTDOWN_RESET) */

/** \brief Reset mode type is 'Enable the Rapid power shutdown'  */
#define DCM_ENABLE_RAPID_POWER_SHUTDOWN_RESET 4U


#if (defined DCM_DISABLE_RAPID_POWER_SHUTDOWN_RESET)
#error DCM_DISABLE_RAPID_POWER_SHUTDOWN_RESET already defined
#endif/* #if (defined DCM_DISABLE_RAPID_POWER_SHUTDOWN_RESET) */

/** \brief Reset mode type is 'Disable the Rapid power shutdown'  */
#define DCM_DISABLE_RAPID_POWER_SHUTDOWN_RESET 5U


#if (defined DCM_BOOTLOADER_RESET)
#error DCM_BOOTLOADER_RESET already defined
#endif/* #if (defined DCM_BOOTLOADER_RESET) */

/** \brief Jump to Bootloader  */
#define DCM_BOOTLOADER_RESET 6U


#if (defined DCM_SS_BOOTLOADER_RESET)
#error DCM_SS_BOOTLOADER_RESET already defined
#endif/* #if (defined DCM_SS_BOOTLOADER_RESET) */

/** \brief Jump to System Supplier Bootloader  */
#define DCM_SS_BOOTLOADER_RESET 7U


#if (defined DCM_RESET_EXECUTION)
#error DCM_RESET_EXECUTION already defined
#endif/* #if (defined DCM_RESET_EXECUTION) */

/** \brief Request the execution of the reset  */
#define DCM_RESET_EXECUTION 8U

/* @} *//* End of macros definitions for Dcm_ResetModeType */

/** @defgroup Macro_Dcm_OpStatusType Macros for Dcm_OpStatusType
 ** \brief    These macros are used as values for Dcm_OpStatusType
 **  @{
 */

#if (DCM_INCLUDE_RTE == STD_OFF)

#if (defined DCM_INITIAL)
#error DCM_INITIAL already defined
#endif/* #if (defined DCM_INITIAL) */

/** \brief Indicates the initial call to the operation */
#define DCM_INITIAL 0x00U

#if (defined DCM_PENDING)
#error DCM_PENDING already defined
#endif/* #if (defined DCM_PENDING) */

/** \brief Indicates that a pending has been returned from
 **        previous call of the operation */
#define DCM_PENDING 0x01U

#if (defined DCM_CANCEL)
#error DCM_CANCEL already defined
#endif/* #if (defined DCM_CANCEL) */

/** \brief Indicates request to cancel a pending operation */
#define DCM_CANCEL 0x02U

#if (defined DCM_FORCE_RCRRP_OK)
#error DCM_FORCE_RCRRP_OK already defined
#endif/* #if (defined DCM_FORCE_RCRRP_OK) */

/** \brief Confirms a ResponsePending transmission */
#define DCM_FORCE_RCRRP_OK 0x03U

#endif /* (DCM_INCLUDE_RTE == STD_OFF) */

#if (defined DCM_UPDATE_PAGE)
#error DCM_UPDATE_PAGE already defined
#endif/* #if (defined DCM_UPDATE_PAGE) */

/** \brief Requests to update the next page in paged buffer processing */
#define DCM_UPDATE_PAGE 0x04U

#if (defined DCM_CONFIRMED_OK)
#error DCM_CONFIRMED_OK already defined
#endif/* #if (defined DCM_CONFIRMED_OK) */

/** \brief Confirms sucsessful transmission of the response */
#define DCM_CONFIRMED_OK 0x05U

#if (defined DCM_CONFIRMED_NOK)
#error DCM_CONFIRMED_NOK already defined
#endif/* #if (defined DCM_CONFIRMED_NOK) */

/** \brief Confirms failure in transmission of the response */
#define DCM_CONFIRMED_NOK 0x06U

#if (defined DCM_ASYNC_PROCESSING_WAIT)
#error DCM_ASYNC_PROCESSING_WAIT already defined
#endif/* #if (defined DCM_ASYNC_PROCESSING_WAIT) */

/** \brief Signals a wait state for asynchronous processing */
#define DCM_ASYNC_PROCESSING_WAIT 0x07U

#if (defined DCM_ASYNC_PROCESSING_DONE)
#error DCM_ASYNC_PROCESSING_DONE already defined
#endif/* #if (defined DCM_ASYNC_PROCESSING_DONE) */

/** \brief Signals the end of asynchronous processing */
#define DCM_ASYNC_PROCESSING_DONE 0x08U

#if (defined DCM_OPSTATUS_INVALID)
#error DCM_OPSTATUS_INVALID already defined
#endif/* #if (defined DCM_OPSTATUS_INVALID) */

/** \brief Generic invalid opStatus */
#define DCM_OPSTATUS_INVALID 0xFFU

/* @} *//* End of macros definitions for Dcm_OpStatusType */

/** @defgroup Macro_Dcm_CommunicationModeType Macros for Dcm_CommunicationModeType
 ** \brief    These macros are used as values for Dcm_CommunicationModeType
 **  @{
 */

#if (defined DCM_ENABLE_RX_TX_NORM)
#error DCM_ENABLE_RX_TX_NORM already defined
#endif/* #if (defined DCM_ENABLE_RX_TX_NORM) */

/** \brief Enable the Rx and Tx for normal communication  */
#define DCM_ENABLE_RX_TX_NORM 0U


#if (defined DCM_ENABLE_RX_DISABLE_TX_NORM)
#error DCM_ENABLE_RX_DISABLE_TX_NORM already defined
#endif/* #if (defined DCM_ENABLE_RX_DISABLE_TX_NORM) */

/** \brief Enable the Rx and disable the Tx for normal communication  */
#define DCM_ENABLE_RX_DISABLE_TX_NORM 1U


#if (defined DCM_DISABLE_RX_ENABLE_TX_NORM)
#error DCM_DISABLE_RX_ENABLE_TX_NORM already defined
#endif/* #if (defined DCM_DISABLE_RX_ENABLE_TX_NORM) */

/** \brief Disable the Rx and enable the Tx for normal communication  */
#define DCM_DISABLE_RX_ENABLE_TX_NORM 2U


#if (defined DCM_DISABLE_RX_TX_NORM)
#error DCM_DISABLE_RX_TX_NORM already defined
#endif/* #if (defined DCM_DISABLE_RX_TX_NORM) */

/** \brief Disable Rx and Tx for normal communication  */
#define DCM_DISABLE_RX_TX_NORM 3U


#if (defined DCM_ENABLE_RX_TX_NM)
#error DCM_ENABLE_RX_TX_NM already defined
#endif/* #if (defined DCM_ENABLE_RX_TX_NM) */

/** \brief Enable the Rx and Tx for network management communication  */
#define DCM_ENABLE_RX_TX_NM 4U


#if (defined DCM_ENABLE_RX_DISABLE_TX_NM)
#error DCM_ENABLE_RX_DISABLE_TX_NM already defined
#endif/* #if (defined DCM_ENABLE_RX_DISABLE_TX_NM) */

/** \brief Enable Rx and disable the Tx for network management communication  */
#define DCM_ENABLE_RX_DISABLE_TX_NM 5U


#if (defined DCM_DISABLE_RX_ENABLE_TX_NM)
#error DCM_DISABLE_RX_ENABLE_TX_NM already defined
#endif/* #if (defined DCM_DISABLE_RX_ENABLE_TX_NM) */

/** \brief Disable the Rx and enable the Tx for network management communication  */
#define DCM_DISABLE_RX_ENABLE_TX_NM 6U


#if (defined DCM_DISABLE_RX_TX_NM)
#error DCM_DISABLE_RX_TX_NM already defined
#endif/* #if (defined DCM_DISABLE_RX_TX_NM) */

/** \brief Diable Rx and Tx for network management communication  */
#define DCM_DISABLE_RX_TX_NM 7U


#if (defined DCM_ENABLE_RX_TX_NORM_NM)
#error DCM_ENABLE_RX_TX_NORM_NM already defined
#endif/* #if (defined DCM_ENABLE_RX_TX_NORM_NM) */

/** \brief Enable Rx and Tx for normal and network management communication  */
#define DCM_ENABLE_RX_TX_NORM_NM 8U


#if (defined DCM_ENABLE_RX_DISABLE_TX_NORM_NM)
#error DCM_ENABLE_RX_DISABLE_TX_NORM_NM already defined
#endif/* #if (defined DCM_ENABLE_RX_DISABLE_TX_NORM_NM) */

/** \brief Enable the Rx and disable the Tx for normal and network management communication  */
#define DCM_ENABLE_RX_DISABLE_TX_NORM_NM 9U


#if (defined DCM_DISABLE_RX_ENABLE_TX_NORM_NM)
#error DCM_DISABLE_RX_ENABLE_TX_NORM_NM already defined
#endif/* #if (defined DCM_DISABLE_RX_ENABLE_TX_NORM_NM) */

/** \brief Enable the Rx and disable the Tx for normal and network management communication  */
#define DCM_DISABLE_RX_ENABLE_TX_NORM_NM 0x0AU


#if (defined DCM_DISABLE_RX_TX_NORM_NM)
#error DCM_DISABLE_RX_TX_NORM_NM already defined
#endif/* #if (defined DCM_DISABLE_RX_TX_NORM_NM) */

/** \brief Disable Rx and Tx for normal and network  */
#define DCM_DISABLE_RX_TX_NORM_NM 0x0BU

/* @} *//* End of macros definitions for Dcm_CommunicationModeType */

#if (DCM_INCLUDE_RTE == STD_OFF)

/** @defgroup Macro_Dcm_RoeStateType Macros for Dcm_RoeStateType
 ** \brief    These macros are used as values for Dcm_RoeStateType
 **  @{
 */

#if (defined DCM_ROE_ACTIVE)
#error DCM_ROE_ACTIVE already defined
#endif/* #if (defined DCM_ROE_ACTIVE) */

/** \brief Activate the event  */
#define DCM_ROE_ACTIVE 0U

#if (defined DCM_ROE_UNACTIVE)
#error DCM_ROE_UNACTIVE already defined
#endif/* #if (defined DCM_ROE_UNACTIVE) */

/** \brief Deactivate the event  */
#define DCM_ROE_UNACTIVE 1U

/* @} *//* End of macros definitions for Dcm_RoeStateType */

#endif /* (DCM_INCLUDE_RTE == STD_OFF) */

/** @defgroup Macro_Dcm_EcuStartModeType Macros for Dcm_EcuStartModeType
 ** \brief    These macros are used as values for Dcm_EcuStartModeType
 **  @{
 */

#if (defined DCM_COLD_START)
#error DCM_COLD_START already defined
#endif/* #if (defined DCM_COLD_START) */

/** \brief The ECU starts normally  */
#define DCM_COLD_START 0U

#if (defined DCM_WARM_START)
#error DCM_WARM_START already defined
#endif/* #if (defined DCM_WARM_START) */

/** \brief The ECU starts from a bootloader jump  */
#define DCM_WARM_START 1U
/* @} *//* End of macros definitions for Dcm_EcuStartModeType */

/** @defgroup Macro_Dcm_SesCtrlType Macros for Dcm_SesCtrlType
 ** \brief    These macros are mandatory to be generated as values for Dcm_SesCtrlType even if the
 **           respective sessions are not configured.
 **  @{
 */

#ifndef DCM_DEFAULT_SESSION
/** \brief Value for Default session level */
#define DCM_DEFAULT_SESSION                    0x01U
#endif /* #ifndef DCM_DEFAULT_SESSION */

#ifndef DCM_PROGRAMMING_SESSION
/** \brief Value for Programming session level */
#define DCM_PROGRAMMING_SESSION                0x02U
#endif /* #ifndef DCM_PROGRAMMING_SESSION */

#ifndef DCM_EXTENDED_DIAGNOSTIC_SESSION
/** \brief Value for Extended session level */
#define DCM_EXTENDED_DIAGNOSTIC_SESSION        0x03U
#endif /* #ifndef DCM_EXTENDED_DIAGNOSTIC_SESSION */

#ifndef DCM_SAFETY_SYSTEM_DIAGNOSTIC_SESSION
/** \brief Value for Safety System session level */
#define DCM_SAFETY_SYSTEM_DIAGNOSTIC_SESSION   0x04U
#endif /* #ifndef DCM_SAFETY_SYSTEM_DIAGNOSTIC_SESSION */

/*==================[type definitions]===========================================================*/

/** \brief This type is used as return type for API function provided by Dcm or the Central
 **        Diagnostic software component. */
typedef uint8 Dcm_StatusType;

#if !defined(RTE_TYPE_Dcm_ConfirmationStatusType)
/** @cond */
#define RTE_TYPE_Dcm_ConfirmationStatusType
/** @endcond */
/** \brief Type used for status informations in confirmations sent to Central Diagnostic Software
 **        Component */
typedef uint8 Dcm_ConfirmationStatusType;
#endif

#if !defined(RTE_TYPE_Dcm_SecLevelType)
/** @cond */
#define RTE_TYPE_Dcm_SecLevelType
/** @endcond */
/** \brief Type of diagnostic security level */
typedef uint8 Dcm_SecLevelType;
#endif

#if !defined(RTE_TYPE_Dcm_SesCtrlType)
/** @cond */
#define RTE_TYPE_Dcm_SesCtrlType
/** @endcond */
/** \brief Type of diagnostic session */
typedef uint8 Dcm_SesCtrlType;
#endif

#if !defined(RTE_TYPE_Dcm_ProtocolType)
/** @cond */
#define RTE_TYPE_Dcm_ProtocolType
/** @endcond */
/** \brief Type of diagnostic protocol */
typedef uint8 Dcm_ProtocolType;
#endif

#if !defined(RTE_TYPE_Dcm_OpStatusType)
/** @cond */
#define RTE_TYPE_Dcm_OpStatusType
/** @endcond */
/** \brief Type used for providing the status of service being processed, to the application */
typedef uint8 Dcm_OpStatusType;
#endif

#if !defined(RTE_TYPE_Dcm_NegativeResponseCodeType)
/** @cond */
#define RTE_TYPE_Dcm_NegativeResponseCodeType
/** @endcond */
/** \brief Type used for negative response codes */
typedef uint8 Dcm_NegativeResponseCodeType;
#endif

#if !defined(RTE_TYPE_Dcm_RoeStateType)
/** @cond */
#define RTE_TYPE_Dcm_RoeStateType
/** @endcond */
/** \brief Roe State types */
typedef uint8 Dcm_RoeStateType;
#endif

#if !defined(RTE_TYPE_Dcm_DTRStatusType)
/** @cond */
#define RTE_TYPE_Dcm_DTRStatusType
/** @endcond */
/** \brief Type used for providing the status of DTR's */
typedef uint8 Dcm_DTRStatusType;
#endif /* #if !defined(RTE_TYPE_Dcm_DTRStatusType) */

/** \brief Type of Requested Communication Mode for UDS Service 'CommunicationControl' */
typedef uint8 Dcm_CommunicationModeType;

/** \brief Return values of callout 'Dcm_ReadMemory' */
typedef uint8 Dcm_ReturnReadMemoryType;

/** \brief Return type of callout 'Dcm_WriteMemory' */
typedef uint8 Dcm_ReturnWriteMemoryType;

/** \brief Allows the DCM to know if a diagnostic response shall be sent in the case of a
**        jump from bootloader.
*/
typedef uint8 Dcm_EcuStartModeType;

/** \brief Type Used in Dcm_SetProgConditions() to allow the integrator to store relevant
**         information prior to jumping to bootloader
*/
/* !LINKSTO Dcm.EB.Dcm_ProgConditionsType, 1 */
typedef struct
{
   /** \brief Tester source address configured per protocol */
   uint16 TesterSourceAddr;
   /** \brief Id of the protocol on which the request has been received */
   uint8 ProtocolId;
   /** \brief Service identifier of the received request */
   uint8 Sid;
   /** \brief Identifier of the received subfunction */
   uint8 SubFncId;
   /** \brief Set/Clear the ReprogramingRequest flag on ECU reset*/
   boolean ReprogramingRequest;
   /** \brief Set/Clear the ApplUpdated flag on ECU reset*/
   boolean ApplUpdated;
   /** \brief Set/Clear the ResponseRequired flag on ECU reset*/
   boolean ResponseRequired;
}
Dcm_ProgConditionsType;

/** \brief Base type for diagnostic message item */
typedef uint8 Dcm_MsgItemType;

/** \brief Base type for diagnostic message ( request, positive or negative response) */
typedef P2VAR(Dcm_MsgItemType, AUTOMATIC, DCM_VAR) Dcm_MsgType;

/** \brief Length of diagnostic message */
typedef uint32 Dcm_MsgLenType;

/** \brief Additional information on message request. */
typedef struct
{
    /** \brief Addressing type of the request(0=physical request, 1=functional request) */
  unsigned int reqType:1;
  /** \brief Suppress positive response (0 = no (do not supress), 1 = yes (no positive response)) */
  unsigned int suppressPosResponse:1;
  /** \brief Messange type of the request(0 = ROE Message, 1 = Periodic Message, 2 = Others) */
  unsigned int messageType:2;
}
Dcm_MsgAddInfoType;

/** \brief Type for context identifier
 **        As a part of the message context the context identifier may be used to determine the
 **        relation between a diagnostic request the confirmation after sending the diagnostic
 **        response.
 */
typedef uint8 Dcm_IdContextType;

/** \brief This data structure contains all information which is necessary to process a diagnostic
 ** messagefrom request to response and response confirmation.
 */
typedef struct
{
  /** \brief Request data, starting directly after service identifier (which is not part of this data)
   */
  Dcm_MsgType reqData;

  /** \brief Request data length (excluding service identifier)
   */
  Dcm_MsgLenType reqDataLen;

  /** \brief Positive response data (excluding service identifier)
   */
  Dcm_MsgType resData;

  /** \brief Positive response data length (excluding service identifier)
   */
  Dcm_MsgLenType resDataLen;

  /** \brief Additional information about service request and response
   */
  Dcm_MsgAddInfoType msgAddInfo;

  /** \brief The maximal length of a response is restricted by the size of the buffer
   */
  Dcm_MsgLenType resMaxDataLen;

  /** \brief context identifier can be used to determine the relation between request and response
   ** confirmation
   */
  Dcm_IdContextType idContext;

  /** \brief Pdu identifier on which the request was received
   */
  PduIdType dcmRxPduId;
}
Dcm_MsgContextType;

/** \brief Type to indicate which kind of reset shall be realized by BswM */
typedef uint8 Dcm_ResetModeType;

/** \brief Type to indicate which kind of LinkControl shall be realized by Callout */
typedef uint8 Dcm_LinkControlRequestType;

/** \brief This data structure contains all information which is necessary to process a diagnostic
 ** messagefrom request to response and response confirmation.
 */

#if !defined(RTE_TYPE_Dcm_DidSupportedType)
/* !LINKSTO SWS_Dcm_01138,1 */
/** \brief Type used call-back functions for DidRanges, indicates if Dids are supported */
typedef uint8 Dcm_DidSupportedType;
#endif

/** \brief Pointer to message related information for one diagnostic request. */
typedef P2VAR(Dcm_MsgContextType, TYPEDEF, DCM_VAR) Dcm_MsgContextPtrType;

/*==================[external function declarations]=============================================*/

/*==================[internal function declarations]=============================================*/

/*==================[external constants]=========================================================*/

/*==================[internal constants]=========================================================*/

/*==================[external data]==============================================================*/

/*==================[internal data]==============================================================*/

/*==================[external function definitions]==============================================*/

/*==================[internal function definitions]==============================================*/
#endif /* if !defined( DCM_TYPES_H ) */
/*==================[end of file]================================================================*/
