/**
 * \file
 *
 * \brief AUTOSAR Dem
 *
 * This file contains the implementation of the AUTOSAR
 * module Dem.
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2017 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */
#if (!defined DEM_H)
#define DEM_H

/* This file contains or includes all external identifiers of
 * the AUTOSAR module Dem. */

/*==================[inclusions]============================================*/
/* !LINKSTO dsn.Dem.IncludeStr,1 */

#include <TSAutosar.h>                        /* EB specific standard types */
#include <Std_Types.h>                            /* AUTOSAR standard types */

#include <Dem_Types.h>           /* public Dem types, also generated by RTE */
#include <Dem_BSW_Types.h>                      /* public Dem RTE prototype */

#include <Dem_Stc.h>                        /* Module public static symbols */

#if (DEM_DCM_ENABLED == STD_ON)
#include <Dcm_Types.h>
#endif

/*==================[macros]================================================*/

/*------------------[DTC status indicators bits]----------------------------*/

#if (defined DEM_SI30_STATUS_UNCONFIRMEDDTC)
#error DEM_SI30_STATUS_UNCONFIRMEDDTC already defined
#endif
/** \brief DTC status indicator unconfirmed DTC status-bit */
#define DEM_SI30_STATUS_UNCONFIRMEDDTC      0x01U

#if (defined DEM_SI30_STATUS_UNCONFIRMEDDTC_TOC)
#error DEM_SI30_STATUS_UNCONFIRMEDDTC_TOC already defined
#endif
/** \brief DTC status indicator unconfirmed DTC in this operation cycle
 ** status-bit */
#define DEM_SI30_STATUS_UNCONFIRMEDDTC_TOC  0x02U

#if (defined DEM_SI30_STATUS_UNCONFIRMEDDTC_SLC)
#error DEM_SI30_STATUS_UNCONFIRMEDDTC_SLC already defined
#endif
/** \brief DTC status indicator unconfirmed DTC since last clear status-bit */
#define DEM_SI30_STATUS_UNCONFIRMEDDTC_SLC  0x04U

#if (defined DEM_SI30_STATUS_AGEDDTC)
#error DEM_SI30_STATUS_AGEDDTC already defined
#endif
/** \brief DTC status indicator aged DTC status-bit */
#define DEM_SI30_STATUS_AGEDDTC             0x08U

#if (defined DEM_SI30_STATUS_SYMPTOM_SLC)
#error DEM_SI30_STATUS_SYMPTOM_SLC already defined
#endif
/** \brief DTC status indicator symptom since last clear status-bit */
#define DEM_SI30_STATUS_SYMPTOM_SLC         0x10U

#if (defined DEM_SI30_STATUS_WIR_SLC)
#error DEM_SI30_STATUS_WIR_SLC already defined
#endif
/** \brief DTC status indicator warning indicator request since last clear
 ** status-bit */
#define DEM_SI30_STATUS_WIR_SLC             0x20U

#if (defined DEM_SI30_STATUS_EMISSIONRELATEDDTC)
#error DEM_SI30_STATUS_EMISSIONRELATEDDTC already defined
#endif
/** \brief DTC status indicator emission related DTC status-bit */
#define DEM_SI30_STATUS_EMISSIONRELATEDDTC  0x40U

#if (defined DEM_SI30_STATUS_TFSLC_AGED)
#error DEM_SI30_STATUS_TFSLC_AGED already defined
#endif
/** \brief DTC status indicator test failed since last clear or aged
 ** status-bit */
#define DEM_SI30_STATUS_TFSLC_AGED          0x80U

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

#define DEM_START_SEC_CODE
#include <MemMap.h>

#if (DEM_VERSION_INFO_API == STD_ON)
/** \brief This service returns the version information of this module.
 **
 ** The version information includes:
 ** - Module Id
 ** - Vendor Id
 ** - Vendor specific version numbers (BSW00407).
 **
 ** This function shall be pre compile time configurable On/Off by the
 ** configuration parameter: DEM_VERSION_INFO_API
 **
 ** \param[out] versioninfo  Pointer to where to store the version information
 **                          of this module.
 **
 ** \ServiceID{::DEM_SID_GetVersionInfo}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_GetVersionInfo(
  P2VAR(Std_VersionInfoType, AUTOMATIC, DEM_APPL_DATA) versioninfo);
#endif /* DEM_VERSION_INFO_API == STD_ON */

/*------------------[Interface ECU State Manager <--> Dem]------------------*/

/** \brief PreInit function to make the Dem queue operational
 **
 ** This function shall be used to initialize the internal states necessary to
 ** process events reported by BSWs
 **
 ** Dem_PreInit() shall be called by the ECU State Manager during the startup
 ** phase of the ECU before the NVRAM Manager has finished the restore of
 ** NVRAM data.
 **
 ** \param[in] ConfigPtr  refer to ::Dem_ConfigType
 **
 ** \ServiceID{::DEM_SID_PreInit}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_PreInit(
  P2CONST(Dem_ConfigType, AUTOMATIC, DEM_APPL_CONST) ConfigPtr);

/** \brief Initializes or reinitializes the Dem module.
 **
 ** This function shall be used during the startup phase of the ECU after
 ** the NVRAM Manager has finished the restore of NVRAM data.
 **
 ** SW-Components including Monitor Functions are initialized afterwards.
 **
 ** Caveats: The Dem is not functional until this function has been called.
 **
 ** \ServiceID{::DEM_SID_Init}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_Init(void);

/** \brief Shutdown function
 **
 ** This function is used to complete all pending operations in the Dem
 ** by preparing the internal states and event data for transfer to the NVRAM
 **
 ** Caveats: Once this function has been executed no further updates
 ** are applied to the Dem internal event data.
 **
 ** \ServiceID{::DEM_SID_Shutdown}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_Shutdown(void);

/*------------------[Interface BSW modules / SW-Components <--> Dem]--------*/

/** \brief Function to report the status of diagnostic events of BSW
 **
 ** Interface for BSW Components to report Errors during start up (even before
 ** Dem initialization) and normal operation. At a first step, it is assumed,
 ** that all incoming results are considered as debounced. If a central
 ** pre-debouncing is provided, this API shall be used to support them for the
 ** BSW.
 **
 ** Configurations: The size of the buffer queue needs to be configured (ref.
 ** to DEM_BSW_ERROR_BUFFER_SIZE)
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] EventStatus  Monitor test result
 **
 ** \ServiceID{::DEM_SID_ReportErrorStatus}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Asynchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ReportErrorStatus(
  Dem_EventIdType     EventId,
  Dem_EventStatusType EventStatus);

#if (DEM_INCLUDE_RTE == STD_OFF)

/** \brief Processes the events reported by SW-Cs via RTE
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim. Some bits of the UDS DTC status
 ** byte changes synchronously or asynchronously (refer to Dem036 and Dem379).
 **
 ** Service for reporting the Event Status to the Dem. This service shall be
 ** used to report an Event Status as soon as a new test result is available.
 **
 ** This Service stores the event in the Event Memory.
 **
 ** API is called from the Monitor Function.
 **
 ** Caveats: Dem configuration during integration of Monitor Functions is
 ** system specific.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 **
 ** \param[in] EventStatus Monitor test result
 **
 ** \return success of operation
 ** \retval E_OK     set of event status was successful
 ** \retval E_NOT_OK set of event status failed or could not be accepted
 **
 ** \ServiceID{::DEM_SID_SetEventStatus}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous/Asynchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetEventStatus(
  Dem_EventIdType     EventId,
  Dem_EventStatusType EventStatus);

/** \brief Resets the event failed status
 **
 ** This API can only be used through the RTE and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 ** This service shall be used to reset the Event Status stored in the Event
 ** Memory in the Dem, without the usage of API Dem_SetEventStatus(EventId,
 ** Passed), because no new test result is available at this time.
 **
 ** With this API the status bit "Failed" defined by
 ** Dem_EventStatusExtendedType is set to 0. API is called by Monitor
 ** Function.
 **
 ** Refer to ISO14229: DTC Status Bit Definition, Table D.14, Bit0 Test
 ** failed.
 **
 ** Dem_ResetEventStatus does not influence the status bit 6
 ** ("testNotCompletedThisMonitoringCycle")
 **
 ** Caveats: Dem configuration during integration of Monitor Functions is
 ** is system specific
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 **
 ** \return success of operation
 ** \retval E_OK     reset of event status was successful
 ** \retval E_NOT_OK reset of event status failed
 **
 ** \ServiceID{::DEM_SID_ResetEventStatus}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_ResetEventStatus(
  Dem_EventIdType EventId);

/** \brief Captures the freeze frame data for a specific event
 **
 ** This API can only be used through the RTE and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** If the Dem does not receive any request to pre-store a freeze frame,
 ** freeze frame capture is linked to the API call Dem_SetEventStatus(). This
 ** API call triggers the freeze frame storage.
 **
 ** If Dem_SetEventStatus(EventId, Passed) is called the corresponding
 ** pre-stored freeze frame is discarded (same behavior like
 ** Dem_ClearPrestoredFreezeFrame()). The API call Dem_ResetEventStatus() does
 ** not influence the pre-stored freeze frame.
 **
 ** API is called from Monitor Function.
 **
 ** Caveats: Dem configuration during integration of Monitor Functions is
 ** system specific.
 **
 ** Configuration: While configuring the Dem the capability of pre-store
 ** functionality for the required event has to be defined.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 **
 ** \return success of operation
 ** \retval E_OK     PreStoreFreezeFrame was successful
 ** \retval E_NOT_OK PreStoreFreezeFrame failed
 **
 ** \ServiceID{::DEM_SID_PrestoreFreezeFrame}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_PrestoreFreezeFrame(
  Dem_EventIdType EventId);

/** \brief Clears a prestored freeze frame of a specific event
 **
 ** This API can only be used through the RTE and therefore no declaration
 ** is exported via \verbatim Dem.h\endverbatim.
 **
 ** The API shall be called to delete or release the prestored freeze frame for
 ** specific Event ID. If the API Dem_SetEventStatus() (passed | failed) is
 ** called it has the same effect - that means it's not necessary to call the
 ** API Dem_ClearPrestoredFreezeFrame() directly after Dem_SetEventStatus().
 **
 ** Caveats: Dem configuration during integration of Monitor Functions is
 ** system specific.
 **
 ** Configuration: While configuring the Dem the capability of pre-store
 ** functionality for the required event has to be defined.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 **
 ** \return success of operation
 ** \retval E_OK     ClearPreStoreFreezeFrame was successful
 ** \retval E_NOT_OK ClearPreStoreFreezeFrame failed
 **
 ** \ServiceID{::DEM_SID_ClearPrestoredFreezeFrame}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_ClearPrestoredFreezeFrame(
  Dem_EventIdType EventId);

/** \brief Sets an operation cycle state
 **
 ** Dem shall be called by the SW-Component as soon as it detects the status
 ** change of the CycleState for the Operation Cycle.
 **
 ** Configuration: The OperationCycleId shall be configured in view of sender
 ** receiver communication.
 **
 ** \param[in] OperationCycleId  Identification of operation cycle, like power
 **                     cycle, driving cycle,  ... (0 <= OpCycleId < DEM_NUM_OPCYCLES)
 **
 ** \param[in] CycleState  New operation cycle state: (re-)start or end
 **
 ** \return success of operation
 ** \retval E_OK     set of operation cycle was successful
 ** \retval E_NOT_OK set of operation cycle failed
 **
 ** \ServiceID{::DEM_SID_SetOperationCycleState}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetOperationCycleState(
  Dem_OperationCycleIdType    OperationCycleId,
  Dem_OperationCycleStateType CycleState);

/** \brief Provides the value of the external operation cycle counter
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** \param[in] OperationCycleId  Identification of operation cycle, like power
 **                     cycle, driving cycle,  ... (0 <= OpCycleId < DEM_NUM_OPCYCLES)
 ** \param[in] CounterValue  Current external counter value of the respective operation
 **                     cycle.
 **
 ** \return success of operation
 ** \retval E_OK      set of operation cycle counter was successful
 ** \retval E_NOT_OK  set of operation cycle counter failed
 **
 ** \ServiceID{::DEM_SID_SetOperationCycleCntValue}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetOperationCycleCntValue(
  uint8 OperationCycleId,
  uint8 CounterValue);

#if ( (DEM_AGINGCYCLE_COUNTER_PROCESSING == DEM_PROCESS_AGINGCTR_INTERN) && \
      (DEM_NUM_AGINGCYCLES > 0U) )
/** \brief Triggers the next aging cycle state
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** \param[in] AgingCycleId  Identification of aging cycle.
 **
 ** \return success of operation
 ** \retval E_OK      set of aging cycle was successful
 ** \retval E_NOT_OK  set of aging cycle failed
 **
 ** \ServiceID{::DEM_SID_SetAgingCycleState}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetAgingCycleState(
  uint8 AgingCycleId);
#endif

/** \brief Provides the value of the external aging cycle counter
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** \param[in] CounterValue  Current external aging cycle counter value.
 **
 ** \return success of operation
 ** \retval E_OK      set of aging cycle counter was successful
 ** \retval E_NOT_OK  set of aging cycle counter failed
 **
 ** \ServiceID{::DEM_SID_SetAgingCycleCounterValue}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetAgingCycleCounterValue(
  uint8 CounterValue);

#if (DEM_USER_CTRL_WIR_SUPPORT == STD_ON)
/** \brief Sets the WIR status bit via failsafe SW-Cs.
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** \param[in] EventId    Identification of an event by assigned EventId.
 **                       The Event Number is configured in the DEM.
 **                       Min.: 1 (0: Indication of no Event or Failure)
 **                       Max.:Result of configuration of Event Numbers in
 **                       DEM (Max is either 255 or 65535).
 ** \param[in] WIRStatus  Requested status of event related WIR-bit (regarding
 **                       to the current status of function inhibition).
 **                       WIRStatus = TRUE -> WIR-bit shall be set to "1"
 **                       WIRStatus = FALSE -> WIR-bit shall be set to "0"
 **
 ** \return success of operation
 ** \retval E_OK      The request is accepted.
 ** \retval E_NOT_OK  The request is not accepted (e.g. disabled controlDTCSetting)
 **                   and should be repeated.
 **
 ** \ServiceID{::DEM_SID_SetWIRStatus}
 ** \Reentrancy{Reentrant for different EventIds. Non reentrant for the same EventId.}
 ** \Synchronicity{Synchronous}
 **
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetWIRStatus(
  Dem_EventIdType EventId, boolean WIRStatus);
#endif
#endif /* (DEM_INCLUDE_RTE == STD_OFF) */

#if ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL))

/** \brief Gets the current extended event status of an event
 **
 ** This API shall be used to read the event status from the Dem. This API is
 ** provided to be used by SW-Components or other basic software modules
 ** e.g. FiM.
 **
 ** For the DCM the API Dem_GetStatusOfDTC() is used.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[out] EventStatusExtended  for explanation see
 **                     ::Dem_EventStatusExtendedType
 **
 ** \return success of operation
 ** \retval E_OK     get of event status was successful
 ** \retval E_NOT_OK get of event status failed
 **
 ** \ServiceID{::DEM_SID_GetEventStatus}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventStatus(
  Dem_EventIdType EventId,
  P2VAR(Dem_EventStatusExtendedType, AUTOMATIC, DEM_APPL_DATA)
    EventStatusExtended);

/** \brief Gets the event failed status of an event
 **
 ** This API shall be used to read Bit 0 of ::Dem_EventStatusExtendedType from
 ** the Dem.
 **
 ** For the DCM the API Dem_GetStatusOfDTC() is used.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[out] EventFailed
 **                     - TRUE Last Failed
 **                     - FALSE not Last Failed
 **
 ** \return success of operation
 ** \retval E_OK     get of event failed was successful
 ** \retval E_NOT_OK get of event failed failed
 **
 ** \ServiceID{::DEM_SID_GetEventFailed}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventFailed(
  Dem_EventIdType                          EventId,
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) EventFailed);

/** \brief Gets the event tested status of an event
 **
 ** This API shall be used to read negated Bit 6 of
 ** ::Dem_EventStatusExtendedType from the Dem.
 **
 ** For the DCM the API Dem_GetStatusOfDTC() is used.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[out] EventTested
 **                     - TRUE event tested this cycle
 **                     - FALSE event not tested this cycle
 **
 ** \return success of operation
 ** \retval E_OK     get of event state "tested" was successful
 ** \retval E_NOT_OK get of event state "tested" failed
 **
 ** \ServiceID{::DEM_SID_GetEventTested}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventTested(
  Dem_EventIdType                          EventId,
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) EventTested);

/** \brief Function to get the DTC of an event
 **
 ** Gets the DTC which is mapped to EventId by Dem Configuration.
 **
 ** Configuration: Mapping of Events to DTCs is configured in Dem. Mapping is
 ** "n to 1" or "1 to n".
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] DTCFormat  This parameter defines the output-format of the
 **                     requested DTC value, either OBD DTC format or
 **                     UDS DTC format.
 ** \param[out] DTCOfEvent  Receives the DTC value returned by the function.
 **                     If the return value of the function is other than
 **                     OK this parameter does not contain valid data.
 **
 ** \return success of operation
 ** \retval E_OK                   get of DTC was successful
 ** \retval E_NOT_OK               get of DTC failed
 ** \retval DEM_E_NO_DTC_AVAILABLE there is no DTC configured in the requested
 **                     format
 **
 ** \ServiceID{::DEM_SID_GetDTCOfEvent}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetDTCOfEvent(
  Dem_EventIdType                              EventId,
  Dem_DTCFormatType                            DTCFormat,
  P2VAR(Dem_DTCType, AUTOMATIC, DEM_APPL_DATA) DTCOfEvent);

#if (DEM_NUM_ENABLECONDITIONS > 0U)
/** \brief Function to set enable condition
 **
 ** This API shall be used to set the enable condition. For each event an
 ** enable condition value is assigned to. An enable condition specifies
 ** a certain number of checks (e.g. correct voltage range) for an event
 ** before the event can be qualified as confirmed.
 **
 ** Configuration: Required configuration parameters per event:
 **                - EnableConditionID
 **                - EnableConditionStatus
 **
 ** This API is optional and depends on the automotive manufacturer.
 **
 ** \param[in] EnableConditionID  This parameter identifies the enable
 **                condition.
 ** \param[in] ConditionFulfilled  This parameter specifies whether the
 **                enable condition assigned to the EnableConditionID
 **                is fulfilled (TRUE) or not fulfilled (FALSE).
 **
 ** \return success of operation
 ** \retval E_OK       enable condition could be set successfully
 ** \retval E_NOT_OK   enable condition could not be set
 **
 ** \ServiceID{::DEM_SID_SetEnableCondition}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API is not available, if no enable condition are configured.
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetEnableCondition(
  uint8   EnableConditionID,
  boolean ConditionFulfilled);
#endif

/** \brief Sets a storage condition.
 **
 ** \param[in] StorageConditionID  This parameter identifies the storage condition.
 ** \param[in] ConditionFulfilled  This parameter specifies whether the
 **                enable condition assigned to the EnableConditionID
 **                is fulfilled (TRUE) or not fulfilled (FALSE).
 **
 ** \return success of operation
 ** \retval E_OK       storage condition could be set successfully
 ** \retval E_NOT_OK   storage condition could be set
 **
 ** \ServiceID{::DEM_SID_SetStorageCondition}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetStorageCondition(
  uint8   StorageConditionID,
  boolean ConditionFulfilled);

#endif /* ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL)) */

#if (DEM_INCLUDE_RTE == STD_OFF)

/** \brief Gets the fault detection counter of an event
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** The API shall be used by SW-C to request the current Fault Detection
 ** Counter for a given EventID.
 **
 ** \param[in] EventId  Provide the EventId value the fault detection counter
 **                     is requested for. If the return value of the function
 **                     is other than OK this parameter does not contain valid
 **                     data.
 ** \param[out] FaultDetectionCounter  This parameter receives the
 **                     Fault Detection Counter information of the requested
 **                     EventId. If the return value of the function call is
 **                     other than OK this parameter does not contain valid data.
 **
 ** \return success of operation
 ** \retval E_OK     request of severity was successful
 ** \retval E_NOT_OK request of severity failed
 **
 ** \ServiceID{::DEM_SID_GetFaultDetectionCounter}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetFaultDetectionCounter(
  Dem_EventIdType EventId,
  P2VAR(Dem_FaultDetectionCounterType, AUTOMATIC, DEM_APPL_DATA)
    FaultDetectionCounter);

#endif /* (DEM_INCLUDE_RTE == STD_OFF) */

#if ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL))

#if (DEM_NUMBER_OF_INDICATORS > 0U)
/** \brief Reads the indicator-status
 **
 ** This function shall be used to read the indicator-status derived from the
 ** event status as a summary of all assigned events.
 **
 ** Configuration: The assignment for the Dem_IndicatorId to indicator has to
 ** be done. Examples for indicators: lamps, different text messages, icons,
 ** ...
 **
 ** \param[in] IndicatorId  Number of indicator
 ** \param[out] IndicatorStatus  Status of the indicator, like on, off,
 **                              blinking.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed or is not supported
 **
 ** \ServiceID{::DEM_SID_GetIndicatorStatus}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API is not available, if no indicators are configured.
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetIndicatorStatus(
  Dem_IndicatorIdType                                      IndicatorId,
  P2VAR(Dem_IndicatorStatusType, AUTOMATIC, DEM_APPL_DATA) IndicatorStatus);
#endif

#endif /* ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL)) */

#if ( (DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL) || \
      ( (DEM_DEFAULT_ASR_SERVICE_API != DEM_SERVICE_API_ASR40) && \
        (DEM_ENABLE_ASR40_SERVICE_API == STD_OFF) ) )
/** \brief Gets the data of a freeze frame by event.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] RecordNumber  This parameter is a unique identifier for a
 **                     freeze frame record as defined in ISO15031-5
 **                     and ISO14229-1.
 ** \param[in] ReportTotalRecord  This parameter specifies whether all
 **                     PIDs/DIDs are requested (TRUE). A dedicated
 **                     PID/DID is requested by the parameter DataId
 **                     (FALSE)
 ** \param[in] DataId  This parameter specifies the PID/DID that shall be
 **                     copied to the destination buffer. If ReportTotalRecord
 **                     is TRUE, the value of DataId is ignored.
 ** \param[out] DestBuffer  This parameter contains a byte pointer that points
 **                     to the buffer, to which the freeze frame data record
 **                     shall be written to. The format is raw hexadecimal
 **                     values and contains no header-information.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_GetEventFreezeFrameData}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventFreezeFrameData(
  Dem_EventIdType                        EventId,
  uint8                                  RecordNumber,
  boolean                                ReportTotalRecord,
  uint16                                 DataId,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) DestBuffer);
#endif

#if ( (DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL) || \
      ( (DEM_DEFAULT_ASR_SERVICE_API != DEM_SERVICE_API_ASR42) && \
        (DEM_ENABLE_ASR42_SERVICE_API == STD_OFF) ) )
/** \brief Gets the data of a freeze frame by event.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] RecordNumber  This parameter is a unique identifier for a
 **                     freeze frame record as defined in ISO15031-5
 **                     and ISO14229-1.
 ** \param[in] ReportTotalRecord  This parameter specifies whether all
 **                     PIDs/DIDs are requested (TRUE). A dedicated
 **                     PID/DID is requested by the parameter DataId
 **                     (FALSE)
 ** \param[in] DataId  This parameter specifies the PID/DID that shall be
 **                     copied to the destination buffer. If ReportTotalRecord
 **                     is TRUE, the value of DataId is ignored.
 ** \param[out] DestBuffer  This parameter contains a byte pointer that points
 **                     to the buffer, to which the freeze frame data record
 **                     shall be written to. The format is raw hexadecimal
 **                     values and contains no header-information.
 **
 ** \return success of operation
 ** \retval E_OK                    Operation was successful
 ** \retval DEM_E_NODATAAVAILABLE   The requested event data is not currently
 **                                 stored (but the request was valid)
 ** \retval DEM_E_WRONG_RECORDNUMBER  The requested record number is not
 **                                   supported by the event
 ** \retval DEM_E_WRONG_DIDNUMBER   The requested DID is not supported by
 **                                 the freeze frame
 ** \ServiceID{::DEM_SID_GetEventFreezeFrameData}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_ASR42_GetEventFreezeFrameData(
  Dem_EventIdType                        EventId,
  uint8                                  RecordNumber,
  boolean                                ReportTotalRecord,
  uint16                                 DataId,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) DestBuffer);
#endif

#if ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL))

/** \brief Gets the data of an extended data record by event
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[in] RecordNumber  Identification of requested Extended data record.
 **                     Valid values are between 0x01 and 0xEF as defined in.
 **                     ISO14229-1. 0xFF means data of all extended data records
 **                     are returned
 ** \param[out] DestBuffer  This parameter contains a byte pointer that points
 **                     to the buffer, to which the extended data shall be
 **                     written to. The format is raw hexadecimal values and
 **                     contains no header-information.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_GetEventExtendedDataRecord}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventExtendedDataRecord(
  Dem_EventIdType                        EventId,
  uint8                                  RecordNumber,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) DestBuffer);

/** \brief Gets the event memory overflow indication status.
 **
 ** \param[in] DTCOrigin  If the Dem supports more than one event
 **                     memory this parameter is used to select
 **                     the source memory the overflow indication
 **                     shall be read from.
 ** \param[out] OverflowIndication  This parameter returns TRUE if the
 **                     respective event memory was overflowed, otherwise it
 **                     returns FALSE
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed or is not supported
 **
 ** \ServiceID{::DEM_SID_GetEventMemoryOverflow}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetEventMemoryOverflow(
  Dem_DTCOriginType                        DTCOrigin,
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) OverflowIndication);

/** \brief Gets the number of entries currently stored in the event memory.
 **
 ** \param[in] DTCOrigin   If the Dem supports more than one event
 **                        memory this parameter is used to select
 **                        the source memory the number of entries
 **                        shall be read from.
 ** \param[out] NumberOfEventMemoryEntries   This parameter returns
 **                        the number of entries currently stored
 **                        in the requested event memory.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed or is not supported
 **
 ** \ServiceID{::DEM_SID_GetNumberOfEventMemoryEntries}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetNumberOfEventMemoryEntries(
  Dem_DTCOriginType                      DTCOrigin,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) NumberOfEventMemoryEntries);

#if (DEM_EXTENDED_DATA_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD)
/** \brief Gets the SI30 Status by event.
 **
 ** \param[in] EventId  Identification of an Event by assigned Event ID.
 **                     The Event ID is configured in the Dem.
 ** \param[out] Status  Pointer to variable which contains the SI30 status
 **                     of the event
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_GetSI30Status}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetSI30Status(
  Dem_EventIdType                        EventId,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Status);

#if (DEM_SUPPORT_FIM_ON_FDC_TRESHOLD == STD_ON)
/** \brief Set SymptomSinceLastClear (SI30.bit4).
 **
 ** \param[in] EventId  Identification of the Event for which the status shall be set.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_SetSI30Symptom}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetSI30Symptom(
  Dem_EventIdType                        EventId);

/** \brief Sets the SI30 Status by event.Set WarningIndicatorRequestedSinceLastClear (SI30.bit5).
 **
 ** \param[in] EventId  Identification of the Event for which the status shall be set.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_SetSI30Notification}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetSI30Notification(
  Dem_EventIdType                        EventId);
#endif /* DEM_SUPPORT_FIM_ON_FDC_TRESHOLD == STD_ON */
#endif /* DEM_EXTENDED_DATA_CAPTURE == DEM_TRIGGER_ON_FDC_THRESHOLD */

/** \brief Set the suppression status of a specific DTC.
 **
 ** \param[in] DTC  Diagnostic Trouble Code
 ** \param[in] DTCFormat  Defines the input-format of the provided DTC value.
 ** \param[in] SuppressionStatus  This parameter specifies whether
 **                     the respective DTC shall be disabled (TRUE)
 **                     or enabled (FALSE).
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed or event entry for this DTC still exists
 **
 ** \ServiceID{::DEM_SID_SetDTCSuppression}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetDTCSuppression(
  uint32            DTC,
  Dem_DTCFormatType DTCFormat,
  boolean           SuppressionStatus);

#endif /* ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL)) */

/*------------------[Interface Dcm <--> Dem]--------------------------------*/

/* --- Access DTCs and Status Information --- */

/** \brief Allows filtering for DTCs with severity information.
 **
 ** This API shall be used for the API's
 ** Dem_GetNextFilteredDTC(), Dem_GetNextFilteredDTCAndFDC() and
 ** Dem_GetNextFilteredDTCAndSeverity().
 ** The function resets the internal counter to the first event that
 ** matches the filter settings. The filter mask attributes are used until
 ** the next call of Dem_SetDTCFilter() or Dem_Init().
 **
 ** \param[in] DTCStatusMask  Status-byte mask for DTC status-byte filtering
 **                       Values:
 **                       0x00: Autosar-specific value to deactivate the
 **                       status-byte filtering (different meaning than in
 **                       ISO 14229-1) to report all supported DTCs (used for
 **                       service 0x19 subfunctions 0x0A/0x15)
 **                       0x01...0xFF: Status-byte mask according to
 **                       ISO 14229-1 DTCStatusMask (handed over by Dcm from
 **                       service request directly) to filter for DTCs with
 **                       at least one status bit set matching this
 **                       status-byte mask
 ** \param[in] DTCKind  Defines the functional group of DTCs to be reported
 **                       (e.g. all DTC, OBD-relevant related DTC)
 ** \param[in] DTCFormat  Defines the output-format of the requested DTC
 **                       values for the sub-sequent API calls.
 ** \param[in] DTCOrigin  If the Dem supports more than one event memory this
 **                       parameter is used to select the source memory the
 **                       DTCs shall be read from.
 ** \param[in] FilterWithSeverity  This flag defines whether severity
 **                       information (ref. to parameter below) shall be used
 **                       for filtering. This is to allow for coexistence of
 **                       DTCs with and without severity information.
 ** \param[in] DTCSeverityMask  This parameter contains the DTCSeverityMask
 **                       according to ISO14229-1.
 ** \param[in] FilterForFaultDetectionCounter  This flag defines whether
 **                       Fault Detection Counter information shall be used for
 **                       filtering. This is to allow for coexistence of DTCs
 **                       with and without Fault Detection Counter information.
 **                       If Fault Detection Counter information is a filter
 **                       criteria, only those DTCs with a Fault Detection
 **                       Counter value between 1 and 0x7E shall be reported.
 **
 ** Remark: If the event does not uses the debouncing inside Dem, then the
 ** Dem must request this information via Xxx_DemGetFaultDetectionCounter.
 **
 ** \return Dem_ReturnSetFilterType -> Status of the operation to
 **                       (re-)set a DTC filter.
 **
 ** \ServiceID{::DEM_SID_SetDTCFilter}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnSetFilterType, DEM_CODE) Dem_SetDTCFilter(
  Dem_DTCStatusMaskType      DTCStatusMask,
  Dem_DTCKindType            DTCKind,
  Dem_DTCFormatType          DTCFormat,
  Dem_DTCOriginType          DTCOrigin,
  Dem_FilterWithSeverityType FilterWithSeverity,
  Dem_DTCSeverityType        DTCSeverityMask,
  Dem_FilterForFDCType       FilterForFaultDetectionCounter);

/** \brief Sets a freeze frame record filter
 **
 ** The filtered freeze frame records can be retrieved by the function
 ** Dem_GetNextFilteredRecord(). This filter always belongs to primary memory.
 **
 ** \param[in] DTCFormat  Defines the output-format of the requested DTC
 **                       values for the sub-sequent API calls.
 ** \param[out] NumberOfFilteredRecords  Number of freeze frame records
 **                       currently stored in the event memory.
 **
 ** \return Status of the operation of type ::Dem_ReturnSetFilterType
 **
 ** \ServiceID{::DEM_SID_SetFreezeFrameRecordFilter}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnSetFilterType, DEM_CODE) Dem_SetFreezeFrameRecordFilter(
  Dem_DTCFormatType                       DTCFormat,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) NumberOfFilteredRecords);

/** \brief Gets the status of a DTC
 **
 ** For large configurations and DTC-calibration, the interface behavior can
 ** be asynchronous (splitting the DTC-search into segments).
 **
 ** This API shall be used to read the status of a DTC to the parameter
 ** DTCStatus according to ISO14229.
 **
 ** \param[in] DTC  Diagnostic Trouble Code in UDS format.
 ** \param[in] DTCOrigin  If the Dem supports more than one event memory this
 **                     parameter is used to select the source memory the DTCs
 **                     shall be read from.
 ** \param[out] DTCStatus  This parameter receives the status information of
 **                     the requested DTC. If the return value of the function
 **                     call is other than OK this parameter does not contain
 **                     valid data.
 **
 ** \return Status of the operation of type ::Dem_ReturnGetStatusOfDTCType
 **
 ** \ServiceID{::DEM_SID_GetStatusOfDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetStatusOfDTCType, DEM_CODE) Dem_GetStatusOfDTC(
  Dem_DTCType                                            DTC,
  Dem_DTCOriginType                                      DTCOrigin,
  P2VAR(Dem_DTCStatusMaskType, AUTOMATIC, DEM_APPL_DATA) DTCStatus);

/** \brief Gets the DTC Status availability mask
 **
 ** The API shall be used to get the DTC status availability mask, i.e.
 ** the DTC status information (according to ISO14229) supported by the Dem.
 **
 ** Only supported bits can be used as filter parameters in the API
 ** Dem_SetDTCFilter().
 **
 ** \param[out] DTCStatusMask  The value from type ::Dem_DTCStatusMaskType
 **                   indicates the supported DTC status bits from the Dem.
 **                   All supported information is indicated by setting the
 **                   corresponding status bit to 1.
 **
 ** \return success of operation
 ** \retval E_OK     get of DTC status availability mask was successful
 ** \retval E_NOT_OK get of DTC status availability mask failed
 **
 ** \ServiceID{::DEM_SID_GetDTCStatusAvailabilityMask}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetDTCStatusAvailabilityMask(
  P2VAR(Dem_DTCStatusMaskType, AUTOMATIC, DEM_APPL_DATA) DTCStatusMask);

/** \brief Gets the number of a filtered DTC
 **
 ** The API shall be used to get the number of DTCs matching the defined status
 ** mask. The DTC Status mask filter is set by the API Dem_SetDTCFilter.
 **
 ** Caveats: DTC filter has been set up properly before function call
 ** (Dem_SetDTCFilter()).
 **
 ** \param[out] NumberOfFilteredDTC  The number of DTCs matching the defined
 **                                  status mask.
 **
 ** \return Status of the operation to retrieve a number of DTC from the Dem.
 ** \retval DEM_NUMBER_OK     Get of number of DTC was successful
 ** \retval DEM_NUMBER_FAILED Get of number of DTC failed
 ** \retval DEM_NUMBER_PENDING Get of number of DTC is pending
 **
 ** \ServiceID{::DEM_SID_GetNumberOfFilteredDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Asynchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetNumberOfFilteredDTCType, DEM_CODE)
  Dem_GetNumberOfFilteredDTC(
    P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) NumberOfFilteredDTC);

/** \brief Gets the next filtered DTC
 **
 ** The API shall be used to return the current DTC and its associated status
 ** from the Dem matching the filter criteria defined by the API call
 ** Dem_SetDTCFilter. After having returned the data the function skips to the
 ** next DTC matching the filter criteria.
 **
 ** To receive all DTCs matching the filter criteria this function shall
 ** called continuously until the return value of the function is
 ** "NoMatchingDTC".
 **
 ** The chronological order shall be reported if the DTC status mask parameter
 ** is set to "pending" and/or "confirmed" (no other status bits are allowed
 ** to be set). The function shall start with the most recent DTC. The
 ** chronological order may vary with the customer specific attributes used by
 ** the algorithm for sorting the DTC records (e.g. pre-sorted records or
 ** time-stamp attributes of the records).
 **
 ** \param[out] DTC  Receives the DTC value in respective format of the filter
 **                  returned by this function. If the return value of the
 **                  function is other than DEM_FILTERED_OK this parameter
 **                  does not contain valid data
 ** \param[out] DTCStatus  This parameter receives the status information of
 **                  the requested DTC. If the return value of the function
 **                  call is other than OK this parameter does not contain
 **                  valid data.
 **
 ** \return Status of the operation to retrieve a DTC from the Dem.
 **                  The value DEM_FILTERED_PENDING is never returned (because
 **                  of synchronous behavior).
 **
 ** \ServiceID{::DEM_SID_GetNextFilteredDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetNextFilteredDTCType, DEM_CODE) Dem_GetNextFilteredDTC(
  P2VAR(Dem_DTCType, AUTOMATIC, DEM_APPL_DATA)           DTC,
  P2VAR(Dem_DTCStatusMaskType, AUTOMATIC, DEM_APPL_DATA) DTCStatus);

#if (DEM_GET_DTCBYOCCURRENCETIME_SUPPORT == STD_ON)
/** \brief Gets the DTC by occurrence time
 **
 ** The API provides the capability to access specific events stored at
 ** certain important points in time. The API call will return one DTC
 ** according to the ::Dem_DTCRequestType. If no DTC is matching at the requested
 ** point in time, the function will return the appropriate operation status
 ** and the DTC value will be zero (0).
 **
 ** \param[in] DTCRequest  This parameter defines the request type of the DTC.
 ** \param[out] DTC  Receives the DTC value in UDS format returned by the
 **                  function. If the return value of the function is other
 **                  than DEM_OCCURR_OK this parameter does not contain valid
 **                  data.
 **
 ** \return Status of the operation of type
 **                  ::Dem_ReturnGetDTCByOccurrenceTimeType
 **
 ** \ServiceID{::DEM_SID_GetDTCByOccurrenceTime}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetDTCByOccurrenceTimeType, DEM_CODE)
  Dem_GetDTCByOccurrenceTime(
    Dem_DTCRequestType                           DTCRequest,
    P2VAR(Dem_DTCType, AUTOMATIC, DEM_APPL_DATA) DTC);
#endif

/** \brief gets the next freeze frame record number and its associated DTC
 ** stored in the event memory.
 **
 ** The API shall be used to get the next freeze frame record
 ** number and its associated DTC stored in the event memory. After having returned the
 ** data the function skips to the next Record matching the filter criteria.
 ** To receive all Records matching the filter criteria this function shall
 ** called continuously until the return value of the function is
 ** "NoMatchingDTC".The interface has an asynchronous behavior,
 ** because NVRAM access might be required.
 **
 ** \param[out] DTC  Receives the DTC value in respective format of the filter
 **                  returned by this function. If the return value of the
 **                  function is other than DEM_FILTERED_OK this parameter
 **                  does not contain valid data.
 ** \param[out] RecordNumber  Freeze frame record number of the reported DTC
 **                  (relative addressing). If the return value of the
 **                  function is other than DEM_FILTERED_OK this
 **                  parameter does not contain valid data.
 **
 ** \return Status of the operation to retrieve a DTC and its associated
                     snapshot record number from the Dem.
 **
 ** \ServiceID{::DEM_SID_GetNextFilteredRecord}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Asynchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetNextFilteredDTCType, DEM_CODE)
  Dem_GetNextFilteredRecord(
    P2VAR(Dem_DTCType, AUTOMATIC, DEM_APPL_DATA) DTC,
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)       RecordNumber);

/** \brief returns next filtered fault detection counter
 **
 ** The API shall be used to return the current DTC and its associated Fault
 ** Detection Counter (FDC)from the Dem, matching the filter criteria defined
 ** by the API call Dem_SetDTCFilter. After having returned the data the
 ** function skips to the next DTC matching the filter criteria.
 ** To receive all DTCs matching the filter criteria this function shall be
 ** called continuously until the return value of the function is
 ** "NoMatchingDTC".The interface has an asynchronous behavior,
 ** because the FDC might be received asynchronously from a SW-C, too.
 **
 ** \param[out] DTC  Receives the DTC value in respective format of the filter
 **                  returned by this function. If the return value of the
 **                  function is other than DEM_FILTERED_OK this parameter
 **                  does not contain valid data.
 ** \param[out] DTCFaultDetectionCounter  This parameter receives the Fault
 **                  Detection Counter information of the requested DTC. If the
 **                  return value of the function call is other than OK this
 **                  parameter does not contain valid data.
 **
 ** \return Status of the operation to retrieve a DTC from the Dem.
 **
 ** \ServiceID{::DEM_SID_GetNextFilteredDTCAndFDC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Asynchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetNextFilteredDTCType, DEM_CODE)
  Dem_GetNextFilteredDTCAndFDC(
    P2VAR(Dem_DTCType, AUTOMATIC, DEM_APPL_DATA) DTC,
    P2VAR(Dem_FaultDetectionCounterType, AUTOMATIC, DEM_APPL_DATA)
      DTCFaultDetectionCounter);

/** \brief Gets the current DTC and its Severity from the Dem
 **
 ** The API shall return the current DTC and its associated Fault Severity
 ** from the Dem, matching the filter criteria defined by the function call
 ** Dem_SetDTCFilter.
 **
 ** \param[out] DTC  Receives the DTC value in respective format of the filter
 **                  returned by this function. If the return value of the
 **                  function is other than DEM_FILTERED_OK this parameter
 **                  does not contain valid data.
 ** \param[out] DTCStatus  Receives the status value returned by the function.
 **                  If the return value is other than ::DEM_FILTERED_OK this
 **                  parameter does not contain valid data.
 ** \param[out] DTCSeverity  Receives the severity value returned by the function.
 **                  If the return value is other than ::DEM_FILTERED_OK this
 **                  parameter does not contain valid data.
 ** \param[out] DTCFunctionalUnit  Receives the functional unit value returned by the
 **                  function. If the return value is other than ::DEM_FILTERED_OK this
 **                  parameter does not contain valid data.
 **
 ** \return Status of the operation to retrieve a DTC from the Dem.
 **                  The value DEM_FILTERED_PENDING is never returned (because
 **                  of synchronous behavior).
 **
 ** \ServiceID{::DEM_SID_GetNextFilteredDTCAndSeverity}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetNextFilteredDTCType, DEM_CODE)
  Dem_GetNextFilteredDTCAndSeverity(
    P2VAR(Dem_DTCType, AUTOMATIC, DEM_APPL_DATA)         DTC,
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)               DTCStatus,
    P2VAR(Dem_DTCSeverityType, AUTOMATIC, DEM_APPL_DATA) DTCSeverity,
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)               DTCFunctionalUnit);

/** \brief Gets the supported DTC formats of the ECU
 **
 ** The supported formats are configured via DemTypeOfDTCSupported.
 **
 ** \return The Translation format provides the configured translation formats
 **                 according to ISO 14229-1 service 0x19
 **
 ** \ServiceID{::DEM_SID_GetTranslationType}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_DTCTranslationFormatType, DEM_CODE)
  Dem_GetTranslationType(void);

/** \brief Gets the severity of the requested DTC
 **
 ** \param[in] DTC  Diagnostic Trouble Code in UDS format.
 ** \param[out] DTCSeverity  This parameter contains the DTCSeverityMask
 **                 according to ISO14229-1.
 **
 ** \return Status of the operation of type ::Dem_ReturnGetSeverityOfDTCType
 **
 ** \ServiceID{::DEM_SID_GetSeverityOfDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetSeverityOfDTCType, DEM_CODE) Dem_GetSeverityOfDTC(
  Dem_DTCType                                          DTC,
  P2VAR(Dem_DTCSeverityType, AUTOMATIC, DEM_APPL_DATA) DTCSeverity);

/** \brief Gets the functional unit of the requested DTC
 **
 ** \param[in] DTC  The Functional unit assigned to this DTC should be returned
 ** \param[out] DTCFunctionalUnit  This parameter contains the Functional unit
 **                 value of the DTC
 **
 ** \return Status of the operation of type
 **                 ::Dem_ReturnGetFunctionalUnitOfDTCType
 **
 ** \ServiceID{::DEM_SID_GetFunctionalUnitOfDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetFunctionalUnitOfDTCType, DEM_CODE)
  Dem_GetFunctionalUnitOfDTC(
    Dem_DTCType                            DTC,
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) DTCFunctionalUnit);

/* --- Access extended data records and freeze frame data --- */

/** \brief Disables the event memory update of a specific DTC (only one at
 ** one time)
 **
 ** This function shall be used if the freeze frame or extended data record
 ** are about to be accessed by subsequent API-calls. It is done to ensure
 ** that the data contained in this record is not changed while the freeze
 ** frame or extended data record are accessed by the external application,
 ** e.g. Dcm.
 **
 ** This function shall protect the event related data of the specified DTC
 ** within the specified origin from updating or deleting, to allow a
 ** consistent read for the following subsequent API-calls:
 ** Dem_GetSizeOfFreezeFrameByDTC() and Dem_GetFreezeFrameDataByDTC()
 ** Dem_GetSizeOfExtendedDataRecordByDTC() and Dem_GetExtendedDataRecordByDTC()
 **
 ** New and other events including their associated freeze frames and extended
 ** data records can still be added to and changed in the event memory as long
 ** as space is available. Event related data might still be updated in
 ** background (e.g. Dem-internal data elements).
 **
 ** DTC status information update is not affected by this function.
 **
 ** \param[in] DTC  Selects the DTC in UDS format, for which DTC record update
 **                 shall be disabled.
 ** \param[in] DTCOrigin  If the Dem supports more than one event memory this
 **                 parameter is used to select the source memory for which
 **                 DTC record update shall be disabled.
 **
 ** \return Status of the operation of type
 **                 ::Dem_ReturnDisableDTCRecordUpdateType
 **
 ** \ServiceID{::DEM_SID_DisableDTCRecordUpdate}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnDisableDTCRecordUpdateType, DEM_CODE)
  Dem_DisableDTCRecordUpdate(
    Dem_DTCType       DTC,
    Dem_DTCOriginType DTCOrigin);

/** \brief Release the currently disabled DTC
 **
 ** The function Dem_EnableDTCRecordUpdate is the counterpart to the function
 ** Dem_DisableDTCRecordUpdate. It enables the event memory update of the DTC
 ** disabled by Dem_DisableDTCRecordUpdate() before. It shall be called after
 ** the freeze frame and extended data record were protected by the function
 ** Dem_DisableDTCRecordUpdate, after the access by subsequent API-calls is
 ** finished.
 **
 ** It is called to release the currently disabled DTC which has been
 ** protected by the function Dem_DisableDTCRecordUpdate, so that the data can
 ** be updated again.
 **
 ** \return success of operation
 ** \retval E_OK     Operation was successful
 ** \retval E_NOT_OK Operation failed
 **
 ** \ServiceID{::DEM_SID_EnableDTCRecordUpdate}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_EnableDTCRecordUpdate(void);

/** \brief Returns one DTC associated with the freeze frame
 **
 ** This API shall be used to return the DTC associated with the freeze frame
 ** selected via its absolute record number. The function stores the data in
 ** the provided DestBuffer.
 **
 ** Caveats: The record number has to be unique throughout the whole ECU.
 ** This function is only required for OBD-relevant ECUs.
 **
 ** \param[in] RecordNumber  This record number is unique per ECU
 **              (absolute addressing). The value 0xFF is not allowed. The
 **              value 0x00 indicates the complete OBD freeze frame.
 ** \param[in] DTCOrigin  If the Dem supports more than one event memory this
 **              parameter is used to select the source memory the DTCs shall
 **              be read from.
 ** \param[in,out] BufSize  When the function is called this parameter
 **              contains the maximum number of data bytes that can be written
 **              to the buffer. The function returns the actual number
 **              of written data bytes in this parameter.
 ** \param[out] DTC  Receives the DTC value in UDS format returned by this
 **              function. If the return value of the function is other than
 **              DEM_GET_FFBYRECORD_OK this parameter does not contain valid
 **              data.
 ** \param[out] DestBuffer  This parameter contains a byte pointer that points
 **              to the buffer, to which the freeze frame data record shall be
 **              written to. The format is: {NumOfDIDs, DID[1], data[1], ...,
 **              DID[N], data[N]}.
 **
 ** \return Status of the operation to retrieve the DTC and its associated
 **         freeze frame record
 **
 ** \ServiceID{::DEM_SID_GetFreezeFrameDataByRecord}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Not fully implemented yet.
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetFreezeFrameDataByRecordType, DEM_CODE)
  Dem_GetFreezeFrameDataByRecord(
    uint8                                        RecordNumber,
    Dem_DTCOriginType                            DTCOrigin,
    P2VAR(Dem_DTCType, AUTOMATIC, DEM_APPL_DATA) DTC,
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)       DestBuffer,
    P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)      BufSize);

/** \brief Used to copy data of a specific freeze frame record
 **
 ** Gets a freeze frame Data by DTC. The Function stores the data in the
 ** provided DestBuffer.  The data returned includes the
 ** DTCSnapshotNumberOfIdentifiers and DTCSnapshotRecord as defined by UDS for
 ** the response message to Service 0x19, subfunction 0x05 or subfunction
 ** 0x04.
 **
 ** \param[in] DTC  Diagnostic Trouble Code in UDS format.
 ** \param[in] DTCOrigin  If the Dem supports more than one event memory
 **              this parameter is used to select the source memory the
 **              DTCs shall be read from.
 ** \param[in] RecordNumber  This parameter is a unique identifier for a
 **              freeze frame record as defined in ISO15031-5 and ISO14229-1.
 **              The value 0xFF is not allowed. This record number is unique
 **              per DTC (relative addressing)The value 0x00 indicates the
 **              DTC-specific OBD freeze frame.
 ** \param[out] DestBuffer  This parameter contains a byte pointer that points
 **              to the buffer to which the freeze frame data shall be written.
 **              The format is: {RecordNumber, NumOfDIDs, DID[1], data[1],
 **              ..., DID[N], data[N]}
 ** \param[in,out] BufSize  When the function is called this parameter
 **              contains the maximum number of data bytes that can be written
 **              to the buffer.
 **              The function returns the actual number of written data bytes
 **              in this parameter.
 **
 ** \return Status of the operation of type
 **              ::Dem_ReturnGetFreezeFrameDataByDTCType
 **
 ** \ServiceID{::DEM_SID_GetFreezeFrameDataByDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Asynchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetFreezeFrameDataByDTCType, DEM_CODE)
  Dem_GetFreezeFrameDataByDTC(
    Dem_DTCType                             DTC,
    Dem_DTCOriginType                       DTCOrigin,
    uint8                                   RecordNumber,
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
    P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) BufSize);

/** \brief Returns the size of the requested freeze frame including header info
 **
 ** The API shall be used to return the size of the requested freeze frame.
 ** This size not only represents the number of user data bytes (pure freeze
 ** frame data) but also contains freeze frame structure information which
 ** includes size of DTCSnapshotRecord and DTCSnapshotNumberOfIdentifiers.
 **
 ** \param[in] DTC  Diagnostic Trouble Code in UDS format.
 ** \param[in] DTCOrigin  If the Dem supports more than one event memory this
 **              parameter is used to select the source memory the DTCs shall
 **              be read from.
 ** \param[in] RecordNumber  This parameter is unique per DTC
 **              (relative addressing). The value 0xFF is explicitly allowed
 **              to request the overall size.This record number is unique per
 **              DTC (relative addressing). The value 0xFF is explicitly
 **             allowed to request the overall size.
 ** \param[out] SizeOfFreezeFrame  Number of bytes in the requested
 **              freeze frame.
 **
 ** \return Status of the operation of type
 **              ::Dem_ReturnGetSizeOfFreezeFrameByDTCType
 **
 ** \ServiceID{::DEM_SID_GetSizeOfFreezeFrameByDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Asynchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetSizeOfFreezeFrameByDTCType, DEM_CODE)
  Dem_GetSizeOfFreezeFrameByDTC(
    Dem_DTCType                             DTC,
    Dem_DTCOriginType                       DTCOrigin,
    uint8                                   RecordNumber,
    P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) SizeOfFreezeFrame);

/** \brief Used to get extended data by DTC.
 **
 ** This function shall be used to return the complete Extended Data Record
 ** for the requested DTC. The format of the data is raw hexadecimal values
 ** and is not standardized to comply with predefined scaling methods.
 **
 ** \param[in] DTC  Diagnostic Trouble Code in UDS format.
 ** \param[in] DTCOrigin  If the Dem supports more than one event memory this
 **              parameter is used to select the source memory the DTCs shall
 **              be read from.
 ** \param[in] ExtendedDataNumber  Identification/Number of requested extended
 **              data record. The values 0xFE and 0xFF are not allowed. Valid
 **              values are from 0x01 to 0xEF.
 ** \param[out] DestBuffer  This parameter contains a byte pointer that points
 **              to the buffer to which the Extended Data shall be written.
 **              The format is raw hexadecimal values and contains no
 **              header-information.
 ** \param[in,out] BufSize  When the function is called this parameter
 **              contains the maximum number of data bytes that can be written
 **              to the buffer.
 **
 ** \return Status of the operation to retrieve extended data by DTC.
 **
 ** \ServiceID{::DEM_SID_GetExtendedDataRecordByDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Asynchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetExtendedDataRecordByDTCType, DEM_CODE)
  Dem_GetExtendedDataRecordByDTC(
    Dem_DTCType                             DTC,
    Dem_DTCOriginType                       DTCOrigin,
    uint8                                   ExtendedDataNumber,
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
    P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) BufSize);

/** \brief Used to return the size of the requested extended data record
 **
 ** The API shall be used to return the size of the requested 'Extended Data
 ** Record' frame. This size only represents the number of user data bytes
 ** stored in the 'Extended Data Record'.
 **
 ** \param[in] DTC  Diagnostic Trouble Code in UDS format.
 ** \param[in] DTCOrigin  If the Dem supports more than one event memory this
 **              parameter is used to select the source memory the DTCs shall
 **              be read from.
 ** \param[in] ExtendedDataNumber  Identification/Number of requested extended
 **              data record. Valid values are from 0x01 to 0xEF. Additionally
 **              the values 0xFE and 0xFF are explicitly allowed to request
 **              the overall size of all OBD records / all records.
 ** \param[out] SizeOfExtendedDataRecord  Pointer to Size of data bytes stored
 **              in the requested extended data record.
 **              If ::DEM_GET_SIZEOFEDRBYDTC_OPTIMIZATION is ::STD_ON then the size
 **              of extended data record is also added along with Size of the
 **              data bytes stored in the requested extended data record.
 **
 ** \return Status of the operation of type
 **              ::Dem_ReturnGetSizeOfExtendedDataRecordByDTCType
 **
 ** \ServiceID{::DEM_SID_GetSizeOfExtendedDataRecordByDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Asynchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetSizeOfExtendedDataRecordByDTCType, DEM_CODE)
  Dem_GetSizeOfExtendedDataRecordByDTC(
    Dem_DTCType                             DTC,
    Dem_DTCOriginType                       DTCOrigin,
    uint8                                   ExtendedDataNumber,
    P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA) SizeOfExtendedDataRecord);

/* --- Clear DTC information --- */

#if (DEM_INCLUDE_RTE == STD_OFF)
/** \brief Clears single DTCs as well as groups of DTCs
 **
 ** This API can only be used through the RTE, and therefore no declaration is
 ** exported via \verbatim Dem.h\endverbatim.
 **
 ** It shall be used to clear:
 ** - all the event status related to the specified DTC
 ** - all associated event memory entries for these events (extended data
 **   and/or freeze frame data, etc.)
 **
 ** \param[in] DTC  Defines the DTC in respective format, that shall be cleared
 **              from the event memory. If the DTC fits to a DTC group number,
 **              all DTCs of the group shall be cleared.
 ** \param[in] DTCFormat  Defines the input-format of the provided DTC value.
 ** \param[in] DTCOrigin  If the Dem supports more than one event memory this
 **              parameter is used to select the source memory the DTCs
 **              shall be cleared from.
 **
 ** \return Status of the operation of type ::Dem_ReturnClearDTCType
 **
 ** \ServiceID{::DEM_SID_DcmClearDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Asynchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnClearDTCType, DEM_CODE) Dem_ClearDTC(
  Dem_DTCType       DTC,
  Dem_DTCFormatType DTCFormat,
  Dem_DTCOriginType DTCOrigin);
#endif /* (DEM_INCLUDE_RTE == STD_OFF) */

/* --- Control DTC setting --- */

/** \brief Disables the storage of DTCs
 **
 ** This function shall be called to disable the DTC setting for a DTC group.
 **
 ** DTC status information update is not affected by this function.
 **
 ** This is only for preventing DTCs from being stored in case of an induced
 ** failure situations in a system, e.g. during flash-reprogramming of one ECU
 ** in a network. In that case all the ECU's are commanded via diagnostic
 ** request (linked to the above diagnostic request) to suppress storage of a
 ** DTC while maintaining correct fail-safe behavior as the flashed ECU is not
 ** participating in the normal communication anymore. If one of the other
 ** networked ECUs needs one of the signals which are now missing, this will
 ** lead to a failsafe-reaction of the ECU (as by the AUTOSAR concept the
 ** fail-safe reaction of an ECU is triggered by certain event-status updates
 ** or a FiM-command which is itself triggered by an event-status update).
 **
 ** \param[in] DTCGroup  Defines the group of DTC that shall be disabled to
 **              store in event memory.
 ** \param[in] DTCKind  This parameter defines the requested DTC kind, either
 **              only OBD-relevant DTCs or all DTCs.
 **
 ** \return Status of the operation of type ::Dem_ReturnControlDTCSettingType
 **
 ** \ServiceID{::DEM_SID_DisableDTCSetting}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Not fully implemented yet. DTCKind parameter is ignored, because OBD
 ** is not supported in this version.
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnControlDTCSettingType, DEM_CODE) Dem_DisableDTCSetting(
  Dem_DTCGroupType DTCGroup,
  Dem_DTCKindType  DTCKind);

/** \brief Enables the storage of DTCs
 **
 ** This function shall be called to enable the DTC setting for a DTC group.
 ** See also Dem_DisableDTCSetting().
 **
 ** \param[in] DTCGroup  Defines the group of DTC that shall be enabled to
 **              store in event memory.
 ** \param[in] DTCKind  This parameter defines the requested DTC kind, either
 **              only OBD-relevant DTCs or all DTCs.
 **
 ** \return Status of the operation of type ::Dem_ReturnControlDTCSettingType
 **
 ** \ServiceID{::DEM_SID_EnableDTCSetting}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Not fully implemented yet. DTCKind parameter is ignored, because OBD
 ** is not supported in this version.
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnControlDTCSettingType, DEM_CODE) Dem_EnableDTCSetting(
  Dem_DTCGroupType DTCGroup,
  Dem_DTCKindType  DTCKind);

/** \brief Cancel pending operation started from Dcm
 **
 ** \ServiceID{::DEM_SID_DcmCancelOperation}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
/* !LINKSTO Dem547,1, Dem560,1 */
extern FUNC(void, DEM_CODE) Dem_DcmCancelOperation(void);

/*-------------------[Vendor specific APIs]---------------------------------*/

/** \brief Sets a filter for stored DTCs
 **
 ** This API shall be used for the API Dem_DcmGetNextFilteredStoredDTC().
 ** The function sets the new filter criteria and resets the internal counter
 ** to the first event that matches the filter settings. The filter mask
 ** attributes are used until the next call of Dem_DcmSetStoredDTCFilter()
 ** or Dem_Init(). The call of this function shall not interrupt the
 ** Dem_DcmGetNextFilteredStoredDTC() sequence call and change the filter
 ** criteria.
 **
 ** \param[in] DTCOrigin  This parameter is used to select the source memory
 **                       from where the DTCs shall be read from
 ** \param[in] DataKind   DataKind Selects only stored DTCs which contain the
 **                       requested data kind (freeze frame or extended data)
 **
 ** \return Dem_ReturnSetFilterType
 **         ::DEM_FILTER_ACCEPTED: Filter was accepted
 **         ::DEM_WRONG_FILTER: Wrong filter selected, i.e. requested
 **                             DTCOrigin is disabled
 **
 ** \ServiceID{::DEM_SID_SetStoredDTCFilter}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnSetFilterType, DEM_CODE) Dem_DcmSetStoredDTCFilter(
  Dem_DTCOriginType DTCOrigin,
  Dem_DataKindType  DataKind);

/** \brief Gets the next filtered stored DTC
 **
 ** The API shall return the stored DTC in event memory from the Dem,
 ** matching the filter criteria defined by the function
 ** call Dem_DcmSetStoredDTCFilter().
 **
 ** \param[out] DTC  Receives the DTC value in UDS format returned by this
 **                  function. If the return value of the function is other
 **                  than ::DEM_FILTERED_OK this parameter does not contain
 **                  valid data.
 **
 ** \return Status of the operation to retrieve a DTC from the Dem.
 **                  The value ::DEM_FILTERED_PENDING is never returned
 **                  (because of synchronous behavior).
 **
 ** \ServiceID{::DEM_SID_GetNextFilteredStoredDTC}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Dem_ReturnGetNextFilteredDTCType, DEM_CODE)
  Dem_DcmGetNextFilteredStoredDTC(
    P2VAR(Dem_DTCType, AUTOMATIC, DEM_APPL_DATA) DTC);

/*------------------[Interface Dlt <--> Dem]--------------------------------*/
/* Since the configuration parameter DemTriggerDltReports is always switched
 * off, the APIs Dem_DltGetMostRecentFreezeFrameRecordData() and
 * Dem_DltGetAllExtendedDataRecords() are currently not implemented.
 */

/*------------------[OBD-specific Interfaces]-------------------------------*/

#if (((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL)) && (DEM_OBD_Support == STD_ON))
/** \brief Service for reporting the Event as disabled to the Dem for the PID
 ** $41 computation
 **
 ** \param[in] EventId  Identification of an Event by assigned EventId.
 **
 ** \return success of operation
 ** \retval E_OK     set of event to disabled was successful
 ** \retval E_NOT_OK set of event disabled failed
 **
 ** \ServiceID{::DEM_SID_SetEventDisabled}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetEventDisabled(
  Dem_EventIdType EventId);
#endif

/* !LINKSTO Dem.Config.IumprFunctionsEnabled,1 */
#if (DEM_IUMPR_FUNCTIONS_ENABLED == STD_ON)
/** \brief Service for reporting that faults are possibly found because are all
 **  conditions are fulfilled.
 **
 ** \param[in] RatioID Ratio Identifier reporting that a respective diagnostic
 **              function could have found a fault -only used when interface
 **              option "API" is selected.
 **
 ** \return success of operation
 ** \retval E_OK     report of IUMPR was successfully reported
 ** \retval E_NOT_OK report of IUMPR was not reported
 **
 ** \ServiceID{::DEM_SID_RepIUMPRFaultDetect}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 **  OBD is not supported in this version.
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_RepIUMPRFaultDetect(
  Dem_RatioIdType RatioID);

/** \brief Service to lock the denominator of a specific monitor.
 **
 ** \param[in] RatioID Ratio Identifier reporting that specific denominator is
 **              locked (for physical reasons e.g. temperature conditions or
 **              minimum activity)
 **
 ** \return success of operation
 ** \retval E_OK     IUMPR denominator status was successfully reported
 ** \retval E_NOT_OK IUMPR denominator status was not successfully reported
 **
 ** \ServiceID{::DEM_SID_RepIUMPRDenLock}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 **  OBD is not supported in this version.
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_RepIUMPRDenLock(
  Dem_RatioIdType RatioID);

/** \brief Service to release the denominator of a specific monitor.
 **
 ** \param[in] RatioID Ratio Identifier reporting that specific denominator is
 **              released (for physical reasons e.g. temperature conditions or
 **              minimum activity)
 **
 ** \return success of operation
 ** \retval E_OK     IUMPR denominator status was successfully reported
 ** \retval E_NOT_OK IUMPR denominator status was not successfully reported
 **
 ** \ServiceID{::DEM_SID_RepIUMPRDenRelease}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 **  OBD is not supported in this version.
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_RepIUMPRDenRelease(
  Dem_RatioIdType RatioID);
#endif /* (DEM_IUMPR_FUNCTIONS_ENABLED == STD_ON) */

#if (DEM_DCM_ENABLED == STD_ON)
/** \brief Service to request for IUMPR data according to Info Type $08.
 **
 ** \param[in] OpStatus Parameter is required for interface compatibility
 **              to Dcm.
 ** \param[out] Iumprdata08  Buffer containing the contents of InfoType $08
 **
 ** \return Always E_OK is returned, as E_PENDING and E_NOT_OK will never
 **              appear.
 **
 ** \ServiceID{::DEM_SID_GetInfoTypeValue08}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 **  OBD is not supported in this version.
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetInfoTypeValue08(
  Dcm_OpStatusType                       OpStatus,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Iumprdata08);

/** \brief Service to request for IUMPR data according to Info Type $0B.
 **
 ** \param[in] OpStatus Parameter is required for interface compatibility
 **              to Dcm.
 ** \param[out] Iumprdata0B  Buffer containing the contents of InfoType $0B
 **
 ** \return Always E_OK is returned, as E_PENDING and E_NOT_OK will never
 **              appear.
 **
 ** \ServiceID{::DEM_SID_GetInfoTypeValue0B}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 **  OBD is not supported in this version.
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetInfoTypeValue0B(
  Dcm_OpStatusType                       OpStatus,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Iumprdata0B);
#endif /* DEM_DCM_ENABLED == STD_ON */

#if (DEM_OBD_Support == STD_ON)
/** \brief Service to report the value of PID $01 computed by the Dem.
 **
 ** \param[out] PID01value  Buffer containing the contents of PID$01 computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID01}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID01(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID01value);
#endif

/** \brief Service to report the value of PID $21 computed by the Dem.
 **
 ** \param[out] PID21value  Buffer containing the contents of PID$21 computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID21}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 **  OBD is not supported in this version.
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID21(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID21value);

/** \brief Service to report the value of PID $30 computed by the Dem.
 **
 ** \param[out] PID30value  Buffer containing the contents of PID$30 computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID30}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 **  OBD is not supported in this version.
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID30(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID30value);

/** \brief Service to report the value of PID $31 computed by the Dem.
 **
 ** \param[out] PID31value  Buffer containing the contents of PID$31 computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID31}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 **  OBD is not supported in this version.
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID31(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID31value);

#if (DEM_OBD_Support == STD_ON)
/** \brief Service to report the value of PID $41 computed by the Dem.
 **
 ** \param[out] PID41value  Buffer containing the contents of PID$41 computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID41}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID41(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID41value);
#endif

/** \brief Service to report the value of PID $4D computed by the Dem.
 **
 ** \param[out] PID4Dvalue  Buffer containing the contents of PID$4D computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID4D}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 **  OBD is not supported in this version.
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID4D(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID4Dvalue);

/** \brief Service to report the value of PID $4E computed by the Dem.
 **
 ** \param[out] PID4Evalue  Buffer containing the contents of PID$4E computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID4E}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 **  OBD is not supported in this version.
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID4E(
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID4Evalue);

 #if (DEM_OBD_COMPLIANCY_ENABLED == STD_ON)
/** \brief Service to report the value of PID $1C computed by the Dem.
 **
 ** \param[out] PID1Cvalue  Buffer containing the contents of PID$1C computed
 **              by Dem.
 **
 ** \return Always E_OK is returned, as E_NOT_OK will never appear.
 **
 ** \ServiceID{::DEM_SID_DcmReadDataOfPID1C}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 **  OBD is not supported in this version.
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_DcmReadDataOfPID1C(
    P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) PID1Cvalue);
#endif

/* !LINKSTO Dem_OBD_0001,2 */
#if (DEM_OBD_Support == STD_ON)
/** \brief Gets data element per PID and index of the most important freeze
 ** frame being selected for the output of service $02
 **
 ** The function stores the data in the provided DestBuffer.
 **
 ** \param[in] PID  This parameter is an identifier for a PID as defined in
 **              ISO15031-5.
 ** \param[in] DataElementIndexOfPID  This parameter is a Data element index
 **              of this PID according to the Dcm configuration
 **              of service $02. It is zero-based and consecutive,
 **              and ordered by the data element positions.
 ** \param[in,out] DestBuffer  This parameter contains a byte pointer that
 **              points to the buffer to which freeze frame data shall be
 **              written. The format is raw hexadecimal values and contains
 **              no header information.
 ** \param[in,out] Bufsize  When the function is called this parameter
 **              contains the maximum number of data bytes that can be written
 **              to the buffer.
 **
 ** \return success of operation
 ** \retval E_OK Freeze frame data was successfully reported
 ** \retval E_NOT_OK Freeze frame data was not successfully reported
 **
 ** \ServiceID{::DEM_SID_ReadDataOfOBDFreezeFrame}
 ** \Reentrancy{Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_ReadDataOfOBDFreezeFrame(
  uint8                                  PID,
  uint8                                  DataElementIndexOfPID,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) DestBuffer,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA) Bufsize);

/** \brief Gets DTC by freeze frame record number
 **
 ** \param[in] FrameNumber  Unique identifier for a freeze frame record as
 **              defined in ISO 15031-5. The value 0x00 indicates the complete
 **              OBD freeze frame. Other values are reserved for future
 **              functionality and are not supported yet.
 ** \param[out] DTC  Diagnostic Trouble Code. If the return value of the
 **              function is other than E_OK this parameter does not
 **              contain valid data.
 ** \return success of operation
 ** \retval E_OK   operation was successful
 ** \retval E_NOT_OK  no DTC available
 **
 ** \ServiceID{::DEM_SID_GetDTCOfOBDFreezeFrame}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note This API must only be used by the Dcm module!
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetDTCOfOBDFreezeFrame(
  uint8                                   FrameNumber,
  P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA) DTC);
#endif /* (DEM_OBD_Support == STD_ON) */

#if ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL))

/** \brief Service to set the status of the PTO
 **
 ** \param[in] PtoStatus  sets the status of the PTO (TRUE == active,
 **              FALSE == inactive)
 **
 ** \return success of operation
 ** \retval E_OK   new PTO status has been adopted by Dem
 ** \retval E_NOT_OK  new PTO status has not been adopted by Dem
 **
 ** \ServiceID{::DEM_SID_SetPtoStatus}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 **
 ** \note Functionality not implemented, only stub available.
 **  OBD is not supported in this version.
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetPtoStatus(boolean PtoStatus);

/* !LINKSTO Dem_OBD_0001,2 */
#if (DEM_OBD_Support == STD_ON)
/** \brief Marks the current OBD driving cycle as having met the criteria
 **        for the PFC cycle. API is needed in OBD-relevant ECUs
 **        only.
 **
 ** \return success of operation
 ** \retval E_OK      always E_OK is returned
 ** \retval E_NOT_OK  E_NOT_OK will never appear
 **
 ** \ServiceID{::DEM_SID_SetPfcCycleQualified}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_SetPfcCycleQualified(void);


/** \brief Returns TRUE if the criteria for the PFC cycle have been
 **        met during the current OBD driving cycle.
 **        API is needed in OBD-relevant ECUs only.
 **
 ** \param[out] isqualified TRUE: During the current OBD driving cycle the criteria
 **                         for the PFC cycle have been met. FALSE: During
 **                         the current OBD driving cycle the criteria for the
 **                         PFC cycle have not been met or permanent memory
 **                         is not defined.
 ** \return success of operation
 ** \retval E_OK      always E_OK is returned
 ** \retval E_NOT_OK  E_NOT_OK will never appear
 **
 ** \ServiceID{::DEM_SID_GetPfcCycleQualified}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(Std_ReturnType, DEM_CODE) Dem_GetPfcCycleQualified(
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) isqualified);

/* !LINKSTO VCC_DEM_007_Req196v1,1 */
/** \brief Sets the TNCSLC bit for all not confirmed (CDTC==0) and not pending (PDTC==0) events
 *         assigned to any ReadinessGroup reported by PID$01.
 **
 ** \return none
 **
 ** \ServiceID{::DEM_SID_ResetReadiness}
 ** \Reentrancy{Non Reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_ResetReadiness(void);
#endif /* #if (DEM_OBD_Support == STD_ON) */

#endif
/*------------------[Scheduled functions]-----------------------------------*/

#if ((DEM_INCLUDE_RTE == STD_OFF) || (!defined DEM_INTERNAL))

/** \brief Processes event memory entries from error-queue
 **
 ** This function is used to process all not event based Dem internal
 ** functions. It shall be called periodically as cyclic task by the software
 ** system (e.g. by operating system).
 **
 ** Timing: fixed cyclic
 **
 ** Configuration: The cyclic time for the main function has to be defined as
 ** an operating system task or runnable entity.
 **
 ** \ServiceID{::DEM_SID_MainFunction}
 ** \Reentrancy{Non reentrant}
 ** \Synchronicity{Synchronous}
 */
extern FUNC(void, DEM_CODE) Dem_MainFunction(void);

#endif

#define DEM_STOP_SEC_CODE
#include <MemMap.h>

/*==================[internal function declarations]========================*/

/*==================[external constants]====================================*/

/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

#define DEM_START_SEC_VAR_SAVED_ZONE_UNSPECIFIED
#include <MemMap.h>

/** \brief Struct containing all NVRAM data */
extern VAR(Dem_NvDataType, DEM_VAR_NOINIT) Dem_NvData;

#define DEM_STOP_SEC_VAR_SAVED_ZONE_UNSPECIFIED
#include <MemMap.h>

#define DEM_START_SEC_VAR_NO_INIT_UNSPECIFIED
#include <MemMap.h>

#if (DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON)

/** \brief Struct containing gate entry base and primary data to be read
 ** from and written to NVRAM block */
extern VAR(Dem_NvGateEntryPrimaryDataType, DEM_VAR_NOINIT)
  Dem_NvGateEntryPrimaryData;

#if (DEM_MAX_NUMBER_EVENT_ENTRY_SEC != 0U)
/** \brief Struct containing gate entry base and secondary data to be read
 ** from and written to NVRAM block */
extern VAR(Dem_NvGateEntrySecondaryDataType, DEM_VAR_NOINIT)
  Dem_NvGateEntrySecondaryData;
#endif

#if (DEM_MAX_NUMBER_EVENT_ENTRY_MIR != 0U)
/** \brief Struct containing gate entry base and mirror data to be read from
 ** and written to NVRAM block */
extern VAR(Dem_NvGateEntryMirrorDataType, DEM_VAR_NOINIT)
  Dem_NvGateEntryMirrorData;
#endif

#endif /* DEM_USE_IMMEDIATE_NV_STORAGE == STD_ON */

#define DEM_STOP_SEC_VAR_NO_INIT_UNSPECIFIED
#include <MemMap.h>

/*==================[internal data]=========================================*/

/*==================[external function definitions]=========================*/

/*==================[internal function definitions]=========================*/

#endif /* if !defined( DEM_H ) */
/*==================[end of file]===========================================*/
