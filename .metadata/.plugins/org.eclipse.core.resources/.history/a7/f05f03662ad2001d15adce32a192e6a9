/*******************************************************************************
**                                                                            **
** Copyright (C) Infineon Technologies (2016)                                 **
**                                                                            **
** All rights reserved.                                                       **
**                                                                            **
** This document contains proprietary information belonging to Infineon       **
** Technologies. Passing on and copying of this document, and communication   **
** of its contents is not permitted without prior written authorization.      **
**                                                                            **
********************************************************************************
**                                                                            **
**  FILENAME     : Adc.c                                                      **
**                                                                            **
**  VERSION      : 5.0.0                                                      **
**                                                                            **
**  DATE         : 2017-03-13                                                 **
**                                                                            **
**  VARIANT      : Variant PB                                                 **
**                                                                            **
**  PLATFORM     : Infineon AURIX2G                                           **
**                                                                            **
**  AUTHOR       : DL-AUTOSAR-Engineering                                     **
**                                                                            **
**  VENDOR       : Infineon Technologies                                      **
**                                                                            **
**  DESCRIPTION  : Adc Driver source file                                     **
**                                                                            **
**  SPECIFICATION(S) : Specification of ADC Driver, AUTOSAR Release 4.2.2     **
**                                                                            **
**  MAY BE CHANGED BY USER : no                                               **
**                                                                            **
*******************************************************************************/

/*******************************************************************************
**                      Includes                                              **
*******************************************************************************/
#include "Adc.h"
#include "McalLib.h"
#if ((ADC_CLC_FAILURE_DEM_NOTIF == ADC_ENABLE_DEM_REPORT)||\
     (ADC_CONV_STOP_TIME_DEM_NOTIF == ADC_ENABLE_DEM_REPORT))
#include "Dem.h"
#endif
#include "SchM_Adc.h"
#include "IfxEvadc_bf.h"
#include "IfxEvadc_reg.h"
#include "IfxScu_bf.h"
#include "IfxScu_reg.h"
#include "Mcal_Compiler.h"

/*******************************************************************************
**                      Imported Compiler Switch Check                        **
*******************************************************************************/
#ifndef ADC_AR_RELEASE_MAJOR_VERSION
  #error "ADC_AR_RELEASE_MAJOR_VERSION is not defined."
#endif

#ifndef ADC_AR_RELEASE_MINOR_VERSION
  #error "ADC_AR_RELEASE_MINOR_VERSION is not defined."
#endif

#ifndef ADC_AR_RELEASE_REVISION_VERSION
  #error "ADC_AR_RELEASE_REVISION_VERSION is not defined."
#endif

#if ( ADC_AR_RELEASE_MAJOR_VERSION != 4U)
  #error "ADC_AR_RELEASE_MAJOR_VERSION does not match."
#endif

#if ( ADC_AR_RELEASE_MINOR_VERSION != 2U )
  #error "ADC_AR_RELEASE_MINOR_VERSION does not match."
#endif

#ifndef ADC_SW_MAJOR_VERSION
  #error "ADC_SW_MAJOR_VERSION is not defined."
#endif

#ifndef ADC_SW_MINOR_VERSION
  #error "ADC_SW_MINOR_VERSION is not defined."
#endif

#ifndef ADC_SW_PATCH_VERSION
  #error "ADC_SW_PATCH_VERSION is not defined."
#endif

#if ( ADC_SW_MAJOR_VERSION != 2U )
  #error "ADC_SW_MAJOR_VERSION does not match."
#endif

#if ( ADC_SW_MINOR_VERSION != 1U )
  #error "ADC_SW_MINOR_VERSION does not match."
#endif
/*
  Note: Elektrobit Automotive GmbH modified the original code provided
        by the third party supplier. The modification is provided for
        convenience.
        Please use the modification on your discretion and account, or
        use the unmodified files provided with this distribution. 
  Please see for the reasons in the file ImportantNotes.txt for tag
*/
/*EB Remove version check for DET and Dem modules 
ASCINFINEON-660 ticket */
/* #if (ADC_DEV_ERROR_DETECT == STD_ON)

#ifndef DET_AR_RELEASE_MAJOR_VERSION
  #error "DET_AR_RELEASE_MAJOR_VERSION is not defined."
#endif

#ifndef DET_AR_RELEASE_MINOR_VERSION
  #error "DET_AR_RELEASE_MINOR_VERSION is not defined."
#endif
#if ( DET_AR_RELEASE_MAJOR_VERSION != 4U )
  #error "DET_AR_RELEASE_MAJOR_VERSION does not match."
#endif

#if ( DET_AR_RELEASE_MINOR_VERSION != 2U )
  #error "DET_AR_RELEASE_MINOR_VERSION does not match."
#endif

#endif End for ADC_DEV_ERROR_DETECT */

/* #if ((ADC_CLC_FAILURE_DEM_NOTIF == ADC_ENABLE_DEM_REPORT)||\
   (ADC_CONV_STOP_TIME_DEM_NOTIF == ADC_ENABLE_DEM_REPORT))

  #ifndef DEM_AR_RELEASE_MAJOR_VERSION
    #error "DEM_AR_RELEASE_MAJOR_VERSION is not defined."
  #endif

  #ifndef DEM_AR_RELEASE_MINOR_VERSION
    #error "DEM_AR_RELEASE_MINOR_VERSION is not defined."
  #endif

  #if ( DEM_AR_RELEASE_MAJOR_VERSION != 4U )
    #error "DEM_AR_RELEASE_MAJOR_VERSION does not match."
  #endif

  #if ( DEM_AR_RELEASE_MINOR_VERSION != 2U )
    #error "DEM_AR_RELEASE_MINOR_VERSION does not match."
  #endif

#endif  End For ADC_CLC_FAILURE_DEM_NOTIF and ADC_CONV_STOP_TIME_DEM_NOTIF */


/*******************************************************************************
**                      Private Macro Definitions                             **
*******************************************************************************/
#define ADC_ONE_U                       (1U)

#define ADC_INITIALIZED                 ((uint32)1U)
#define ADC_UNINITIALIZED               ((uint32)0U)
#define ADC_INVALID_GROUP_ID            ((Adc_GroupType)0xFFU)
#define ADC_INVALID_CHANNEL_ID          ((Adc_ChannelType)0xFFU)
#define ADC_KERNEL_ID_START_POS         (5U)
#define ADC_KERNEL_ID_NO_OF_BITS        (4U)
#define ADC_GROUP_ID_MASK               (0x1FU)
#define ADC_ERU_DATA_BITS               (16)
#define ADC_ERU_EICR_REG_SEL_MASK       (3U)
#define ADC_ERU_IGCR_REG_SEL_MASK       (3U)
#define ADC_ERU_CH_CFG_BIT_POS_SHIFT    (4U)

#define ADC_PRIMARY_CONV_CHANNEL_COUNT     (8U)
#define ADC_SECONDARY_CONV_CHANNEL_COUNT   (16U)
#define ADC_MAX_RESULT_REGISTERS           (16U)
/*MISRA2012_RULE_2_5_JUSTIFICATION:
The usage of macro is configuration dependent, it is unused only in the 
current configuration. Keeping the macro declaration under compiler switch
is not necessary here */
#define ADC_12BIT_RIGHT_ALIGN_RESULT_MASK  (0xFFFU)
/*MISRA2012_RULE_2_5_JUSTIFICATION:
The usage of macro is configuration dependent, it is unused only in the 
current configuration. Keeping the macro declaration under compiler switch
is not necessary here */
#define ADC_12BIT_LEFT_ALIGN_RESULT_SHIFT  (4U)
/*MISRA2012_RULE_2_5_JUSTIFICATION:
The usage of macro is configuration dependent, it is unused only in the 
current configuration. Keeping the macro declaration under compiler switch
is not necessary here */
#define ADC_CHANNEL_RESULT_CLR_MASK     ((uint16)0xFFFFU)
#define ADC_CLR_VALID_FLAG_REG          ((uint32)0x0000FFFFU)
#define ADC_REQTM_RESET_VALUE           ((uint32)0xFFC00000U)
#define ADC_CLR_SOURCE_EVENT            ((uint32)0x00000007U)
#define ADC_CLR_RESULT_EVENT            ((uint32)0x0000FFFFU)
#define ADC_CLR_PRIMARY_CH_EVENT        ((uint32)0x000000FFU)
#define ADC_CLR_SECONDARY_CH_EVENT      ((uint32)0x0000FFFFU)
#define ADC_ANCFG_DEFAULT_VALUE         ((uint32)0x00300004U)
#define ADC_CLC_DEFAULT_VALUE           ((uint32)0x00000001U)
#define ADC_CLR_CHCTR_EXCEPT_BWD        ((uint32)0x70000000U)
#define ADC_ALIAS_DEFAULT_VALUE         ((uint32)0x00000100U)

#define ADC_SEVNP_INIT_CFG_VALUE        ((uint32)0x00000210U)
/*MISRA2012_RULE_2_5_JUSTIFICATION:
The usage of macro is configuration dependent, it is unused only in the 
current configuration. Keeping the macro declaration under compiler switch
is not necessary here */
#define ADC_CEVNP_INIT_CFG_VALUE        ((uint32)0x33333333U)
/*MISRA2012_RULE_2_5_JUSTIFICATION:
The usage of macro is configuration dependent, it is unused only in the 
current configuration. Keeping the macro declaration under compiler switch
is not necessary here */
#define ADC_REVNP_INIT_CFG_VALUE        ((uint32)0x33333333U)

#define ADC_CONVERTER_ON                (3U)

#define ADC_Q_CTRL_WRITE_PROTECT_MSK    ((uint32)(\
                           ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QCTRL_TMWC_OFF)|\
                           ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QCTRL_GTWC_OFF)|\
                           ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QCTRL_XTWC_OFF)))

#define ADC_GLOBCFG_WRITE_PROTECT_MSK    (\
                           (uint32)ADC_ONE_U<<IFX_EVADC_GLOBCFG_CPWC_OFF)

#define ADC_GLOBTF_WRITE_PROTECT_MSK   ((uint32)(\
                           ((uint32)ADC_ONE_U<<IFX_EVADC_GLOB_TF_MDWC_OFF)|\
                           ((uint32)ADC_ONE_U<<IFX_EVADC_GLOB_TF_CDWC_OFF)))

#define ADC_START_SW_TRIG_CONV         ((uint32)(\
                           ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_ENGT_OFF)|\
                           ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_TREV_OFF)))

/*******************************************************************************
**                      Private Type Definitions                              **
*******************************************************************************/
/*Type Definition for  Adc_QueueDataType*/
#if(ADC_ENABLE_QUEUING == STD_ON)
/*Type Definition for  Adc_QueueDataType*/ 
typedef struct
{
  Adc_GroupType PreviousGroup;
  Adc_GroupType NextGroup;
}Adc_QueueDataType;
#endif/* End for ADC_ENABLE_QUEUING */

/*Type Definition for  Adc_RSDataType*/
typedef struct
{
  Adc_GroupType ActiveGroupId;
  Adc_ChannelType ActiveLimitChkCh;
  uint8 IsrNoServiceFlag;
}Adc_RSDataType;

/*Type Definition for  Adc_GlobalDataType*/
typedef struct
{
  #if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
  Adc_ValueGroupType *GrpResBuffer[ADC_MAX_GROUPS];
  #endif
  uint32 GrpStatus;
  uint32 GrpResultStatus;
  uint32 GrpBufferEndResultStatus;
  uint32 GrpNotifStatus;
  Adc_RSDataType RSData[ADC_REQSRC_COUNT];
  #if(ADC_ENABLE_QUEUING == STD_ON)
  Adc_QueueDataType QueueOfSwGroup[ADC_MAX_GROUPS];
  Adc_GroupType PopGroupId;
  Adc_GroupType PushGroupId;
  #endif
  uint16 AllRunningChannels;
  uint16 AllRunningResReg;
  #if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
  Adc_StreamNumSampleType NumofValidConRes[ADC_MAX_GROUPS];
  #endif
}Adc_GlobalDataType;
/*******************************************************************************
**                      Private Function Declarations                         **
*******************************************************************************/
#define ADC_START_SEC_CODE_QM_GLOBAL
/*MISRA2012_RULE_4_10_JUSTIFICATION: Memmap header is repeatedly included
without safegaurd. It complies to Autosar guidelines. */
/*MISRA2012_RULE_20_1_JUSTIFICATION: Memmap header usage as per Autosar
guideline. */
#include "Adc_MemMap.h"

LOCAL_INLINE uint32 Adc_lGetAdcKernel(const Adc_GroupType GroupId);
LOCAL_INLINE Adc_GroupType Adc_lGetKernelGroupId(const Adc_GroupType GroupId);
LOCAL_INLINE Adc_GlobalDataType* Adc_lGetKernelDataAddress(\
                                                       const uint32 KernelId);

/************** Local APIs for Group Status - Start **************/
LOCAL_INLINE void Adc_lSetGroupStatusBusyAtomic(\
                  Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId);
LOCAL_INLINE void Adc_lSetGroupResultAtomic(\
                  Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId);
LOCAL_INLINE void Adc_lSetResBuffEndStatusAtomic(\
                  Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId);
LOCAL_INLINE void Adc_lClrGroupStatusBusyAtomic(\
                  Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId);
LOCAL_INLINE void Adc_lClrGroupResultAtomic(\
                  Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId);
LOCAL_INLINE void Adc_lClrResBuffEndStatusAtomic(\
                  Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId);
LOCAL_INLINE uint32 Adc_lGetGroupStatus(\
            const Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId);
LOCAL_INLINE uint32 Adc_lGetGroupResultStatus(\
            const Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId);
LOCAL_INLINE uint32 Adc_lGetResBuffEndStatus(\
            const Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId);
LOCAL_INLINE uint32 Adc_lGetAllGroupStatus(void);

#if (ADC_GRP_NOTIF_CAPABILITY == STD_ON)
LOCAL_INLINE void Adc_lSetGrpNotifAtomic(\
                  Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId);
LOCAL_INLINE void Adc_lClrGrpNotifAtomic(\
                  Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId);
LOCAL_INLINE uint32 Adc_lGetGroupNotifStatus(\
            const Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId);
#endif /* End for ADC_GRP_NOTIF_CAPABILITY*/

/************** Local APIs for Group Status - End **************/

LOCAL_INLINE void Adc_lInit(void);
LOCAL_INLINE void Adc_lResetGlobalSfr(void);
static void Adc_lResetGlobalVars(void);
LOCAL_INLINE void Adc_lKernelInit(const Adc_HwUnitCfgType *KernelCfgPtr,\
                                                    const uint32 KernelId);
static void Adc_lKernelDeInit(const Adc_HwUnitCfgType *KernelCfgPtr,\
                                                       const uint32 KernelId);
static void Adc_lPrepareGrpForStart(const uint32 KernelId,\
                                               const Adc_GroupType GroupId);

#if (ADC_ENABLE_START_STOP_GROUP_API == STD_ON)
static void Adc_lStartSwConversion(const Adc_GroupCfgType *GrpPtr,\
                                                    const uint32 KernelId);
#endif /* End for ADC_ENABLE_START_STOP_GROUP_API */

#if (ADC_ENABLE_QUEUING == STD_ON)
LOCAL_INLINE void Adc_lPushToQueue(const uint32 KernelId,\
                                   const Adc_GroupType GroupId);
static void Adc_lScheduleFromQueue(const uint32 KernelId);
static void Adc_lPopFromQueue(const uint32 KernelId,\
                              const Adc_GroupType GroupId);
LOCAL_INLINE void Adc_lRemoveFromQueue(Adc_GlobalDataType *KernelDataPtr,\
                                                 const Adc_GroupType GroupId);
#endif /* End For ADC_ENABLE_QUEUING */

static void Adc_lStopConvRequest(const Adc_GroupCfgType *GrpPtr,\
                                                      const uint32 KernelId);
static void Adc_lClearGroupSfr(const Adc_GroupCfgType *GrpPtr,\
                                               const uint32 KernelId);
LOCAL_INLINE void Adc_lRemoveActiveGroup(Adc_GlobalDataType *KernelDataPtr,\
                                              const Adc_GroupCfgType *GrpPtr);

#if (ADC_HW_TRIGGER_API == STD_ON)
LOCAL_INLINE void Adc_lResetHwTrigger(const Adc_GroupCfgType *GrpPtr);
LOCAL_INLINE void Adc_lSetHwTrigger(const Adc_GroupCfgType *GrpPtr);
LOCAL_INLINE void Adc_lStartHwConversion(const Adc_GroupCfgType *GrpPtr,\
                                                 const uint32 KernelId);
LOCAL_INLINE void Adc_lGtmChannelInit(\
                             const Mcal_GtmTomChConfigType *GtmChannelCfgPtr);
LOCAL_INLINE void Adc_lGtmChannelDeInit(\
                             const Mcal_GtmTomChConfigType *GtmChannelCfgPtr);
LOCAL_INLINE void Adc_lEruChannelInit(\
                             const Adc_EruChannelCfgType *EruChannelCfgPtr);
LOCAL_INLINE void Adc_lEruChannelDeInit(\
                             const Adc_EruChannelCfgType *EruChannelCfgPtr);
#endif /* End for ADC_HW_TRIGGER_API */

#if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
static void Adc_lUpdateResBuffer(const uint32 KernelId,\
                                 const Adc_GroupType GroupId);
static void Adc_lGrpSequenceHandler(const uint32 KernelId,\
                              const Adc_GroupType GroupId, const uint8 ReqSrc);
#endif /* End for ADC_RESULT_HANDLING_IMPLEMENTATION */

static void Adc_lRSEventHandler(const uint32 KernelId, const uint8 RequestSrc);

#if (ADC_ENABLE_LIMIT_CHECK==STD_ON)
static void Adc_lLimitChkEventHandler(const uint32 KernelId,\
                                      const Adc_GroupType GroupId);
#endif /* End for ADC_ENABLE_LIMIT_CHECK */


/************** Local APIs for DET checks - Start**************/
#if (ADC_DEV_ERROR_DETECT == STD_ON)
LOCAL_INLINE uint8 Adc_lInitDetCheck(const Adc_ConfigType *ConfigPtr);
#endif

#if ((ADC_DEV_ERROR_DETECT == STD_ON) &&\
     (ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING))
LOCAL_INLINE uint8 Adc_lSetupResBufDetCheck(const uint32 KernelId,\
  const Adc_GroupType GroupId, const Adc_ValueGroupType* DataBufferPtr);
#endif

#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_DEINIT_API ==STD_ON))
LOCAL_INLINE uint8 Adc_lDeInitDetCheck(void);
#endif

#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_ENABLE_START_STOP_GROUP_API==STD_ON))
LOCAL_INLINE uint8 Adc_lStartGrpConvDetCheck(const uint32 KernelId,\
                                             const Adc_GroupType GroupId);
LOCAL_INLINE uint8 Adc_lStopGrpConvDetCheck(const uint32 KernelId,\
                                            const Adc_GroupType GroupId);
#endif

#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_READ_GROUP_API==STD_ON))
LOCAL_INLINE uint8 Adc_lReadGrpDetCheck(const uint32 KernelId,\
                                        const Adc_GroupType GroupId);
#endif

#if(ADC_DEV_ERROR_DETECT==STD_ON)
LOCAL_INLINE uint8 Adc_lGetGrpStatusDetCheck(const uint32 KernelId,\
                                             const Adc_GroupType GroupId);
#endif

#if ((ADC_DEV_ERROR_DETECT == STD_ON) &&\
     (ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING))
LOCAL_INLINE uint8 Adc_lGetStrmPtrDetCheck(const uint32 KernelId,\
                                           const Adc_GroupType GroupId);
#endif

#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_GRP_NOTIF_CAPABILITY ==STD_ON))
LOCAL_INLINE uint8 Adc_lEnGrpNotifDetCheck(const uint32 KernelId,\
                                           const Adc_GroupType GroupId);
LOCAL_INLINE uint8 Adc_lDisGrpNotifDetCheck(const uint32 KernelId,\
                                            const Adc_GroupType GroupId);
#endif

#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_HW_TRIGGER_API==STD_ON))
LOCAL_INLINE uint8 Adc_lEnHwTriggerDetCheck(const uint32 KernelId,\
                                            const Adc_GroupType GroupId);
LOCAL_INLINE uint8 Adc_lDisHwTriggerDetCheck(const uint32 KernelId,\
                                             const Adc_GroupType GroupId);
#endif

#if(ADC_DEV_ERROR_DETECT==STD_ON)
LOCAL_INLINE uint8 Adc_lCheckUnInitDet(const uint8 ServiceId);
#endif

#if(ADC_DEV_ERROR_DETECT==STD_ON)
LOCAL_INLINE uint8 Adc_lCheckParamGrpDet(const uint32 KernelId,\
                           const Adc_GroupType GroupId, const uint8 ServiceId);
#endif

#if(ADC_DEV_ERROR_DETECT==STD_ON)
LOCAL_INLINE uint8 Adc_lCheckWrongTrigSrcDet(const uint32 KernelId,\
                         const Adc_GroupType GroupId,const uint8 ServiceId);
#endif

#if((ADC_DEV_ERROR_DETECT==STD_ON) && \
    (ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING))
LOCAL_INLINE uint8 Adc_lCheckBufferUnInitDet(const uint32 KernelId,\
                         const Adc_GroupType GroupId,const uint8 ServiceId);
#endif

#if(ADC_DEV_ERROR_DETECT==STD_ON )
LOCAL_INLINE uint8 Adc_lCheckGrpIdleDet(const uint32 KernelId,\
                        const Adc_GroupType GroupId, const uint8 ServiceId);
#endif

#if(ADC_DEV_ERROR_DETECT==STD_ON )
LOCAL_INLINE uint8 Adc_lCheckGrpBusyDet(const uint32 KernelId,\
                          const Adc_GroupType GroupId, const uint8 ServiceId);
#endif


#if((ADC_DEV_ERROR_DETECT==STD_ON )&&(ADC_GRP_NOTIF_CAPABILITY ==STD_ON))
LOCAL_INLINE uint8 Adc_lCheckNotifCapableDet(const uint32 KernelId,\
                        const Adc_GroupType GroupId, const uint8 ServiceId);
#endif

#if((ADC_DEV_ERROR_DETECT==STD_ON )&&(ADC_HW_TRIGGER_API==STD_ON))
LOCAL_INLINE uint8 Adc_lCheckWrongConvModeDet(const uint32 KernelId,\
                     const Adc_GroupType GroupId, const uint8 ServiceId);
#endif

#define ADC_STOP_SEC_CODE_QM_GLOBAL
/*MISRA2012_RULE_20_1_JUSTIFICATION: Memmap header usage as per Autosar
guideline. */
/*MISRA2012_RULE_4_10_JUSTIFICATION: Memmap header is repeatedly included
without safegaurd. It complies to Autosar guidelines. */
#include "Adc_MemMap.h"

/************** Local APIs for DET checks - End**************/

/*******************************************************************************
**                      Global Constant Definitions                           **
*******************************************************************************/

#define ADC_START_SEC_CONST_QM_8
/*MISRA2012_RULE_20_1_JUSTIFICATION: Memmap header usage as per Autosar
guideline.*/
/*MISRA2012_RULE_4_10_JUSTIFICATION: Memmap header is repeatedly included
without safegaurd. It complies to Autosar guidelines. */
#include "Adc_MemMap.h"
/*MISRA2012_RULE_8_9_JUSTIFICATION: Variable not defined at block scope.
The size of this array is derived from a configuration constant.
The function uses this returns the address of this variable,
and the content of the variable is changed from different APIs'*/
static const uint8 Adc_kKernelDataIndex[ADC_MAX_KERNEL_ID] =\
{
  ADCX_KERNEL_INDEX
};
#define ADC_STOP_SEC_CONST_QM_8
/*MISRA2012_RULE_20_1_JUSTIFICATION: Memmap header usage as per Autosar
guideline. */
/*MISRA2012_RULE_4_10_JUSTIFICATION: Memmap header is repeatedly included
without safegaurd. It complies to Autosar guidelines. */
#include "Adc_MemMap.h"
/*******************************************************************************
**                      Global Variable Definitions                           **
*******************************************************************************/
/*MISRA2012_RULE_5_1_JUSTIFICATION:Memmap macros are defined as per Autosar 
naming convention, hence it goes beyond 32 characters.*/
/*MISRA2012_RULE_5_2_JUSTIFICATION:Memmap macros are defined as per Autosar 
naming convention, hence it goes beyond 32 characters.*/
/*MISRA2012_RULE_5_4_JUSTIFICATION:Memmap macros are defined as per Autosar 
naming convention, hence it goes beyond 32 characters.*/
/*MISRA2012_RULE_5_5_JUSTIFICATION:Memmap macros are defined as per Autosar 
naming convention, hence it goes beyond 32 characters.*/
#define ADC_START_SEC_VAR_CLEARED_QM_LOCAL_UNSPECIFIED
/*MISRA2012_RULE_20_1_JUSTIFICATION: Memmap header usage as per Autosar
guideline. */
/*MISRA2012_RULE_4_10_JUSTIFICATION: Memmap header is repeatedly included
without safegaurd. It complies to Autosar guidelines. */ 
#include "Adc_MemMap.h"
static Adc_GlobalDataType Adc_KernelData[ADC_KERNEL_USED_COUNT];
/*MISRA2012_RULE_5_1_JUSTIFICATION:Memmap macros are defined as per Autosar 
naming convention, hence it goes beyond 32 characters.*/
/*MISRA2012_RULE_5_2_JUSTIFICATION:Memmap macros are defined as per Autosar 
naming convention, hence it goes beyond 32 characters.*/
/*MISRA2012_RULE_5_4_JUSTIFICATION:Memmap macros are defined as per Autosar 
naming convention, hence it goes beyond 32 characters.*/
/* MISRA2012_RULE_5_5_JUSTIFICATION:Memmap macros are defined as per Autosar 
naming convention, hence it goes beyond 32 characters.*/
#define ADC_STOP_SEC_VAR_CLEARED_QM_LOCAL_UNSPECIFIED
/*MISRA2012_RULE_20_1_JUSTIFICATION: Memmap header usage as per Autosar
guideline. */
/*MISRA2012_RULE_4_10_JUSTIFICATION: Memmap header is repeatedly included
without safegaurd. It complies to Autosar guidelines. */
#include "Adc_MemMap.h"

#define ADC_START_SEC_VAR_CLEARED_QM_LOCAL_32
/*MISRA2012_RULE_20_1_JUSTIFICATION: Memmap header usage as per Autosar
guideline. */
/*MISRA2012_RULE_4_10_JUSTIFICATION: Memmap header is repeatedly included
without safegaurd. It complies to Autosar guidelines. */
#include "Adc_MemMap.h"

static const Adc_ConfigType *Adc_kConfigPtr;

#if (ADC_DEV_ERROR_DETECT==STD_ON)
static uint32 Adc_InitStatus;
#endif

#define ADC_STOP_SEC_VAR_CLEARED_QM_LOCAL_32
/*MISRA2012_RULE_20_1_JUSTIFICATION: Memmap header usage as per Autosar
guideline. */
/*MISRA2012_RULE_4_10_JUSTIFICATION: Memmap header is repeatedly included
without safegaurd. It complies to Autosar guidelines. */
#include "Adc_MemMap.h"

/*******************************************************************************
**                      Global Function Definitions                           **
*******************************************************************************/
#define ADC_START_SEC_CODE_QM_GLOBAL
/*MISRA2012_RULE_4_10_JUSTIFICATION: Memmap header is repeatedly included
without safegaurd. It complies to Autosar guidelines. */
/*MISRA2012_RULE_20_1_JUSTIFICATION: Memmap header usage as per Autosar
guideline. */
#include "Adc_MemMap.h"
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : void Adc_Init                                           **
**                    (                                                       **
**                      const Adc_ConfigType *ConfigPtr                       **
**                    )                                                       **
**                                                                            **
** Description      : This API initializes the ADC hardware units and clear   **
**                    global variables to their reset state. The SFRs of the  **
**                    configured kernels are first reset to default values and**
**                    then initialized as per the configuration.              **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x00                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Non - Reentrant                                         **
**                                                                            **
** Parameters(in)   : ConfigPtr - Pointer to ADC configuration Set            **
**                                                                            **
** Parameters (out) : none                                                    **
**                                                                            **
** Return value     : none                                                    **
**                                                                            **
*******************************************************************************/
void Adc_Init(const Adc_ConfigType *ConfigPtr)
{
  uint32 lClcReadBack;
  #if (ADC_DEV_ERROR_DETECT == STD_ON)
  uint8 lDetVal;
  /* Check DET's for the API */
  lDetVal = Adc_lInitDetCheck(ConfigPtr);
  if(ADC_E_NO_ERR == lDetVal)
  #endif
  {
    Mcal_ResetPeripheralEndInitProtection();

    /* Enable module clock via CLC */
    /*MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
      object and integer type is permitted for special function registers*/
    MODULE_EVADC.CLC.U = ((uint32)ADC_SLEEP_MODE_CFG<<IFX_EVADC_CLC_EDIS_OFF);
    /* To ensure CLC is written properly before Endinit is restored */
    DSYNC();
    Mcal_SetPeripheralEndInitProtection();

    /* Time required to set Safety Endinit should be sufficient for CLC
     to be enabled*/
    /*MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
      object and integer type is permitted for special function registers*/
    lClcReadBack = (uint32)MODULE_EVADC.CLC.U;

    /* Check if the clock disable bit - DISS is reset */
    if((lClcReadBack &\
       ((uint32)IFX_EVADC_CLC_DISS_MSK<<IFX_EVADC_CLC_DISS_OFF)) == (uint32)0U)
    {
      /* Raise pass DEM, when CLC enabling is successful*/
      #if (ADC_CLC_FAILURE_DEM_NOTIF == ADC_ENABLE_DEM_REPORT)
      Dem_ReportErrorStatus(ADC_E_CLC_FAILURE, DEM_EVENT_STATUS_PASSED);
      #endif

      /* Store the config pointer passed */
      Adc_kConfigPtr = ConfigPtr;

      /* Local Function to initialize all kernels*/
      Adc_lInit();

      #if (ADC_DEV_ERROR_DETECT == STD_ON)
      /* Set Init complete flag after complete intialization is done*/
      Adc_InitStatus = ADC_INITIALIZED;
      #endif
    }
    #if (ADC_CLC_FAILURE_DEM_NOTIF == ADC_ENABLE_DEM_REPORT)
    else
    {
      /* Raise failure DEM, when CLC enabling fails*/
      Dem_ReportErrorStatus(ADC_E_CLC_FAILURE, DEM_EVENT_STATUS_FAILED);
    }
    #endif
  }
}
#if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : Std_ReturnType Adc_SetupResultBuffer                    **
**                    (                                                       **
**                      Adc_GroupType Group,                                  **
**                      Adc_ValueGroupType *DataBufferPtr                     **
**                    )                                                       **
**                                                                            **
** Description      : This API will set-up the group’s result buffer,         **
**                    where the conversion results will be stored.            **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x0C                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : Group ID and Data buffer pointer                        **
**                                                                            **
** Parameters (out) : none                                                    **
**                                                                            **
** Return value     : E_OK/E_NOT_OK                                           **
**                                                                            **
*******************************************************************************/
Std_ReturnType Adc_SetupResultBuffer(Adc_GroupType Group,\
                                            Adc_ValueGroupType *DataBufferPtr)
{
  Adc_GlobalDataType *lKernelDataPtr;
  Std_ReturnType lRetVal;
  uint32 lKernelId;
  Adc_GroupType lGroupId;

  /* Extract Kernel ID from Group */
  lKernelId = Adc_lGetAdcKernel(Group);
  /* Extract Kernel specific GroupID from Group*/
  lGroupId = Adc_lGetKernelGroupId(Group);

  #if (ADC_DEV_ERROR_DETECT == STD_ON)

  uint8 lDetVal;

  /* Check DET's for the API */
  lDetVal = Adc_lSetupResBufDetCheck(lKernelId,lGroupId,DataBufferPtr);

  if(ADC_E_NO_ERR == lDetVal)
  {
    /* Group should be IDLE mode to set up the result buffer*/
    /*Start of Critcal Section - DET ON*/
    SchM_Enter_Adc_KernelData();
    lDetVal = Adc_lCheckGrpBusyDet(lKernelId,lGroupId,\
                                   ADC_SID_SETUP_RESULT_BUFFER);
    if(ADC_E_NO_ERR != lDetVal)
    {
      /*End of Critical Section - DET Fails*/
      SchM_Exit_Adc_KernelData();
    }
  }
  if(ADC_E_NO_ERR != lDetVal)
  {
    lRetVal = E_NOT_OK;
  }
  else
  #endif /* End for ADC_DEV_ERROR_DETECT*/
  {
    /* Get global state data location for the Kernel */
    lKernelDataPtr = Adc_lGetKernelDataAddress(lKernelId);

    /*Since the group result pointer and No of valid conversion are
      updated in ISR, they are accessed under critical section*/
    #if (ADC_DEV_ERROR_DETECT == STD_OFF)
    /*Start of Critcal Section - DET OFF*/
    SchM_Enter_Adc_KernelData();
    #endif

    lKernelDataPtr->GrpResBuffer[lGroupId] = DataBufferPtr;
    /* Reset Next Buffer Position and Valid Result count to 0*/
    lKernelDataPtr->NumofValidConRes[lGroupId] = (Adc_StreamNumSampleType)0U;

    /*End of Critical Section*/
    SchM_Exit_Adc_KernelData();

    lRetVal = E_OK;
  }
return(lRetVal);
}
#endif /*End for ADC_RESULT_HANDLING_IMPLEMENTATION */
#if (ADC_DEINIT_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : void Adc_DeInit                                         **
**                    (                                                       **
**                      void                                                  **
**                    )                                                       **
**                                                                            **
** Description      : This API resets all SFRs (including SRC) of the kernels **
**                    configured by Adc_Init to their reset states. It also   **
**                    resets the global SFR’s (common to all Kernels) of the  **
**                    EVADC IP.                                               **
**                    Note: SFRs of kernels not configured by Adc_Init are    **
**                    not de-initialized by this API                          **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x01                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Non - Reentrant                                         **
**                                                                            **
** Parameters(in)   : none                                                    **
**                                                                            **
** Parameters (out) : none                                                    **
**                                                                            **
** Return value     : none                                                    **
**                                                                            **
*******************************************************************************/
void Adc_DeInit(void)
{
  const Adc_ConfigType *lConfigPtr;
  uint32 lKernelCount;

  #if (ADC_DEV_ERROR_DETECT == STD_ON)

  uint8 lDetVal;
  /* Check DET's for the API */
  lDetVal = Adc_lDeInitDetCheck();

  if(ADC_E_NO_ERR == lDetVal)
  #endif
  {
    /* Store the config pointer locally, to be used for deinit of kernels*/
    lConfigPtr = Adc_kConfigPtr;
    /* The init status and config pointer is reset here, so that an interrupted
       Deinit will result in DETs when other APIs are invoked*/
    Adc_kConfigPtr = NULL_PTR;
    #if (ADC_DEV_ERROR_DETECT == STD_ON)
    Adc_InitStatus = ADC_UNINITIALIZED;
    #endif

    /* Loop till the last Kernel ID */
    for(lKernelCount=(uint32)0U; lKernelCount<ADC_MAX_KERNEL_ID; lKernelCount++)
    {
      if(lConfigPtr->HwUnitCfgPtr[lKernelCount] != NULL_PTR)
      {
        /* Only kernels configured by user are de-intialized here */
        Adc_lKernelDeInit(lConfigPtr->HwUnitCfgPtr[lKernelCount],\
                                                    lKernelCount);
      }
    }

    /* Reset Global SFRs common across all Kernels*/
    Adc_lResetGlobalSfr();

    Mcal_ResetPeripheralEndInitProtection();
    /*Disable the clock via CLC, reset to default value */
    /*MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
      object and integer type is permitted for special function registers*/
    MODULE_EVADC.CLC.U = ADC_CLC_DEFAULT_VALUE;
    /* To ensure CLC is written properly before Endinit is restored */
    DSYNC();
    Mcal_SetPeripheralEndInitProtection();

    /* Reset Global variables of the driver */
    Adc_lResetGlobalVars();
  }
}
#endif /* End for ADC_DEINIT_API */

#if (ADC_ENABLE_START_STOP_GROUP_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : void Adc_StartGroupConversion                           **
**                    (                                                       **
**                      Adc_GroupType Group                                   **
**                    )                                                       **
**                                                                            **
** Description      : This API setups the group for conversion and starts the **
**                    conversion of the requested ADC Channel group           **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x02                                                    **
**                                                                            **
** Sync/Async       : Asynchronous                                            **
**                                                                            **
** Reentrancy       : Conditionally reentrant – API is re-entrant only for    **
**                    Groups executing on different ADC Kernels               **
**                                                                            **
** Parameters(in)   : Group - Numeric ID of requested ADC Channel group.      **
**                                                                            **
** Parameters (out) : none                                                    **
**                                                                            **
** Return value     : none                                                    **
**                                                                            **
*******************************************************************************/
void Adc_StartGroupConversion(Adc_GroupType Group)
{
  uint32 lKernelId;
  Adc_GroupType lGroupId;

  /* Extract Kernel ID from Group */
  lKernelId = Adc_lGetAdcKernel(Group);
  /* Extract Kernel specific GroupID from Group*/
  lGroupId = Adc_lGetKernelGroupId(Group);

  #if (ADC_DEV_ERROR_DETECT == STD_ON)

  uint8 lDetVal;

  /* Check DET's for the API */
  lDetVal = Adc_lStartGrpConvDetCheck(lKernelId,lGroupId);

  if(ADC_E_NO_ERR == lDetVal)
  {
    /*Start of Critcal Section - DET ON*/
    SchM_Enter_Adc_KernelData();
    lDetVal = Adc_lCheckGrpBusyDet(lKernelId,lGroupId,\
                                   ADC_SID_START_GROUP_CONVERSION);
    if(ADC_E_NO_ERR != lDetVal)
    {
      /*End of Critcal Section - DET Fails*/
      SchM_Exit_Adc_KernelData();
    }
  }
  if(ADC_E_NO_ERR == lDetVal)
  #endif
  {
    #if (ADC_ENABLE_QUEUING == STD_ON)
      #if (ADC_DEV_ERROR_DETECT == STD_OFF)
      /*Start of Critcal Section - DET OFF*/
      SchM_Enter_Adc_KernelData();
      #endif
      /* Push the group on to the SW queue,
         groups is started immediately if the SW queue is currently empty*/
      Adc_lPushToQueue(lKernelId,lGroupId);
      /*End of Critcal Section - DET Fails*/
      SchM_Exit_Adc_KernelData();
    #else

    Adc_GlobalDataType *lKernelDataPtr;
    const Adc_GroupCfgType *lGrpCfgPtr;

    /* Get global state data location for the Kernel */
    lKernelDataPtr = Adc_lGetKernelDataAddress(lKernelId);
    /* Get group configuration address */
    lGrpCfgPtr =  &(Adc_kConfigPtr->HwUnitCfgPtr[lKernelId]->\
                                  GrpCfgPtr[lGroupId]);
    #if (ADC_DEV_ERROR_DETECT == STD_OFF)
    /*Start of Critcal Section - DET OFF*/
    SchM_Enter_Adc_KernelData();
    #endif

    /* Update group status to busy state */
    Adc_lSetGroupStatusBusyAtomic(lKernelDataPtr,lGroupId);
    Adc_lClrGroupResultAtomic(lKernelDataPtr,lGroupId);
    Adc_lClrResBuffEndStatusAtomic(lKernelDataPtr,lGroupId);
    #if (ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
    lKernelDataPtr->NumofValidConRes[lGroupId] = (Adc_StreamNumSampleType)0U;
    #endif
    /* Update the Active group ID to RS runtime data */
    lKernelDataPtr->RSData[lGrpCfgPtr->GrpReqSrc].ActiveGroupId = lGroupId;

    #if (ADC_PRIORITY_IMPLEMENTATION != ADC_PRIORITY_NONE)
    /* Set flags for used channels and result registers */
    lKernelDataPtr->AllRunningChannels |= lGrpCfgPtr->ChannelMask;
    lKernelDataPtr->AllRunningResReg |= lGrpCfgPtr->ResultRegMask;
    #endif

    /* Set the limit check group */
    #if (ADC_ENABLE_LIMIT_CHECK == STD_ON)
    if((uint8)ADC_ONE_U == lGrpCfgPtr->LimitCheckGroup)
    {
      lKernelDataPtr->RSData[lGrpCfgPtr->GrpReqSrc].ActiveLimitChkCh=\
            lGrpCfgPtr->GroupDefinition[0U].AnalogChannelNo;
      /*lKernelDataPtr->LimitChkGroupId = lGroupId;*/
    }
    #endif

    /*End of Critical Section*/
    SchM_Exit_Adc_KernelData();

    /* Prepare channels and result registers */
    Adc_lPrepareGrpForStart(lKernelId,lGroupId);

    /* Enable ISR servicing for the request source */
    lKernelDataPtr->RSData[lGrpCfgPtr->GrpReqSrc].IsrNoServiceFlag = (uint8)0U;

    /* Prepare queue and trigger the SW conversion */
    Adc_lStartSwConversion(lGrpCfgPtr,lKernelId);

    #endif /* End for ADC_ENABLE_QUEUING */
  }
}
#endif /* End for ADC_ENABLE_START_STOP_GROUP_API */

#if (ADC_ENABLE_START_STOP_GROUP_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : void Adc_StopGroupConversion                            **
**                    (                                                       **
**                      Adc_GroupType Group                                   **
**                    )                                                       **
**                                                                            **
** Description      : This API stops the conversion of the requested ADC      **
**                    Channel group                                           **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x03                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally reentrant – API is re-entrant only for    **
**                    Groups executing on different ADC Kernels               **
**                                                                            **
** Parameters(in)   : Group - Numeric ID of requested ADC Channel group.      **
**                                                                            **
** Parameters (out) : none                                                    **
**                                                                            **
** Return value     : none                                                    **
**                                                                            **
*******************************************************************************/
void Adc_StopGroupConversion(Adc_GroupType Group)
{
  uint32 lKernelId;
  Adc_GroupType lGroupId;

  /* Extract Kernel ID from Group */
  lKernelId = Adc_lGetAdcKernel(Group);
  /* Extract Kernel specific GroupID from Group*/
  lGroupId = Adc_lGetKernelGroupId(Group);

  #if (ADC_DEV_ERROR_DETECT == STD_ON)

  uint8 lDetVal;

  /* Check DET's for the API */
  lDetVal = Adc_lStopGrpConvDetCheck(lKernelId,lGroupId);
  if(ADC_E_NO_ERR == lDetVal)
  {
    /*Start of Critcal Section - DET ON*/
    SchM_Enter_Adc_KernelData();
    lDetVal = Adc_lCheckGrpIdleDet(lKernelId,lGroupId,\
                                  ADC_SID_STOP_GROUP_CONVERSION);
    if(ADC_E_NO_ERR != lDetVal)
    {
      /* End of Critical Section - DET fails */
      SchM_Exit_Adc_KernelData();
    }
  }
  if(ADC_E_NO_ERR == lDetVal)
  #endif
  {
    #if (ADC_ENABLE_QUEUING == STD_ON)
      /* Pop/remove the group on to the SW queue,
         groups has to be stopped if the group is at the currently converting*/
      #if (ADC_DEV_ERROR_DETECT == STD_OFF)
      /*Start of Critcal Section - DET OFF */
      SchM_Enter_Adc_KernelData();
      #endif
      Adc_lPopFromQueue(lKernelId,lGroupId);
      /* End of Critical Section */
      SchM_Exit_Adc_KernelData();
    #else

    Adc_GlobalDataType *lKernelDataPtr;
    const Adc_GroupCfgType *lGrpCfgPtr;

    /* Get global state data location for the Kernel */
    lKernelDataPtr = Adc_lGetKernelDataAddress(lKernelId);
    /* Get group configuration address */
    lGrpCfgPtr =  &(Adc_kConfigPtr->HwUnitCfgPtr[lKernelId]->\
                                         GrpCfgPtr[lGroupId]);
    #if (ADC_DEV_ERROR_DETECT == STD_OFF)
    /*Start of Critcal Section - DET OFF */
    SchM_Enter_Adc_KernelData();
    #endif

    /* Stop a group only if it is currently Converting - BUSY */
    if(Adc_lGetGroupStatus(lKernelDataPtr,lGroupId) == (uint32)ADC_ONE_U)
    {
      /* Disable ISR servicing for the request source */
      lKernelDataPtr->RSData[lGrpCfgPtr->GrpReqSrc].IsrNoServiceFlag = \
                                                        (uint8)ADC_ONE_U;
      SchM_Exit_Adc_KernelData();
      /* Stop the ongoing conversions */
      Adc_lStopConvRequest(lGrpCfgPtr,lKernelId);
      /* Remove Active Group ID from the Global Kernel Data */
      Adc_lRemoveActiveGroup(lKernelDataPtr,lGrpCfgPtr);
    }
    else
    {
      /* End of Critical Section */
      SchM_Exit_Adc_KernelData();
    }
    /*Start of Critcal Section */
    SchM_Enter_Adc_KernelData();
    /*Restore group status to IDLE*/
    Adc_lClrGroupStatusBusyAtomic(lKernelDataPtr,lGroupId);
    Adc_lClrGroupResultAtomic(lKernelDataPtr,lGroupId);
    Adc_lClrResBuffEndStatusAtomic(lKernelDataPtr,lGroupId);
    #if (ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
    lKernelDataPtr->NumofValidConRes[lGroupId] = (Adc_StreamNumSampleType)0U;
    #endif
    #if (ADC_GRP_NOTIF_CAPABILITY == STD_ON)
    /*Disable group notification*/
    Adc_lClrGrpNotifAtomic(lKernelDataPtr,lGroupId);
    #endif /* End for ADC_GRP_NOTIF_CAPABILITY*/

    /* End of Critical Section */
    SchM_Exit_Adc_KernelData();
    #endif /* End for ADC_ENABLE_QUEUING */
  }
}
#endif /* (End for ADC_ENABLE_START_STOP_GROUP_API*/

#if (ADC_READ_GROUP_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : Std_ReturnType Adc_ReadGroup                            **
**                    (                                                       **
**                      Adc_GroupType Group                                   **
**                      Adc_ValueGroupType *DataBufferPtr                     **
**                    )                                                       **
**                                                                            **
** Description      : This API reads the group conversion result of the last  **
**                    completed conversion round of the requested group and   **
**                    stores the channel’s conversion value starting from     **
**                    DataBufferPtr address. The channel’s conversion values  **
**                    are stored in ascending channel number order            **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x04                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Re-Entrant                                **
**                                                                            **
** Parameters(in)   : Group - Numeric ID of requested ADC Channel group.      **
**                                                                            **
** Parameters (out) : DataBufferPtr - Location to store the requested Group's **
**                    channels conversion result                              **
**                                                                            **
** Return value     : E_OK - Results are available and written to the data    **
**                           buffer                                           **
**                    E_NOT_OK - No results are available or development      **
**                               error occurred                               **
**                                                                            **
*******************************************************************************/
Std_ReturnType Adc_ReadGroup(Adc_GroupType Group,
                                     Adc_ValueGroupType *DataBufferPtr)
{
  const Adc_GroupCfgType *lGrpCfgPtr;
  Adc_GlobalDataType *lKernelDataPtr;
  const Adc_ValueGroupType *lCurrentResultPtr;
  uint32 lKernelId,lBusyFlag,lResultFlag;
  Std_ReturnType lRetVal;
  Adc_GroupType lGroupId;
  Adc_StreamNumSampleType lNoofValidConv,lNumOfSamples;
  uint8 lNoOfChannels;

  /* Extract Kernel ID from Group */
  lKernelId = Adc_lGetAdcKernel(Group);
  /* Extract Kernel specific GroupID from Group*/
  lGroupId = Adc_lGetKernelGroupId(Group);

  #if (ADC_DEV_ERROR_DETECT == STD_ON)

  uint8 lDetVal;
  /* Check DET's for the API */
  lDetVal = Adc_lReadGrpDetCheck(lKernelId,lGroupId);
  if(ADC_E_NO_ERR == lDetVal)
  {
    /*Start of Critcal Section - DET ON*/
    SchM_Enter_Adc_KernelData();
    lDetVal = Adc_lCheckGrpIdleDet(lKernelId,lGroupId,ADC_SID_READ_GROUP);
    if(ADC_E_NO_ERR != lDetVal)
    {
      /* End of Critical Section - DET fails */
      SchM_Exit_Adc_KernelData();
    }
  }
  if(ADC_E_NO_ERR != lDetVal)
  {
    lRetVal = E_NOT_OK;
  }
  else
  #endif
  {
    /* Get global state data location for the Kernel */
    lKernelDataPtr = Adc_lGetKernelDataAddress(lKernelId);
    /* Get group configuration address */
    lGrpCfgPtr = &(Adc_kConfigPtr->HwUnitCfgPtr[lKernelId]->\
                                           GrpCfgPtr[lGroupId]);

    /* Get Channel count for the group*/
    lNumOfSamples = lGrpCfgPtr->NumOfSamples;
    /* Get Number of channels present in the group */
    lNoOfChannels = lGrpCfgPtr->NoOfChannels;

    /*Critical Section is protecting the result copy to application.
      Since, for continuous conversion groups with 1 streaming sample,
      the same result buffer position will be written in ISR and read from
      this API. Hence, while the read is ON, the write from ISR should be
      protected, to get a consistent result set for all the channels*/

    /*Start of Critcal Section - DET OFF*/
    #if (ADC_DEV_ERROR_DETECT == STD_OFF)
    SchM_Enter_Adc_KernelData();
    #endif

    /* Get group status flags */
    lBusyFlag = Adc_lGetGroupStatus(lKernelDataPtr,lGroupId);
    lResultFlag = Adc_lGetGroupResultStatus(lKernelDataPtr,lGroupId);
    /* Get Number of valid results available */
    lNoofValidConv = lKernelDataPtr->NumofValidConRes[lGroupId];

    /* Check if group is busy with no results or DataBufferPtr is NULL */
    if( (DataBufferPtr == NULL_PTR)||\
        ((lBusyFlag == (uint32)1U) && (lResultFlag == (uint32)0U)) )
    {
      lRetVal = E_NOT_OK;
    }
    else
    {
      /*
      Application Result Buffer organisation for
      - 5 Channels - CH9, CH1, CH2, CH3 and CH4
      - 3 streaming samples for each channel

        Buffer Start                                       Buffer End
        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
        |CH9|CH9|CH9|CH1|CH1|CH1|CH2|CH2|CH2|CH3|CH3|CH3|CH4|CH4|CH4|
        +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
      */

      /* Get the pointer to the latest available conversion results */
      /* MISRA2012_RULE_18_4_JUSTIFICATION: Pointer arithmetic other than 
      array indexing used for ADC application buffers. The buffer layout for 
      result handling as defined by AUTOSAR forces to use pointer arithmetic. 
      The access range is within the boundaries of the buffer.*/
      lCurrentResultPtr = (lKernelDataPtr->GrpResBuffer[lGroupId] + \
                          lNoofValidConv - (Adc_StreamNumSampleType)1U);
      do
      {
        *DataBufferPtr = *lCurrentResultPtr;
        DataBufferPtr++;
        /* MISRA2012_RULE_18_4_JUSTIFICATION: Pointer arithmetic other than
        array indexing used for ADC application buffers. The buffer layout for 
        result handling as defined by AUTOSAR forces to use pointer arithmetic. 
        The access range is within the boundaries of the buffer.*/
        lCurrentResultPtr += lNumOfSamples;
        lNoOfChannels--;
      }while(lNoOfChannels>(uint8)0U);

      /* Reset Group Status to BUSY for currently converting groups */
      Adc_lClrGroupResultAtomic(lKernelDataPtr,lGroupId);
      Adc_lClrResBuffEndStatusAtomic(lKernelDataPtr,lGroupId);
      /* Groups which are not converting - implicitly stopped
         are put to IDLE state*/
      if(lBusyFlag == (uint32)0U)
      {
        lKernelDataPtr->NumofValidConRes[lGroupId] =\
                                               (Adc_StreamNumSampleType)0U;
      }
      lRetVal = E_OK;
    }
    /*End of Critcal Section */
    SchM_Exit_Adc_KernelData();
  }
return(lRetVal);
}
#endif /* End for ADC_READ_GROUP_API */

#if (ADC_HW_TRIGGER_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : void Adc_EnableHardwareTrigger                          **
**                    (                                                       **
**                      Adc_GroupType Group                                   **
**                    )                                                       **
**                                                                            **
** Description      : This API setups the group for conversion and enables    **
**                    the hardware trigger for the requested ADC Group.       **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x05                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally reentrant – API is re-entrant only for    **
**                    Groups executing on different ADC Kernels               **
**                                                                            **
** Parameters(in)   : Group - Numeric ID of requested ADC Channel group.      **
**                                                                            **
** Parameters (out) : none                                                    **
**                                                                            **
** Return value     : none                                                    **
**                                                                            **
*******************************************************************************/
void Adc_EnableHardwareTrigger(Adc_GroupType Group)
{
  Adc_GlobalDataType *lKernelDataPtr;
  const Adc_GroupCfgType *lGrpCfgPtr;
  uint32 lKernelId;
  Adc_GroupType lGroupId;

  /* Extract Kernel ID from Group */
  lKernelId = Adc_lGetAdcKernel(Group);
  /* Extract Kernel specific GroupID from Group*/
  lGroupId = Adc_lGetKernelGroupId(Group);

  #if (ADC_DEV_ERROR_DETECT == STD_ON)

  uint8 lDetVal;
  /* Check DET's for the API */
  lDetVal = Adc_lEnHwTriggerDetCheck(lKernelId,lGroupId);
  if(ADC_E_NO_ERR == lDetVal)
  {
    /*Start of Critcal Section - DET ON*/
    SchM_Enter_Adc_KernelData();
    lDetVal = Adc_lCheckGrpBusyDet(lKernelId,lGroupId,\
                                   ADC_SID_ENABLE_HARDWARE_TRIGGER);
    if(ADC_E_NO_ERR != lDetVal)
    {
      /*End of Critcal Section - DET Fails*/
      SchM_Exit_Adc_KernelData();
    }
  }
  if(ADC_E_NO_ERR == lDetVal)
  #endif
  {
    /* Get global state data location for the Kernel */
    lKernelDataPtr = Adc_lGetKernelDataAddress(lKernelId);
    /* Get group configuration address */
    lGrpCfgPtr =  &(Adc_kConfigPtr->HwUnitCfgPtr[lKernelId]->\
                                             GrpCfgPtr[lGroupId]);
    #if (ADC_DEV_ERROR_DETECT == STD_OFF)
    /*Start of Critcal Section - DET OFF*/
    SchM_Enter_Adc_KernelData();
    #endif

    #if (ADC_ENABLE_QUEUING == STD_ON)
    /* Since, the SW queue is empty, place the group on Queue head
       Further calls to to start SW Triggered group will be queued and
       will be started when current HW triggered groups is stopped */
    lKernelDataPtr->PushGroupId = lGroupId;
    lKernelDataPtr->PopGroupId = lGroupId;
    #endif

    /* Update group status to busy state */
    Adc_lSetGroupStatusBusyAtomic(lKernelDataPtr,lGroupId);
    Adc_lClrGroupResultAtomic(lKernelDataPtr,lGroupId);
    Adc_lClrResBuffEndStatusAtomic(lKernelDataPtr,lGroupId);
    #if (ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
    lKernelDataPtr->NumofValidConRes[lGroupId] = (Adc_StreamNumSampleType)0U;
    #endif
    /* Update active group ID to the RS runtime data */
    lKernelDataPtr->RSData[lGrpCfgPtr->GrpReqSrc].ActiveGroupId = lGroupId;

    #if (ADC_PRIORITY_IMPLEMENTATION != ADC_PRIORITY_NONE)
    /* Set flags for used channels and result registers */
    lKernelDataPtr->AllRunningChannels |= lGrpCfgPtr->ChannelMask;
    lKernelDataPtr->AllRunningResReg |= lGrpCfgPtr->ResultRegMask;
    #endif

    /* Set the limit check group */
    #if (ADC_ENABLE_LIMIT_CHECK==STD_ON)
    if((uint8)ADC_ONE_U == lGrpCfgPtr->LimitCheckGroup)
    {
      lKernelDataPtr->RSData[lGrpCfgPtr->GrpReqSrc].ActiveLimitChkCh=\
            lGrpCfgPtr->GroupDefinition[0U].AnalogChannelNo;
    }
    #endif

    /*End of Critcal Section*/
    SchM_Exit_Adc_KernelData();

    /* Prepare channels and result registers */
    Adc_lPrepareGrpForStart(lKernelId,lGroupId);

    /* Enable ISR servicing for the request source */
    lKernelDataPtr->RSData[lGrpCfgPtr->GrpReqSrc].IsrNoServiceFlag = (uint8)0U;

    /* Prepare queue and enable HW trigger peripheral conversion */
    Adc_lStartHwConversion(lGrpCfgPtr,lKernelId);
  }
}
#endif /* End for ADC_HW_TRIGGER_API */

#if (ADC_HW_TRIGGER_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : void Adc_DisableHardwareTrigger                         **
**                    (                                                       **
**                      Adc_GroupType Group                                   **
**                    )                                                       **
**                                                                            **
** Description      : This function  stops the ongoing conversion and disables**
**                    hardware trigger for the requested ADC Channel group.   **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x06                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally reentrant – API is re-entrant only for    **
**                    Groups executing on different ADC Kernels               **
**                                                                            **
** Parameters(in)   : Group - Numeric ID of requested ADC Channel group.      **
**                                                                            **
** Parameters (out) : none                                                    **
**                                                                            **
** Return value     : none                                                    **
**                                                                            **
*******************************************************************************/
void Adc_DisableHardwareTrigger(Adc_GroupType Group)
{
  uint32 lKernelId;
  Adc_GroupType lGroupId;

  /* Extract Kernel ID from Group */
  lKernelId = Adc_lGetAdcKernel(Group);
  /* Extract Kernel specific GroupID from Group*/
  lGroupId = Adc_lGetKernelGroupId(Group);

  #if (ADC_DEV_ERROR_DETECT == STD_ON)

  uint8 lDetVal;
  /* Check DET's for the API */
  lDetVal = Adc_lDisHwTriggerDetCheck(lKernelId,lGroupId);
  if(ADC_E_NO_ERR == lDetVal)
  {
    /*Start of Critcal Section - DET ON*/
    SchM_Enter_Adc_KernelData();
    lDetVal = Adc_lCheckGrpIdleDet(lKernelId,lGroupId,\
                                  ADC_SID_DISABLE_HARDWARE_TRIGGER);
    if(ADC_E_NO_ERR != lDetVal)
    {
      /* End of Critical Section - DET fails */
      SchM_Exit_Adc_KernelData();
    }
  }
  if(ADC_E_NO_ERR == lDetVal)
  #endif
  {
    #if (ADC_ENABLE_QUEUING == STD_ON)
      /*Since it is a HW triggered group,
      it has to be stopped because it is converting currently*/
      #if (ADC_DEV_ERROR_DETECT == STD_OFF)
      /*Start of Critcal Section - DET OFF */
      SchM_Enter_Adc_KernelData();
      #endif
      Adc_lPopFromQueue(lKernelId,lGroupId);
      /* End of Critical Section */
      SchM_Exit_Adc_KernelData();
    #else

    Adc_GlobalDataType *lKernelDataPtr;
    const Adc_GroupCfgType *lGrpCfgPtr;

    /* Get global state data location for the Kernel */
    lKernelDataPtr = Adc_lGetKernelDataAddress(lKernelId);
    /* Get group configuration address */
    lGrpCfgPtr =  &(Adc_kConfigPtr->HwUnitCfgPtr[lKernelId]->\
                                               GrpCfgPtr[lGroupId]);
    #if (ADC_DEV_ERROR_DETECT == STD_OFF)
    /*Start of Critcal Section - DET OFF */
    SchM_Enter_Adc_KernelData();
    #endif
    /*Stop a group only if it is currently Converting-BUSY*/
    if(Adc_lGetGroupStatus(lKernelDataPtr,lGroupId) == (uint32)ADC_ONE_U)
    {
      /* Disable ISR servicing for the request source */
      lKernelDataPtr->RSData[lGrpCfgPtr->GrpReqSrc].IsrNoServiceFlag =\
                                                           (uint8)ADC_ONE_U;
      /* End of Critical Section */
      SchM_Exit_Adc_KernelData();
      /* Stop the ongoing conversions */
      Adc_lStopConvRequest(lGrpCfgPtr,lKernelId);
      /* Remove Active Group ID from the Global Kernel Data */
      Adc_lRemoveActiveGroup(lKernelDataPtr,lGrpCfgPtr);
    }
    else
    {
      /* End of Critical Section */
      SchM_Exit_Adc_KernelData();
    }

    /*Start of Critcal Section */
    SchM_Enter_Adc_KernelData();
    /*Restore group status to IDLE*/
    Adc_lClrGroupStatusBusyAtomic(lKernelDataPtr,lGroupId);
    Adc_lClrGroupResultAtomic(lKernelDataPtr,lGroupId);
    Adc_lClrResBuffEndStatusAtomic(lKernelDataPtr,lGroupId);
    #if (ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
    lKernelDataPtr->NumofValidConRes[lGroupId] = (Adc_StreamNumSampleType)0U;
    #endif
    #if (ADC_GRP_NOTIF_CAPABILITY == STD_ON)
    /*Disable group notification*/
    Adc_lClrGrpNotifAtomic(lKernelDataPtr,lGroupId);
    #endif /* End for ADC_GRP_NOTIF_CAPABILITY*/

    /* End of Critical Section */
    SchM_Exit_Adc_KernelData();
    #endif
  }
}
#endif /* End for ADC_HW_TRIGGER_API */

#if (ADC_GRP_NOTIF_CAPABILITY == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : void Adc_EnableGroupNotification                        **
**                    (                                                       **
**                      Adc_GroupType Group                                   **
**                    )                                                       **
**                                                                            **
** Description      : This API enables the notification mechanism for the     **
**                    requested ADC Channel group.                            **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x07                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-entrant                                              **
**                                                                            **
** Parameters(in)   : Group - Numeric ID of requested ADC Channel group.      **
**                                                                            **
** Parameters (out) : none                                                    **
**                                                                            **
** Return value     : none                                                    **
**                                                                            **
*******************************************************************************/
void Adc_EnableGroupNotification(Adc_GroupType Group)
{
  Adc_GlobalDataType *lKernelDataPtr;
  uint32 lKernelId;
  Adc_GroupType lGroupId;

  /* Extract Kernel ID from Group */
  lKernelId = Adc_lGetAdcKernel(Group);
  /* Extract Kernel specific GroupID from Group*/
  lGroupId = Adc_lGetKernelGroupId(Group);

  #if (ADC_DEV_ERROR_DETECT == STD_ON)

  uint8 lDetVal;
  /* Check DET's for the API */
  lDetVal = Adc_lEnGrpNotifDetCheck(lKernelId,lGroupId);
  if(ADC_E_NO_ERR == lDetVal)
  #endif
  {
    /* Get global state data location for the Kernel */
    lKernelDataPtr = Adc_lGetKernelDataAddress(lKernelId);
    /* Enable Group Notifications - Atomically, hence no critical
      section is needed here */
    Adc_lSetGrpNotifAtomic(lKernelDataPtr,lGroupId);
  }
}
#endif /* End for ADC_GRP_NOTIF_CAPABILITY*/

#if (ADC_GRP_NOTIF_CAPABILITY == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : void Adc_DisableGroupNotification                       **
**                    (                                                       **
**                      Adc_GroupType Group                                   **
**                    )                                                       **
**                                                                            **
** Description      : This API disables the notification mechanism for the    **
**                    requested ADC Channel group.                            **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x08                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : Group - Numeric ID of requested ADC Channel group.      **
**                                                                            **
** Parameters (out) : none                                                    **
**                                                                            **
** Return value     : none                                                    **
**                                                                            **
*******************************************************************************/
void Adc_DisableGroupNotification(Adc_GroupType Group)
{
  Adc_GlobalDataType *lKernelDataPtr;
  uint32 lKernelId;
  Adc_GroupType lGroupId;

  /* Extract Kernel ID from Group */
  lKernelId = Adc_lGetAdcKernel(Group);
  /* Extract Kernel specific GroupID from Group */
  lGroupId = Adc_lGetKernelGroupId(Group);

  #if (ADC_DEV_ERROR_DETECT == STD_ON)

  uint8 lDetVal;
  /* Check DET's for the API */
  lDetVal = Adc_lDisGrpNotifDetCheck(lKernelId,lGroupId);
  if(ADC_E_NO_ERR == lDetVal)
  #endif
  {
    /* Get global state data location for the Kernel */
    lKernelDataPtr = Adc_lGetKernelDataAddress(lKernelId);
    /* Disable Group Notifications  - Atomically, hence no critical
      section is needed here */
    Adc_lClrGrpNotifAtomic(lKernelDataPtr,lGroupId);
  }
}
#endif /* End for ADC_GRP_NOTIF_CAPABILITY*/

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : Adc_StatusType Adc_GetGroupStatus                       **
**                    (                                                       **
**                      Adc_GroupType Group                                   **
**                    )                                                       **
**                                                                            **
** Description      : This API returns the conversion status of the requested **
**                    ADC Channel group.                                      **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x09                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : Group - Numeric ID of requested ADC Channel group.      **
**                                                                            **
** Parameters (out) : none                                                    **
**                                                                            **
** Return value     : Adc_StatusType                                          **
**                    Conversion status for the requested group               **
**                                                                            **
*******************************************************************************/
Adc_StatusType Adc_GetGroupStatus(Adc_GroupType Group)
{
  const Adc_GlobalDataType *lKernelDataPtr;
  uint32 lKernelId,lStrmCompletedFlag,lResultFlag,lBusyFlag;
  Adc_GroupType lGroupId;
  Adc_StatusType lRetVal;

  /* Extract Kernel ID from Group */
  lKernelId = Adc_lGetAdcKernel(Group);
  /* Extract Kernel specific GroupID from Group*/
  lGroupId = Adc_lGetKernelGroupId(Group);

  #if (ADC_DEV_ERROR_DETECT == STD_ON)

  uint8 lDetVal;
  /* Check DET's for the API */
  lDetVal = Adc_lGetGrpStatusDetCheck(lKernelId,lGroupId);
  if(ADC_E_NO_ERR != lDetVal)
  {
    /* Return status as IDLE in case of DET */
    lRetVal = ADC_IDLE;
  }
  else
  #endif
  {
    /* Get global state data location for the Kernel */
    lKernelDataPtr = Adc_lGetKernelDataAddress(lKernelId);

    /*Start of Critcal Section */
    SchM_Enter_Adc_KernelData();

    /* Get all the group status flags */
    lStrmCompletedFlag = Adc_lGetResBuffEndStatus(lKernelDataPtr,lGroupId);
    lResultFlag = Adc_lGetGroupResultStatus(lKernelDataPtr,lGroupId);
    lBusyFlag = Adc_lGetGroupStatus(lKernelDataPtr,lGroupId);

    /*End of Critical Section */
    SchM_Exit_Adc_KernelData();

    if((uint32)ADC_ONE_U == lStrmCompletedFlag)
    {
      lRetVal = ADC_STREAM_COMPLETED;
    }
    else if((uint32)ADC_ONE_U == lResultFlag)
    {
      lRetVal = ADC_COMPLETED;
    }
    else if((uint32)ADC_ONE_U == lBusyFlag)
    {
      lRetVal = ADC_BUSY;
    }
    else
    {
      lRetVal = ADC_IDLE;
    }
  }
return(lRetVal);
}
#if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : Adc_StreamNumSampleType Adc_GetStreamLastPointer        **
**                    (                                                       **
**                      Adc_GroupType Group                                   **
**                      Adc_ValueGroupType **PtrToSamplePtr                   **
**                    )                                                       **
**                                                                            **
** Description      : This API returns the number of valid samples per channel**
**                    stored in the result buffer. It also returns a pointer  **
**                    to the result buffer containing the latest available    **
**                    conversion results.                                     **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x0b                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Re-entrant                                **
**                                                                            **
** Parameters(in)   : Group - Numeric ID of requested ADC Channel group.      **
**                                                                            **
** Parameters (out) : SamplePtr - Pointer to the last acquired value.         **
**                                                                            **
** Return value     : Adc_StreamNumSampleType                                 **
**                    Number of valid samples per channel.                    **
**                                                                            **
*******************************************************************************/
Adc_StreamNumSampleType Adc_GetStreamLastPointer(
                    Adc_GroupType Group,  Adc_ValueGroupType **PtrToSamplePtr)
{
  const Adc_GroupCfgType *lGrpCfgPtr;
  Adc_GlobalDataType *lKernelDataPtr;
  Adc_StreamNumSampleType lNoOfValidConv;
  uint32 lKernelId,lBusyFlag,lStrmCompletedFlag,lResultFlag;
  Adc_GroupType lGroupId;


  /* Extract Kernel ID from Group */
  lKernelId = Adc_lGetAdcKernel(Group);
  /* Extract Kernel specific GroupID from Group*/
  lGroupId = Adc_lGetKernelGroupId(Group);

  #if (ADC_DEV_ERROR_DETECT == STD_ON)

  uint8 lDetVal;
  /* Check DET's for the API */
  lDetVal = Adc_lGetStrmPtrDetCheck(lKernelId,lGroupId);
  if(ADC_E_NO_ERR == lDetVal)
  {
    /*Start of Critcal Section - DET ON*/
    SchM_Enter_Adc_KernelData();
    lDetVal = Adc_lCheckGrpIdleDet(lKernelId,lGroupId,\
                                   ADC_SID_GET_STREAM_LAST_POINTER);
    if(ADC_E_NO_ERR != lDetVal)
    {
      /*End of Critcal Section - DET Fails*/
      SchM_Exit_Adc_KernelData();
    }
  }
  if(ADC_E_NO_ERR != lDetVal)
  {
    /* In case of error return 0 and NULL_PTR for samples */
    lNoOfValidConv = (Adc_StreamNumSampleType)0U;
    *PtrToSamplePtr = NULL_PTR;
  }
  else
  #endif
  {
    /* Get global state data location for the Kernel */
    lKernelDataPtr = Adc_lGetKernelDataAddress(lKernelId);
    /* Get group configuration address */
    lGrpCfgPtr = &(Adc_kConfigPtr->HwUnitCfgPtr[lKernelId]->\
                                               GrpCfgPtr[lGroupId]);

    /*The status flags and number of valid results are read in critical section.
      The calculation of the last result set pointer location need not
      be in critical section*/
    #if (ADC_DEV_ERROR_DETECT == STD_OFF)
    /*Start of Critcal Section - DET OFF*/
     SchM_Enter_Adc_KernelData();
    #endif

    /* Get groups status flags */
    lStrmCompletedFlag = Adc_lGetResBuffEndStatus(lKernelDataPtr,lGroupId);
    lResultFlag = Adc_lGetGroupResultStatus(lKernelDataPtr,lGroupId);
    lBusyFlag = Adc_lGetGroupStatus(lKernelDataPtr,lGroupId);
    lNoOfValidConv = lKernelDataPtr->NumofValidConRes[lGroupId];

    /* Check if group is busy with no results*/
    if((lBusyFlag == (uint32)1U) && (lResultFlag == (uint32)0U))
    {
      /*End of Critcal Section*/
      SchM_Exit_Adc_KernelData();
      /* Conversion on going but no result set available yet */
      lNoOfValidConv = (Adc_StreamNumSampleType)0U;
      *PtrToSamplePtr = NULL_PTR;
    }
    else
    {
      /* Reset Group Status to BUSY for currently converting groups */
      Adc_lClrGroupResultAtomic(lKernelDataPtr,lGroupId);
      Adc_lClrResBuffEndStatusAtomic(lKernelDataPtr,lGroupId);

      /* Groups which are not converting and are implicitly stopped
         are put to IDLE state*/
      if(lBusyFlag == (uint32)0U)
      {
        lKernelDataPtr->NumofValidConRes[lGroupId] =\
                                             (Adc_StreamNumSampleType)0U;
      }
      /*End of Critcal Section*/
      SchM_Exit_Adc_KernelData();

      /* Update current valid result position */
      /* MISRA2012_RULE_18_4_JUSTIFICATION: Pointer arithmetic other than
      array indexing used for ADC application buffers. The buffer layout for 
      result handling as defined by AUTOSAR forces to use pointer arithmetic. 
      The access range is within the boundaries of the buffer.*/
      *PtrToSamplePtr = (lKernelDataPtr->GrpResBuffer[lGroupId] +\
                         lNoOfValidConv - (Adc_StreamNumSampleType)1U);

      if(lStrmCompletedFlag == (uint32)ADC_ONE_U)
      {
        lNoOfValidConv = lGrpCfgPtr->NumOfSamples;
      }
    }
  }
return(lNoOfValidConv);
}
#endif/*End For ADC_RESULT_HANDLING_IMPLEMENTATION */
#if (ADC_CALIB_STATUS_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : Std_ReturnType Adc_GetStartupCalStatus                  **
**                    (                                                       **
**                       void                                                 **
**                    )                                                       **
**                                                                            **
** Description      : This API returns the status of the start up calibration.**
** [/cover]                                                                   **
**                                                                            **
** Service ID       : 0x30                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : None                                                    **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : E_OK: Startup calibration is not ongoing                **
**                    E_NOT_OK: Startup calibration is ongoing                **
**                                                                            **
*******************************************************************************/
Std_ReturnType Adc_GetStartupCalStatus(void)
{
  uint32 lKernelCount;
  Std_ReturnType lRetVal;
  #if (ADC_DEV_ERROR_DETECT == STD_ON)
  uint8 lDetVal;
  /* Check DET's for the API */
  lDetVal = Adc_lCheckUnInitDet(ADC_SID_GET_STARTUP_CAL_STATUS);
  if(lDetVal!=ADC_E_NO_ERR)
  {
    lRetVal = E_NOT_OK;
  }
  else
  #endif
  {
    lRetVal = E_OK;
    /* Loop till the last kernel ID,
       missing or un-configured kernels will be NULL PTR in the config set*/
    for(lKernelCount=(uint32)0U; lKernelCount<ADC_MAX_KERNEL_ID; lKernelCount++)
    {
      if(Adc_kConfigPtr->HwUnitCfgPtr[lKernelCount] != NULL_PTR)
      {
        /*If calibration is active, then return E NOT OK */
        /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
        object and integer type is permitted for special function registers*/
        if(MODULE_EVADC.G[lKernelCount].ARBCFG.B.CAL == (uint32)ADC_ONE_U)
        {
          lRetVal = E_NOT_OK;
          break;
        }
      }
    }
  }
return(lRetVal);
}
#endif /* End for ADC_CALIB_STATUS_API */

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : void Adc_RS0EventInterruptHandler                       **
**                    (                                                       **
**                       uint32 KernelId                                      **
**                    )                                                       **
**                                                                            **
** Description      : This API Handles the interrupts from Request source 0   **
**                    for passed ADC KernelId.                                **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally reentrant–Reentrant for different Kernels **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID for which the Interrupt handler    **
**                    is invoked                                              **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
void Adc_RS0EventInterruptHandler(uint32 KernelId)
{
  /*Since there is no DET check in interrupts, hence validation of
    configuration pointers is done here*/
  if(Adc_kConfigPtr != NULL_PTR)
  {
    if(Adc_kConfigPtr->HwUnitCfgPtr[KernelId] != NULL_PTR)
    {
      /*Check validity of interrupt via the HW flag */
      /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
       object and integer type is permitted for special function registers*/
      if(MODULE_EVADC.G[KernelId].SEFLAG.B.SEV0 == (uint32)ADC_ONE_U)
      {
        /* Clear the RS event flag */
        /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
        object and integer type is permitted for special function registers*/
        MODULE_EVADC.G[KernelId].SEFCLR.U =\
                             ((uint32)ADC_ONE_U<<IFX_EVADC_G_SEFCLR_SEV0_OFF);
        Adc_lRSEventHandler(KernelId,(uint8)0U);
      }
    }
  }
}

#if (ADC_PRIORITY_IMPLEMENTATION != ADC_PRIORITY_NONE)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : void Adc_RS1EventInterruptHandler                       **
**                    (                                                       **
**                       uint32 KernelId                                      **
**                    )                                                       **
**                                                                            **
** Description      : This API Handles the interrupts from Request source 1   **
**                    for passed ADC KernelId.                                **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally reentrant–Reentrant for different Kernels **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID for which the Interrupt handler    **
**                    is invoked                                              **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
void Adc_RS1EventInterruptHandler(uint32 KernelId)
{
  /*Since there is no DET check in interrupts, hence validation of
  configuration pointers is done here*/
  if(Adc_kConfigPtr != NULL_PTR)
  {
    if(Adc_kConfigPtr->HwUnitCfgPtr[KernelId] != NULL_PTR)
    {
      /*Check validity of interrupt via the HW flag */
      /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
       object and integer type is permitted for special function registers*/
      if(MODULE_EVADC.G[KernelId].SEFLAG.B.SEV1 == (uint32)ADC_ONE_U)
      {
         /* Clear the RS event flag */
         /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
         object and integer type is permitted for special function registers*/
        MODULE_EVADC.G[KernelId].SEFCLR.U =\
                             ((uint32)ADC_ONE_U<<IFX_EVADC_G_SEFCLR_SEV1_OFF);
        Adc_lRSEventHandler(KernelId,(uint8)1U);
      }
    }
  }
}
#endif /* End for ADC_PRIORITY_IMPLEMENTATION*/

#if (ADC_PRIORITY_IMPLEMENTATION != ADC_PRIORITY_NONE)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : void Adc_RS2EventInterruptHandler                       **
**                    (                                                       **
**                       uint32 KernelId                                      **
**                    )                                                       **
**                                                                            **
** Description      : This API Handles the interrupts from Request source 2   **
**                    for passed ADC KernelId.                                **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally reentrant–Reentrant for different Kernels **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID for which the Interrupt handler    **
**                    is invoked                                              **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
void Adc_RS2EventInterruptHandler(uint32 KernelId)
{
  /*Since there is no DET check in interrupts, hence validation of
    configuration pointers is done here*/
  if(Adc_kConfigPtr != NULL_PTR)
  {
    if(Adc_kConfigPtr->HwUnitCfgPtr[KernelId] != NULL_PTR)
    {
      /*Check validity of interrupt via the HW flag */
      /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
       object and integer type is permitted for special function registers*/
      if(MODULE_EVADC.G[KernelId].SEFLAG.B.SEV2 == (uint32)ADC_ONE_U)
      {
        /* Clear the RS event flag */
        /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
           object and integer type is permitted for special function registers*/
        MODULE_EVADC.G[KernelId].SEFCLR.U =\
                             ((uint32)ADC_ONE_U<<IFX_EVADC_G_SEFCLR_SEV2_OFF);
        Adc_lRSEventHandler(KernelId,(uint8)2U);
      }
    }
  }
}
#endif /* End for ADC_PRIORITY_IMPLEMENTATION*/

#if (ADC_ENABLE_LIMIT_CHECK == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : void Adc_ChEventInterruptHandler                        **
**                    (                                                       **
**                       uint32 KernelId                                      **
**                    )                                                       **
**                                                                            **
** Description      : This API Handles the interrupts from ADC Channel Event  **
**                    for passed ADC KernelId.                                **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally reentrant–Reentrant for different Kernels **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID for which the Interrupt handler    **
**                    is invoked                                              **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
void Adc_ChEventInterruptHandler(uint32 KernelId)
{
  const Adc_GlobalDataType *lKernelDataPtr;
  uint32 lChannelMask,lRsCount;
  Adc_ChannelType lLimitChkCh;

  /*Since there is no DET check in interrupts, hence validation of
    configuration pointers is done here*/
  if(Adc_kConfigPtr != NULL_PTR)
  {
    if(Adc_kConfigPtr->HwUnitCfgPtr[KernelId] != NULL_PTR)
    {
      lKernelDataPtr = Adc_lGetKernelDataAddress(KernelId);
      for(lRsCount=(uint32)0U; lRsCount<ADC_REQSRC_COUNT; lRsCount++)
      {
        lLimitChkCh = lKernelDataPtr->RSData[lRsCount].ActiveLimitChkCh;
        if(lLimitChkCh < (Adc_ChannelType)ADC_SECONDARY_CONV_CHANNEL_COUNT)
        {
          lChannelMask = ((uint32)ADC_ONE_U<<lLimitChkCh);
          /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
             object and integer type is permitted for special function
             registers*/
          if((MODULE_EVADC.G[KernelId].CEFLAG.U & lChannelMask) == \
                                                                lChannelMask)
          {
            /* Clear the channel event */
            /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
               object and integer type is permitted for special function
               registers*/
            MODULE_EVADC.G[KernelId].CEFCLR.U = lChannelMask;
            Adc_lLimitChkEventHandler(KernelId,\
                  lKernelDataPtr->RSData[lRsCount].ActiveGroupId);
          }
        }
      }
    }
  }
}
#endif /*End for ADC_ENABLE_LIMIT_CHECK*/
/*******************************************************************************
**                      Private Function Definitions                          **
*******************************************************************************/
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint32 Adc_lGetAdcKernel                   **
**                    (                                                       **
**                       const Adc_GroupType GroupId                          **
**                    )                                                       **
**                                                                            **
** Description      : This function derives the Adc kernel number from the    **
**                    Adc channel group number.                               **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Kernel Number                                           **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint32 Adc_lGetAdcKernel(const Adc_GroupType GroupId)
{
  return((uint32)(Mcal_GetBitAtomic((uint32)GroupId,\
                                    ADC_KERNEL_ID_START_POS,\
                                    ADC_KERNEL_ID_NO_OF_BITS)));
}
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE Adc_GroupType Adc_lGetKernelGroupId        **
**                    (                                                       **
**                      const  Adc_GroupType GroupId                          **
**                    )                                                       **
**                                                                            **
** Description      : This function derives the Group Number from the         **
**                    Adc channel group ID.                                   **
** [/cover]                                                                   **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Group Number                                            **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE Adc_GroupType  Adc_lGetKernelGroupId(const Adc_GroupType GroupId)
{
  return((Adc_GroupType)(GroupId & (Adc_GroupType)ADC_GROUP_ID_MASK));
}
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           :LOCAL_INLINE Adc_GlobalDataType*Adc_lGetKernelDataAddress**
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                    )                                                       **
**                                                                            **
** Description      : This function returns the address of the element of the **
**                    array - Adc_KernelData, where kernel specific run-time  **
**                    data stored.                                            **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : address of the element of the Adc_KernelData            **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE Adc_GlobalDataType* Adc_lGetKernelDataAddress(\
                                                   const uint32 KernelId)
{
  return(&Adc_KernelData[Adc_kKernelDataIndex[KernelId]]);
}

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lSetGroupStatusBusyAtomic         **
**                    (                                                       **
**                       Adc_GlobalDataType *KernelDataPtr                    **
**                       Adc_GroupType GroupId                                **
**                    )                                                       **
** [/cover]                                                                   **
**                                                                            **
** Description      : This function sets the Group Status to ADC_BUSY         **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelDataPtr - Pointer to Adc_KernelData array element **
**                    GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lSetGroupStatusBusyAtomic(\
   Adc_GlobalDataType *KernelDataPtr,Adc_GroupType GroupId)
{
  Mcal_SetBitAtomic(&(KernelDataPtr->GrpStatus),(uint8)GroupId,\
                      1,1U);
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
     instruction, hence they are not unused.*/
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
     instruction, hence they are not unused.*/
  /* MISRA2012_RULE_8_13_JUSTIFICATION: Parameter are updated via assembly 
     instruction, hence cannot be passed as const.*/
}

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lSetGroupResultAtomic             **
**                    (                                                       **
**                       Adc_GlobalDataType *KernelDataPtr                    **
**                       Adc_GroupType GroupId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function changes the group conversion result status**
**                    to ‘results-available’.                                 **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelDataPtr - Pointer to Adc_KernelData array element **
**                    GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lSetGroupResultAtomic(\
   Adc_GlobalDataType *KernelDataPtr,Adc_GroupType GroupId)
{
  Mcal_SetBitAtomic(&(KernelDataPtr->GrpResultStatus),(uint8)GroupId,\
                      1,1U);
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
     instruction, hence they are not unused.*/
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
     instruction, hence they are not unused.*/
  /* MISRA2012_RULE_8_13_JUSTIFICATION:Parameter are updated via assembly 
     instruction, hence cannot be passed as const.*/
}
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lSetResBuffEndStatusAtomic        **
**                    (                                                       **
**                       Adc_GlobalDataType *KernelDataPtr                    **
**                       Adc_GroupType GroupId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function changes the group conversion result       **
**                    status to ‘buffer full’ (stream completed)              **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelDataPtr - Pointer to Adc_KernelData array element **
**                    GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lSetResBuffEndStatusAtomic(\
   Adc_GlobalDataType *KernelDataPtr,Adc_GroupType GroupId)
{
  Mcal_SetBitAtomic(&(KernelDataPtr->GrpBufferEndResultStatus),(uint8)GroupId,\
                      1,1U);
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
     instruction, hence they are not unused.*/
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
   instruction, hence they are not unused.*/
  /* MISRA2012_RULE_8_13_JUSTIFICATION:Parameter are updated via assembly
   instruction, hence cannot be passed as const.*/
}
#if (ADC_GRP_NOTIF_CAPABILITY == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lSetGrpNotifAtomic                **
**                    (                                                       **
**                       Adc_GlobalDataType *KernelDataPtr                    **
**                       Adc_GroupType GroupId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function enables the group notification for        **
**                    the passed group                                        **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelDataPtr - Pointer to Adc_KernelData array element **
**                    GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lSetGrpNotifAtomic(\
   Adc_GlobalDataType *KernelDataPtr,Adc_GroupType GroupId)
{
  Mcal_SetBitAtomic(&(KernelDataPtr->GrpNotifStatus),(uint8)GroupId,\
                      1,1U);
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
   instruction, hence they are not unused.*/
  /* MISRA2012_RULE_8_13_JUSTIFICATION:Parameter are updated via assembly
   instruction, hence cannot be passed as const.*/
}
#endif /* End for ADC_GRP_NOTIF_CAPABILITY*/
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lClrGroupStatusBusyAtomic         **
**                    (                                                       **
**                       Adc_GlobalDataType *KernelDataPtr                    **
**                       Adc_GroupType GroupId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function clears the Group Status flag to indicate  **
**                    ADC_IDLE state.                                         **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelDataPtr - Pointer to Adc_KernelData array element **
**                    GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lClrGroupStatusBusyAtomic(\
   Adc_GlobalDataType *KernelDataPtr,Adc_GroupType GroupId)
{
  Mcal_SetBitAtomic(&(KernelDataPtr->GrpStatus),(uint8)GroupId,\
                      1,0U);
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
   instruction, hence they are not unused.*/
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
   instruction, hence they are not unused.*/
  /* MISRA2012_RULE_8_13_JUSTIFICATION: Parameter are updated via assembly
   instruction, hence cannot be passed as const.*/
}
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lClrGroupResultAtomic             **
**                    (                                                       **
**                       Adc_GlobalDataType *KernelDataPtr                    **
**                       Adc_GroupType GroupId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function changes the group conversion result status**
**                    to un-available                                         **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelDataPtr - Pointer to Adc_KernelData array element **
**                    GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lClrGroupResultAtomic(\
   Adc_GlobalDataType *KernelDataPtr,Adc_GroupType GroupId)
{
  Mcal_SetBitAtomic(&(KernelDataPtr->GrpResultStatus),(uint8)GroupId,\
                      1,0U);
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
   instruction, hence they are not unused. */
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
   instruction, hence they are not unused.*/
  /* MISRA2012_RULE_8_13_JUSTIFICATION:Parameter are updated via assembly 
   instruction, hence cannot be passed as const. */
}

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lClrResBuffEndStatusAtomic        **
**                    (                                                       **
**                       Adc_GlobalDataType *KernelDataPtr                    **
**                       Adc_GroupType GroupId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function changes the group conversion result buffer**
**                    status to buffer not full.                              **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelDataPtr - Pointer to Adc_KernelData array element **
**                    GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lClrResBuffEndStatusAtomic(\
   Adc_GlobalDataType *KernelDataPtr,Adc_GroupType GroupId)
{
  Mcal_SetBitAtomic(&(KernelDataPtr->GrpBufferEndResultStatus),(uint8)GroupId,\
                      1,0U);
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
     instruction, hence they are not unused.*/
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
     instruction, hence they are not unused.*/
  /* MISRA2012_RULE_8_13_JUSTIFICATION:Parameter are updated via assembly 
     instruction, hence cannot be passed as const.*/
}

#if (ADC_GRP_NOTIF_CAPABILITY == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lClrGrpNotifAtomic                **
**                    (                                                       **
**                       Adc_GlobalDataType *KernelDataPtr                    **
**                       Adc_GroupType GroupId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function disables the group notification for the   **
**                    passed group.                                           **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelDataPtr - Pointer to Adc_KernelData array element **
**                    GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lClrGrpNotifAtomic(\
   Adc_GlobalDataType *KernelDataPtr,Adc_GroupType GroupId)
{
  Mcal_SetBitAtomic(&(KernelDataPtr->GrpNotifStatus),(uint8)GroupId,\
                      1,0U);
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
   instruction, hence they are not unused.*/
  /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter are updated via assembly
   instruction, hence they are not unused.*/
  /* MISRA2012_RULE_8_13_JUSTIFICATION: Parameter are updated via assembly 
   instruction, hence cannot be passed as const.*/
}
#endif /* End for ADC_GRP_NOTIF_CAPABILITY*/

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint32  Adc_lGetGroupStatus                **
**                    (                                                       **
**                       const Adc_GlobalDataType *KernelDataPtr              **
**                       Adc_GroupType GroupId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function returns the Adc group status              **
**                    ADC_IDLE/ADC_BUSY.                                      **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelDataPtr - Pointer to Adc_KernelData array element **
**                    GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : 0U:ADC_IDLE                                             **
**                    1U:ADC_BUSY                                             **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint32 Adc_lGetGroupStatus(\
              const Adc_GlobalDataType *KernelDataPtr,  Adc_GroupType GroupId)
{
  return((uint32)(Mcal_GetBitAtomic((uint32)KernelDataPtr->GrpStatus,\
                      GroupId,1U)));
}

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint32  Adc_lGetGroupResultStatus          **
**                    (                                                       **
**                       const Adc_GlobalDataType *KernelDataPtr              **
**                       Adc_GroupType GroupId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function returns whether results are available for **
**                     the Group ID                                           **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelDataPtr - Pointer to Adc_KernelData array element **
**                    GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : 0U:Adc results are not available                        **
**                    1U:Atleast one streaming sample is completed            **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint32 Adc_lGetGroupResultStatus(\
               const Adc_GlobalDataType *KernelDataPtr,Adc_GroupType GroupId)
{
  return((uint32)(Mcal_GetBitAtomic((uint32)KernelDataPtr->GrpResultStatus,\
                      GroupId,1U)));
}
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint32  Adc_lGetResBuffEndStatus           **
**                    (                                                       **
**                       const Adc_GlobalDataType *KernelDataPtr              **
**                       Adc_GroupType GroupId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function retursn the Result buffer end status      **
**                   (ADC_STREAM_COMPLETED)                                   **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelDataPtr - Pointer to Adc_KernelData array element **
**                    GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : 0U:Adc result buffer is not full                        **
**                    1U:Adc result buffer is full                            **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint32 Adc_lGetResBuffEndStatus(\
              const Adc_GlobalDataType *KernelDataPtr,Adc_GroupType GroupId)
{
  return((uint32)(Mcal_GetBitAtomic(\
                    (uint32)KernelDataPtr->GrpBufferEndResultStatus,\
                    GroupId,1U)));
}

#if (ADC_GRP_NOTIF_CAPABILITY == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint32  Adc_lGetGroupNotifStatus           **
**                    (                                                       **
**                       const Adc_GlobalDataType *KernelDataPtr              **
**                       Adc_GroupType GroupId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function returns the notification enabled status   **
**                   for the Group ID                                         **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelDataPtr - Pointer to Adc_KernelData array element **
**                    GroupId - Adc Channel Group number                      **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : 0U:Adc Groups notification is disabled                  **
**                    1U:Adc Groups notification is enabled                   **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint32 Adc_lGetGroupNotifStatus(\
          const Adc_GlobalDataType *KernelDataPtr, Adc_GroupType GroupId)
{
  return((uint32)(Mcal_GetBitAtomic((uint32)KernelDataPtr->GrpNotifStatus,\
                      GroupId,1U)));
}
#endif /* End for ADC_GRP_NOTIF_CAPABILITY*/

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint32  Adc_lGetAllGroupStatus             **
**                    (                                                       **
**                      void                                                  **
**                    )                                                       **
**                                                                            **
** Description      : This function checks the BUSY / IDLE status of all the  **
**                    groups across all the kernels                           **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : None                                                    **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : 0U:All groups are in ADC_IDLE state                     **
**                    1U:Atleast one group is in ADC_BUSY state               **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint32 Adc_lGetAllGroupStatus(void)
{
  const Adc_GlobalDataType *lKernelDataPtr;
  uint32 lKernelCount,lRetVal;
  lRetVal = (uint32)0U;
  /* Loop till the last kernel ID,
     missing or un-configured kernels will be NULL PTR in the config set*/
  for(lKernelCount=(uint32)0U; lKernelCount<ADC_MAX_KERNEL_ID; lKernelCount++)
  {
    if(Adc_kConfigPtr->HwUnitCfgPtr[lKernelCount] != NULL_PTR)
    {
      lKernelDataPtr = Adc_lGetKernelDataAddress(lKernelCount);
      /*Check if any group is busy, then return a busy state */
      if( (lKernelDataPtr->GrpStatus) != (uint32)0U )
      {
        lRetVal = (uint32)ADC_ONE_U;
        break;
      }
    }
  }
  return(lRetVal);
}

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lInit                             **
**                    (                                                       **
**                       void                                                 **
**                    )                                                       **
**                                                                            **
** Description      : This function resets the global and kernel specific SFRs**
**                    to reset values and then initializes them as per        **
**                    configuration.                                          **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Non - Reentrant                                         **
**                                                                            **
** Parameters(in)   : None                                                    **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lInit(void)
{
  uint32 lKernelCount;
  /***** Start of DEINIT Process *****/
  /* Loop till the last kernel ID,
     missing or un-configured kernels will be NULL PTR in the config set*/
  for(lKernelCount=(uint32)0U; lKernelCount<ADC_MAX_KERNEL_ID; lKernelCount++)
  {
    if(Adc_kConfigPtr->HwUnitCfgPtr[lKernelCount] != NULL_PTR)
    {
      Adc_lKernelDeInit(Adc_kConfigPtr->HwUnitCfgPtr[lKernelCount],\
                                                        lKernelCount);
    }
  }
  Adc_lResetGlobalSfr();
  /***** End of DEINIT Process *****/
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
  /***** Start of INIT Process *****/
  MODULE_EVADC.GLOBCFG.U = ( (Adc_kConfigPtr->GlobalCfgPtr->GlobalCfg)|\
                             (uint32)ADC_GLOBCFG_WRITE_PROTECT_MSK);
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
  MODULE_EVADC.GLOB.ICLASS[0U].U = \
                           Adc_kConfigPtr->GlobalCfgPtr->GlobInputClass0Cfg;
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
  MODULE_EVADC.GLOB.ICLASS[1U].U = \
                           Adc_kConfigPtr->GlobalCfgPtr->GlobInputClass1Cfg;

  /* Loop till the last kernel ID,
     missing or un-configured kernels will be NULL PTR in the config set*/
  for(lKernelCount=(uint32)0U; lKernelCount<ADC_MAX_KERNEL_ID; lKernelCount++)
  {
    if(Adc_kConfigPtr->HwUnitCfgPtr[lKernelCount] != NULL_PTR)
    {
      Adc_lKernelInit(Adc_kConfigPtr->HwUnitCfgPtr[lKernelCount],\
                                                        lKernelCount);
      /* Converter is put to always ON mode via the ANONS bit,
         after all registers are configured */
      /* Converters need to be switched ON here,
         because startup calibration requires all converters to be ON */
      /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
        object and integer type is permitted for special function registers*/
      MODULE_EVADC.G[lKernelCount].ARBCFG.B.ANONC = ADC_CONVERTER_ON;
      /* Ensure register is written and converter is switched ON */
      DSYNC();
    }
  }
  /* Trigger Start Up calibration */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/ 
  MODULE_EVADC.GLOBCFG.U |= ((uint32)ADC_ONE_U<<\
                                    IFX_EVADC_GLOBCFG_SUCAL_OFF);
  Adc_lResetGlobalVars();
  /***** End of INIT Process *****/
}

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lResetGlobalSfr                   **
**                    (                                                       **
**                       void                                                 **
**                    )                                                       **
**                                                                            **
** Description      : This function resets the global SFRs of EVADC           **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Non - Reentrant                                         **
**                                                                            **
** Parameters(in)   : None                                                    **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lResetGlobalSfr(void)
{
  Ifx_EVADC_GLOB *lEvadcGlobalSfr;
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/ 
  lEvadcGlobalSfr = &(MODULE_EVADC.GLOB);
  /* Reset Global SFRs to default values */
  lEvadcGlobalSfr->ICLASS[0U].U = (uint32)0U;
  lEvadcGlobalSfr->ICLASS[1U].U = (uint32)0U;
  lEvadcGlobalSfr->BOUND.U      = (uint32)0U;
  lEvadcGlobalSfr->RCR.U        = (uint32)0U;
  lEvadcGlobalSfr->RES.U        = ((uint32)ADC_ONE_U<<\
                                   IFX_EVADC_GLOB_RESD_VF_OFF);
  lEvadcGlobalSfr->EFLAG.U      = ((uint32)ADC_ONE_U<<\
                                  IFX_EVADC_GLOB_EFLAG_REVGLBCLR_OFF);
  lEvadcGlobalSfr->EVNP.U       = (uint32)0U;
  lEvadcGlobalSfr->TE.U         = (uint32)0U;
  lEvadcGlobalSfr->TF.U         = ADC_GLOBTF_WRITE_PROTECT_MSK;
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
  MODULE_EVADC.EMUXSEL.U        = (uint32)0U;
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/ 
  MODULE_EVADC.GLOBCFG.U        = (uint32)ADC_GLOBCFG_WRITE_PROTECT_MSK;

}
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : static void Adc_lResetGlobalVars                        **
**                    (                                                       **
**                       void                                                 **
**                    )                                                       **
**                                                                            **
** Description      : This function resets the global variables of ADC driver **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Non - Reentrant                                         **
**                                                                            **
** Parameters(in)   : None                                                    **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
static void Adc_lResetGlobalVars(void)
{
  Adc_GlobalDataType *lKernelDataPtr;
  uint8 lLoopCount,lRsCount;
  /* Loop for all the indices of the array Adc_KernelData */

  for(lLoopCount=(uint8)0U; lLoopCount<ADC_KERNEL_USED_COUNT; lLoopCount++)
  {
    lKernelDataPtr = &Adc_KernelData[lLoopCount];

    #if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
    /* When ADC_RESULT_HANDLING_IMPLEMENTATION is ADC_DMA_MODE_RESULT_HANDLING,
       then ADC_ENABLE_QUEUING will always be STD_OFF.
       Hence, this loop is not required when ADC_RESULT_HANDLING_IMPLEMENTATION
       is ADC_DMA_MODE_RESULT_HANDLING  */
    uint8 lGroupCount;
    for(lGroupCount=(uint8)0U; lGroupCount<ADC_MAX_GROUPS; lGroupCount++)
    {
      #if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
      lKernelDataPtr->GrpResBuffer[lGroupCount] =(Adc_ValueGroupType *)0U;
      lKernelDataPtr->NumofValidConRes[lGroupCount] = \
                                               (Adc_StreamNumSampleType)0U;
      #endif /* End for ADC_RESULT_HANDLING_IMPLEMENTATION */

      #if(ADC_ENABLE_QUEUING == STD_ON)
      /* Intialize queue elements with invalid group ID */
      lKernelDataPtr->QueueOfSwGroup[lGroupCount].PreviousGroup=\
                                                ADC_INVALID_GROUP_ID;
      lKernelDataPtr->QueueOfSwGroup[lGroupCount].NextGroup=\
                                                ADC_INVALID_GROUP_ID;
      #endif/* End for ADC_ENABLE_QUEUING */
    }
    #endif /* End for ADC_RESULT_HANDLING_IMPLEMENTATION */

    for(lRsCount=(uint8)0U; lRsCount<ADC_REQSRC_COUNT; lRsCount++)
    {
      lKernelDataPtr->RSData[lRsCount].ActiveGroupId = ADC_INVALID_GROUP_ID;
      lKernelDataPtr->RSData[lRsCount].ActiveLimitChkCh = \
                                                      ADC_INVALID_CHANNEL_ID;
      lKernelDataPtr->RSData[lRsCount].IsrNoServiceFlag = (uint8)ADC_ONE_U;
    }

    #if(ADC_ENABLE_QUEUING == STD_ON)
    /* Intialize queue elements with invalid group ID */
    lKernelDataPtr->PopGroupId = ADC_INVALID_GROUP_ID;
    lKernelDataPtr->PushGroupId = ADC_INVALID_GROUP_ID;
    #endif

    lKernelDataPtr->GrpStatus = (uint32)0U;
    lKernelDataPtr->GrpResultStatus = (uint32)0U;
    lKernelDataPtr->GrpBufferEndResultStatus = (uint32)0U;
    lKernelDataPtr->GrpNotifStatus = (uint32)0U;
    lKernelDataPtr->AllRunningChannels = (uint16)0U;
    lKernelDataPtr->AllRunningResReg = (uint16)0U;
  }

}
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lKernelInit                       **
**                    (                                                       **
**                       const Adc_HwUnitCfgType *KernelCfgPtr                **
                         const uint32 KernelId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function programs the kernels Analog Function,     **
**                    Input Class and Arbiter specific SFRs.                  **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Non - Reentrant                                         **
**                                                                            **
** Parameters(in)   : KernelCfgPtr - Pointer to the Kernel Config Data        **
**                    KernelId  - Kernel ID                                   **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lKernelInit(const Adc_HwUnitCfgType *KernelCfgPtr,\
                                  const uint32 KernelId)
{
  Ifx_EVADC_G *lEvadcGroupPtr;
  const Adc_HwCfgType *lHwCfgPtr;

  /* Get the HW configuration address*/
  lHwCfgPtr = KernelCfgPtr->HwCfgPtr;
  /* Get the SFR base address for the kernel */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
  lEvadcGroupPtr = &MODULE_EVADC.G[KernelId];

  /*Initialize kernel SFRs from the configuration */
  lEvadcGroupPtr->ANCFG.U      = lHwCfgPtr->GrpAnalogFuncCfg;
  lEvadcGroupPtr->ARBPR.U      = lHwCfgPtr->GrpArbitPrioCfg;
  lEvadcGroupPtr->ICLASS[0U].U = lHwCfgPtr->KernelInputClass0Cfg;
  lEvadcGroupPtr->ICLASS[1U].U = lHwCfgPtr->KernelInputClass1Cfg;
  lEvadcGroupPtr->SYNCTR.U     = lHwCfgPtr->GrpSyncCtrlCfg;

  /* RSx event is mapped to SRx, x = 0..2*/
  lEvadcGroupPtr->SEVNP.U      = ADC_SEVNP_INIT_CFG_VALUE;

  #if (ADC_ENABLE_LIMIT_CHECK == STD_ON)
  /* Set channel event node pointer to SR3 for all channels
     Channel event will be triggered only when CHCTR.CHEVMODE is enabled
     for Limit checking groups*/
  lEvadcGroupPtr->CEVNP0.U = ADC_CEVNP_INIT_CFG_VALUE;
  if(KernelId > ADC_LAST_PRIMARY_KERNELID)
  {
    lEvadcGroupPtr->CEVNP1.U = ADC_CEVNP_INIT_CFG_VALUE;
  }
  #endif
  #if(ADC_RESULT_HANDLING_IMPLEMENTATION == ADC_DMA_MODE_RESULT_HANDLING)
  lEvadcGroupPtr->REVNP0.U      = ADC_REVNP_INIT_CFG_VALUE;
  lEvadcGroupPtr->REVNP1.U      = ADC_REVNP_INIT_CFG_VALUE;
  #endif
  /* Converter is NOT SWITCHED ON here */
  lEvadcGroupPtr->ARBCFG.U     = lHwCfgPtr->GrpArbitCfg;
}
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : static void Adc_lKernelDeInit                           **
**                    (                                                       **
**                       const Adc_HwUnitCfgType *KernelCfgPtr                **
**                       const uint32 KernelId                                **
**                    )                                                       **
**                                                                            **
** Description      : This function resets the global SFRs of EVADC           **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Non - Reentrant                                         **
**                                                                            **
** Parameters(in)   : KernelCfgPtr - Pointer to the Kernel Config Data        **
**                    KernelId  - Kernel ID                                   **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
static void Adc_lKernelDeInit(const Adc_HwUnitCfgType *KernelCfgPtr,\
                              const uint32 KernelId)
{
  Ifx_EVADC_G *lEvadcGroupPtr;
  uint8 lLoopCount,lChannelCount;
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/

  lEvadcGroupPtr = &MODULE_EVADC.G[KernelId];

  #if (ADC_HW_TRIGGER_API == STD_ON)
  const Adc_GroupCfgType *lGrpCfgPtr;
  uint8 lGroupCount;

  lGrpCfgPtr = KernelCfgPtr->GrpCfgPtr;
  lGroupCount = KernelCfgPtr->NoOfGroups;

  /* Loop for all the HW triggered groups, and reset the HW trigger peripheral*/
  for(lLoopCount=(uint8)0U; lLoopCount<lGroupCount; lLoopCount++)
  {
    if((lGrpCfgPtr[lLoopCount].TriggerSource) == ADC_TRIGG_SRC_HW)
    {
      Adc_lResetHwTrigger(&lGrpCfgPtr[lLoopCount]);
    }
  }
  #endif /* End for ADC_HW_TRIGGER_API */

  for(lLoopCount=(uint8)0U; \
         lLoopCount < (ADC_REQSRC_COUNT-(uint8)1U); lLoopCount++)
  {
    /* Flush the Queue */
    lEvadcGroupPtr->Q[lLoopCount].QMR.U =(\
                              ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_FLUSH_OFF)|\
                              ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_CEV_OFF)|\
                              ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_CLRV_OFF));
    lEvadcGroupPtr->Q[lLoopCount].QCTRL.U = ADC_Q_CTRL_WRITE_PROTECT_MSK;
    lEvadcGroupPtr->Q[lLoopCount].REQTM.U = ADC_REQTM_RESET_VALUE;
  }

  /* Flush the Queue Q2 */
  lEvadcGroupPtr->Q2.QMR.U =(\
                            ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_FLUSH_OFF)|\
                            ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_CEV_OFF)|\
                            ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_CLRV_OFF));
  lEvadcGroupPtr->Q2.QCTRL.U = ADC_Q_CTRL_WRITE_PROTECT_MSK;
  lEvadcGroupPtr->Q2.REQTM.U = ADC_REQTM_RESET_VALUE;

  /* Clear Kernel registers and Switch off the converter also */
  lEvadcGroupPtr->ARBCFG.U = (uint32)0U;
  /* Ensure register is written and converter is switched OFF */
  DSYNC();
  lEvadcGroupPtr->Q2.TRCTR.U = ((uint32)ADC_ONE_U<<\
                                             IFX_EVADC_G_Q_TRCTR_COV_OFF);

  lEvadcGroupPtr->ARBPR.U        = (uint32)0U;
  lEvadcGroupPtr->ANCFG.U        = ADC_ANCFG_DEFAULT_VALUE;
  lEvadcGroupPtr->ICLASS[0U].U   = (uint32)0U;
  lEvadcGroupPtr->ICLASS[1U].U   = (uint32)0U;
  lEvadcGroupPtr->ALIAS.U        = ADC_ALIAS_DEFAULT_VALUE;
  lEvadcGroupPtr->BOUND.U        = (uint32)0U;
  lEvadcGroupPtr->SYNCTR.U       = (uint32)0U;
  lEvadcGroupPtr->EMUXCTR.U      = (uint32)ADC_ONE_U<<\
                                       IFX_EVADC_G_EMUXCTR_EMXWC_OFF;
  lEvadcGroupPtr->EMUXCS.U       = (uint32)0U;

  if(KernelId > ADC_LAST_PRIMARY_KERNELID)
  {
    lChannelCount = (uint8)ADC_SECONDARY_CONV_CHANNEL_COUNT;
  }
  else
  {
    lChannelCount = (uint8)ADC_PRIMARY_CONV_CHANNEL_COUNT;
  }
  for(lLoopCount=(uint8)0U; lLoopCount<lChannelCount;lLoopCount++)
  {
    /*Clear Channel control registers,
      - 8 channels for primary converter
      - 16 channels for primary converter */
    lEvadcGroupPtr->CHCTR[lLoopCount].U = (uint32)0U;
  }
  for(lLoopCount=(uint8)0U; \
              lLoopCount<(uint8)ADC_MAX_RESULT_REGISTERS;lLoopCount++)
  {
    /* Clear all 16 result control registers */
    lEvadcGroupPtr->RCR[lLoopCount].U = (uint32)0U;
  }

  /* Clear Source events, result event ,channel event flags and
     service node pointers*/
  lEvadcGroupPtr->VFR.U      = ADC_CLR_VALID_FLAG_REG;
  lEvadcGroupPtr->SEFCLR.U   = ADC_CLR_SOURCE_EVENT;
  lEvadcGroupPtr->REFCLR.U   = ADC_CLR_RESULT_EVENT;
  lEvadcGroupPtr->SEVNP.U    = (uint32)0U;
  lEvadcGroupPtr->REVNP0.U   = (uint32)0U;
  lEvadcGroupPtr->REVNP1.U   = (uint32)0U;
  lEvadcGroupPtr->CEVNP0.U   = (uint32)0U;

  if(KernelId>ADC_LAST_PRIMARY_KERNELID)
  {
    /* Since channel count for secondary converters is 16,
       hence Channel event register and CEVNP1 are cleared here*/
    lEvadcGroupPtr->CEFCLR.U = ADC_CLR_SECONDARY_CH_EVENT;
    lEvadcGroupPtr->CEVNP1.U = (uint32)0U;
  }
  else
  {
    /* Channel count for primary converters is 8 */
    lEvadcGroupPtr->CEFCLR.U = ADC_CLR_PRIMARY_CH_EVENT;
  }
}

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : static void Adc_lPrepareGrpForStart                     **
**                    (                                                       **
**                      const uint32 KernelId,                                **
**                      const Adc_GroupType  GroupId                          **
**                    )                                                       **
**                                                                            **
** Description      : This function prepares (configures) all the analog      **
**                   channels and result registers of the group for conversion**
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant(Re-entrant for different Kernel)**
**                                                                            **
** Parameters(in)   : KernelId  - ADC Kernel to which the group belongs       **
**                    GroupId   - ADC Group ID of the Kernel                  **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
static void Adc_lPrepareGrpForStart(const uint32 KernelId,\
                                    const Adc_GroupType GroupId)
{
  Ifx_EVADC_G *lEvadcGroupPtr;
  const Adc_GroupCfgType *lGrpCfgPtr;
  const Adc_ChannelCfgType *lChCfgPtr;
  const Adc_GroupDefType *lGrpDefCfgPtr;
  uint32 lWfrCfgVal,lResRegFifoInput,lChctrVal;
  Adc_ChannelType lAsChannelId,lAnChannelId;
  Adc_ResultRegType lResReg;
  uint8 lNoOfChannels,lChloopCount;
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
  /*Get the SFR base address for the kernel */
  lEvadcGroupPtr = &MODULE_EVADC.G[KernelId];
  /*Get the base address of the group configuration */
  lGrpCfgPtr = &(Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->GrpCfgPtr[GroupId]);
  /*Get the base address of the channel configuration */
  lChCfgPtr = Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->ChCfgPtr;
  /* Get the base address of the group definition */
  lGrpDefCfgPtr = lGrpCfgPtr->GroupDefinition;

  #if(ADC_RESULT_HANDLING_IMPLEMENTATION == ADC_DMA_MODE_RESULT_HANDLING)
  uint32 lResultEvent;
  lResultEvent = (uint32)ADC_ONE_U<<IFX_EVADC_RCR_SRGEN_OFF;
  #endif

  #if (ADC_ENABLE_LIMIT_CHECK == STD_ON)
  if(lGrpCfgPtr->LimitCheckGroup == (uint8)ADC_ONE_U)
  {
    /* For Limit checking group do not enable wait for read mode */
    lWfrCfgVal = (uint32)0U;
  }
  else
  #endif
  {
    lWfrCfgVal = (uint32)ADC_ONE_U<<IFX_EVADC_RCR_WFR_OFF;
  }

  lNoOfChannels = lGrpCfgPtr->NoOfChannels;
  /* Get the result register that is the FIFO INPUT stage
    - from the last channel*/
  lResRegFifoInput = \
  (uint32)((uint32)(lGrpDefCfgPtr[lNoOfChannels - (uint8)1U].ResultReg)<<\
                                           IFX_EVADC_CHCTR_RESREG_OFF);

  /*Configure Alias configuration */
  lEvadcGroupPtr->ALIAS.U = lGrpCfgPtr->AliasChCfg;

  lChloopCount = (uint8)0U;
  do
  {
    /*Get the AS channel ID, this is used to get the CHCTR config value*/
    lAsChannelId = lGrpDefCfgPtr[lChloopCount].ASChannelId;
    /* Get the analog channel number */
    lAnChannelId = lGrpDefCfgPtr[lChloopCount].AnalogChannelNo;
    lResReg = lGrpDefCfgPtr[lChloopCount].ResultReg;

    /*Clear only Used bits of CHCTR, BWD related bits are not written*/
    lChctrVal = (uint32)((lEvadcGroupPtr->CHCTR[lAnChannelId].U) &\
                                                   ADC_CLR_CHCTR_EXCEPT_BWD);
    lChctrVal |= (lChCfgPtr[lAsChannelId].ChannelChctrCfg | lResRegFifoInput);
    /* Write the CHCTR value back to SFR */
    lEvadcGroupPtr->CHCTR[lAnChannelId].U = lChctrVal;

    /*Result registers work in FIFO mode always,
      result enter via the FIFO INPUT (highest index result register) and
      read from FIFO OUTPUT (lowest index result register)*/
    /* Enable FEN for all channels except the last result register(FIFO INPUT),
       RCR for last channel will be written again after the while loop */
    #if(ADC_RESULT_HANDLING_IMPLEMENTATION == ADC_DMA_MODE_RESULT_HANDLING)
    lEvadcGroupPtr->RCR[lResReg].U = lResultEvent|\
                         ((uint32)ADC_ONE_U<<IFX_EVADC_RCR_FEN_OFF);
    lResultEvent = (uint32)0U;
    #else
    lEvadcGroupPtr->RCR[lResReg].U = \
                         ((uint32)ADC_ONE_U<<IFX_EVADC_RCR_FEN_OFF);
    #endif
    lChloopCount++;
  }while(lChloopCount<lNoOfChannels);

  #if(ADC_RESULT_HANDLING_IMPLEMENTATION == ADC_DMA_MODE_RESULT_HANDLING)
  /* Enable wait for read mode for FIFO INPUT (last result register) 
     and keep SRGEN bit of it unchanged*/
     lResultEvent = (uint32)ADC_ONE_U<<IFX_EVADC_RCR_SRGEN_OFF;
     lEvadcGroupPtr->RCR[lResReg].U = (lEvadcGroupPtr->RCR[lResReg].U&\
                                      lResultEvent)|lWfrCfgVal;
  #else
  /* Enable wait for read mode for FIFO INPUT (last result register) */
  lEvadcGroupPtr->RCR[lResReg].U = lWfrCfgVal;
  #endif


  #if (ADC_ENABLE_LIMIT_CHECK == STD_ON)
  if((uint8)ADC_ONE_U == lGrpCfgPtr->LimitCheckGroup)
  {
    /* Set limit check boundary values and channel event node pointer */
    lEvadcGroupPtr->BOUND.U = lChCfgPtr[lAsChannelId].BoundaryValues;
  }
  #endif
}
#if (ADC_ENABLE_START_STOP_GROUP_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : static void Adc_lStartSwConversion                      **
**                    (                                                       **
**                      const Adc_GroupCfgType *GrpPtr,                       **
**                      const uint32 KernelId                                 **
**                    )                                                       **
**                                                                            **
** Description      : This function programs the Request Source Queue and     **
**                    triggers the start of conversion.                       **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant(Re-entrant for different Kernel)**
**                                                                            **
** Parameters(in)   : GrpPtr  - Pointer to the Group configuration data       **
**                    KernelId  - ADC Group ID of the Kernel                  **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
static void Adc_lStartSwConversion(const Adc_GroupCfgType *GrpPtr,\
                                   const uint32 KernelId)
{
  Ifx_EVADC_G *lEvadcGroupPtr;
  Ifx_EVADC_G_Q *lEvadcQPtr;
  const Adc_GroupDefType *lGrpDefCfgPtr;
  uint32 lConvMode,lRsIntpt;
  uint8 lNoOfChannels,lChloopCount;

  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
  /* Get base address of the kernel SFR */
  lEvadcGroupPtr = &MODULE_EVADC.G[KernelId];
  /* Get base address of the RS SFR */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
  lEvadcQPtr = &MODULE_EVADC.G[KernelId].Q[GrpPtr->GrpReqSrc];

  /* Flush the RS queue, clear valid flags, before channels are queued up
     for conversion */
  lEvadcQPtr->QMR.U =(((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_FLUSH_OFF)|\
                      ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_CEV_OFF)|\
                      ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_CLRV_OFF));

  /* Clear RS event, Channel event and result event flags */
  lEvadcGroupPtr->SEFCLR.U = ((uint32)ADC_ONE_U<<(GrpPtr->GrpReqSrc));
  lEvadcGroupPtr->CEFCLR.U = (uint32)GrpPtr->ChannelMask;
  lEvadcGroupPtr->REFCLR.U = (uint32)GrpPtr->ResultRegMask;
  /* Clear valid flag for all result registers */
  lEvadcGroupPtr->VFR.U = (uint32)GrpPtr->ResultRegMask;

  if(GrpPtr->ConvMode == ADC_CONV_MODE_CONTINUOUS)
  {
    /* If group is in continuous mode, enable REFILL mode of Queue*/
    lConvMode = (uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QINR_RF_OFF;
  }
  else
  {
    lConvMode = (uint32)0U;
  }

  #if (ADC_ENABLE_LIMIT_CHECK==STD_ON)
  if(GrpPtr->LimitCheckGroup == (uint8)ADC_ONE_U)
  {
    lRsIntpt = (uint32)0U;
  }
  else
  #endif
  {
    /* If group is not LIMIT CHECKING, enable the RS interrupt */
    lRsIntpt = (uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QINR_ENSI_OFF;
  }

  /* Get the group definition configuration */
  lGrpDefCfgPtr = GrpPtr->GroupDefinition;

  lNoOfChannels = GrpPtr->NoOfChannels;
  lChloopCount = (uint8)0U;

  /* Update QCTRL from the configuration directly */
  lEvadcQPtr->QCTRL.U =(uint32)\
              (GrpPtr->GroupQCtrlCfg | ADC_Q_CTRL_WRITE_PROTECT_MSK);

  /* Loop for all channels, except the last one */
  while(lChloopCount < (lNoOfChannels-(uint8)1U))
  {
    /* Input the channels in the RS Queue one by one, along with REFILL mode */
    lEvadcQPtr->QINR.U = (lConvMode |\
                       (uint32)(lGrpDefCfgPtr[lChloopCount].AnalogChannelNo));
    lChloopCount++;
  }

  /* Input the last channel in the RS Queue,
     along with REFILL mode and RS interrput*/
  lEvadcQPtr->QINR.U =(lConvMode | lRsIntpt |\
             (uint32)(lGrpDefCfgPtr[lChloopCount].AnalogChannelNo));

  /* Start the SW conversion
     - Ignore Gating signal
     - Generate a trigger event via TREV */
  lEvadcQPtr->QMR.U = ADC_START_SW_TRIG_CONV;
}
#endif

#if (ADC_ENABLE_QUEUING == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void  Adc_lPushToQueue                     **
**                    (                                                       **
**                       const uint32 KernelId                                **
**                       const Adc_GroupType GroupId                          **
**                    )                                                       **
**                                                                            **
** Description      :The function places the new requested group in Queue and **
**                   updates the Queue data. If Queue is empty, the requested **
**                   Group conversion is started.                             **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Re-entrant(ReEntrant for different Kernel)**
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lPushToQueue(const uint32 KernelId,\
                                   const Adc_GroupType GroupId)
{
  Adc_GlobalDataType *lKernelDataPtr;
  Adc_GroupType lPushGrpId;
  /* Get global state data location for the Kernel */
  lKernelDataPtr = Adc_lGetKernelDataAddress(KernelId);

  /* Set group status to BUSY, as it is in the queue now */
  Adc_lSetGroupStatusBusyAtomic(lKernelDataPtr,GroupId);
  Adc_lClrGroupResultAtomic(lKernelDataPtr,GroupId);
  Adc_lClrResBuffEndStatusAtomic(lKernelDataPtr,GroupId);
  lKernelDataPtr->NumofValidConRes[GroupId] = (Adc_StreamNumSampleType)0U;

  /* Check if the queue is empty */
  if(lKernelDataPtr->PushGroupId == ADC_INVALID_GROUP_ID)
  {
    /* Place group at the queue head */
    lKernelDataPtr->PushGroupId = GroupId;
    lKernelDataPtr->PopGroupId = GroupId;
    /* Start the group conversion */
    Adc_lScheduleFromQueue(KernelId);
  }
  else
  {
    /* Add group to the end of the queue */
    lPushGrpId = lKernelDataPtr->PushGroupId;
    lKernelDataPtr->QueueOfSwGroup[lPushGrpId].NextGroup = GroupId;
    lKernelDataPtr->QueueOfSwGroup[GroupId].PreviousGroup = lPushGrpId;
    lKernelDataPtr->PushGroupId = GroupId;
  }
}
#endif

#if (ADC_ENABLE_QUEUING == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : static void Adc_lScheduleFromQueue                      **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                    )                                                       **
**                                                                            **
** Description      :This function Schedules the Group for conversion which   **
**                   is pointed by Pop index.                                 **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Re-entrant(ReEntrant for different Kernel)**
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
static void Adc_lScheduleFromQueue(const uint32 KernelId)
{
  Adc_GlobalDataType *lKernelDataPtr;
  const Adc_GroupCfgType *lGrpCfgPtr;
  Adc_GroupType lPopGrpId;

  /* Get global state data location for the Kernel */
  lKernelDataPtr = Adc_lGetKernelDataAddress(KernelId);

  /* Get Group to be started */
  lPopGrpId = lKernelDataPtr->PopGroupId;

  /* Get group configuration address */
  lGrpCfgPtr =  &(Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->GrpCfgPtr[lPopGrpId]);

  /* Set the active group variable*/
  lKernelDataPtr->RSData[lGrpCfgPtr->GrpReqSrc].ActiveGroupId = lPopGrpId;

  /* Set the limit check group */
  #if (ADC_ENABLE_LIMIT_CHECK == STD_ON)
  if((uint8)ADC_ONE_U == lGrpCfgPtr->LimitCheckGroup)
  {
    lKernelDataPtr->RSData[lGrpCfgPtr->GrpReqSrc].ActiveLimitChkCh=\
            lGrpCfgPtr->GroupDefinition[0U].AnalogChannelNo;
  }
  #endif

  /* Prepare channels and result registers */
  Adc_lPrepareGrpForStart(KernelId,lPopGrpId);
  /* Enable ISR servicing for the request source */
  lKernelDataPtr->RSData[lGrpCfgPtr->GrpReqSrc].IsrNoServiceFlag = (uint8)0U;
  /* Prepare HW RS queue and trigger the SW conversion */
  Adc_lStartSwConversion(lGrpCfgPtr,KernelId);
}
#endif

#if (ADC_ENABLE_QUEUING == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : static void Adc_lPopFromQueue                           **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const Adc_GroupType GroupId                           **
**                    )                                                       **
**                                                                            **
** Description      :The function removes the requested group from Queue and  **
**                   updates the Queue data. If requested Group is currently  **
**                   converting, the Group is stopped and the next Group in   **
**                   Queue is started for conversion (if any).                **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Re-entrant(ReEntrant for different Kernel)**
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
static void Adc_lPopFromQueue(const uint32 KernelId,\
                              const Adc_GroupType GroupId)
{
  Adc_GlobalDataType *lKernelDataPtr;
  Adc_QueueDataType *lQueuePtr;
  const Adc_GroupCfgType *lGrpCfgPtr;
  Adc_GroupType lPopGrpId,lTempPrevGrpId,lTempNextGrpId;

  /* Get global state data location for the Kernel */
  lKernelDataPtr = Adc_lGetKernelDataAddress(KernelId);
  /* Get Base address of the Queue */
  lQueuePtr =  &(lKernelDataPtr->QueueOfSwGroup[0U]);
  /* Get group configuration address */
  lGrpCfgPtr = &(Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->GrpCfgPtr[GroupId]);

  /* Check if the element is the POP element, currently coverting */
  if(lKernelDataPtr->PopGroupId == GroupId)
  {
    /* Disable ISR servicing for the request source */
    lKernelDataPtr->RSData[lGrpCfgPtr->GrpReqSrc].IsrNoServiceFlag =\
                                                            (uint8)ADC_ONE_U;

    lKernelDataPtr->PopGroupId = lQueuePtr[GroupId].NextGroup;
    lPopGrpId = lKernelDataPtr->PopGroupId;
    /* Are there further groups in the queue */
    if(lPopGrpId != ADC_INVALID_GROUP_ID)
    {
      lQueuePtr[GroupId].NextGroup = ADC_INVALID_GROUP_ID;
      lQueuePtr[lPopGrpId].PreviousGroup = ADC_INVALID_GROUP_ID;
    }
    else
    {
      /*Since, there are no further groups in the queue, Queue is marked empty*/
      lKernelDataPtr->PushGroupId = ADC_INVALID_GROUP_ID;
    }

    /* Stop the ongoing conversion */
    Adc_lStopConvRequest(lGrpCfgPtr,KernelId);

    /* Clear Kernel Data variable */
    Adc_lRemoveActiveGroup(lKernelDataPtr,lGrpCfgPtr);

    /*Restore group status to IDLE*/
    Adc_lClrGroupStatusBusyAtomic(lKernelDataPtr,GroupId);
    Adc_lClrGroupResultAtomic(lKernelDataPtr,GroupId);
    Adc_lClrResBuffEndStatusAtomic(lKernelDataPtr,GroupId);
    lKernelDataPtr->NumofValidConRes[GroupId] = (Adc_StreamNumSampleType)0U;
    #if (ADC_GRP_NOTIF_CAPABILITY == STD_ON)
    /*Disable group notification*/
    Adc_lClrGrpNotifAtomic(lKernelDataPtr,GroupId);
    #endif /* End for ADC_GRP_NOTIF_CAPABILITY*/

    /* If more groups are present in the queue,
       Start the next group in the queue */
    if(lKernelDataPtr->PopGroupId != ADC_INVALID_GROUP_ID)
    {
      Adc_lScheduleFromQueue(KernelId);
    }
  }
  else
  { /*Group is in between or at the end of the queue, only Link is removed.
      No need to stop any conversion or clear SFR */
    lTempPrevGrpId = lQueuePtr[GroupId].PreviousGroup;
    lTempNextGrpId = lQueuePtr[GroupId].NextGroup;
    if(lTempPrevGrpId != ADC_INVALID_GROUP_ID)
    {
      lQueuePtr[lTempPrevGrpId].NextGroup = lTempNextGrpId;
    }
    if(lTempNextGrpId != ADC_INVALID_GROUP_ID)
    {
      lQueuePtr[lTempNextGrpId].PreviousGroup = lTempPrevGrpId;
    }
    lQueuePtr[GroupId].PreviousGroup = ADC_INVALID_GROUP_ID;
    lQueuePtr[GroupId].NextGroup = ADC_INVALID_GROUP_ID;

    if(lKernelDataPtr->PushGroupId == GroupId)
    {
      /*If the removed group is last in the queue, update the push group ID*/
      lKernelDataPtr->PushGroupId = lTempPrevGrpId;
    }

    /*Restore group status to IDLE*/
    Adc_lClrGroupStatusBusyAtomic(lKernelDataPtr,GroupId);
    Adc_lClrGroupResultAtomic(lKernelDataPtr,GroupId);
    Adc_lClrResBuffEndStatusAtomic(lKernelDataPtr,GroupId);
    lKernelDataPtr->NumofValidConRes[GroupId] = (Adc_StreamNumSampleType)0U;
    #if (ADC_GRP_NOTIF_CAPABILITY == STD_ON)
    /*Disable group notification*/
    Adc_lClrGrpNotifAtomic(lKernelDataPtr,GroupId);
    #endif /* End for ADC_GRP_NOTIF_CAPABILITY*/
  }
}
#endif

#if (ADC_ENABLE_QUEUING == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lRemoveFromQueue                  **
**                    (                                                       **
**                       Adc_GlobalDataType *KernelDataPtr                    **
**                       const Adc_GroupType GroupId                          **
**                    )                                                       **
**                                                                            **
** Description      :This function Removes the Group from Queue which has     **
**                   just completed the conversion (implicitly stopped)       **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Re-entrant(ReEntrant for different Kernel)**
**                                                                            **
** Parameters(in)   : KernelId - Pointer to the kenrels global data structure **
**                    GroupId - Group ID for the Kernel                       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lRemoveFromQueue(Adc_GlobalDataType *KernelDataPtr,\
                                                   const Adc_GroupType GroupId)
{
  Adc_QueueDataType *lQueuePtr;
  Adc_GroupType lPopGrpId;

  /* Get Base address of the Queue */
  lQueuePtr = &(KernelDataPtr->QueueOfSwGroup[0U]);

  /*Update the next group in queue as the POP group*/
  KernelDataPtr->PopGroupId = lQueuePtr[GroupId].NextGroup;
  lPopGrpId = KernelDataPtr->PopGroupId;
  /* Are there further groups in the queue */
  if(lPopGrpId != ADC_INVALID_GROUP_ID)
  {
    lQueuePtr[GroupId].NextGroup = ADC_INVALID_GROUP_ID;
    lQueuePtr[lPopGrpId].PreviousGroup = ADC_INVALID_GROUP_ID;
  }
  else
  {
    /*Since, there are no further groups in the queue, Queue is marked empty*/
    KernelDataPtr->PushGroupId = ADC_INVALID_GROUP_ID;
  }
}
#endif

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : static void Adc_lStopConvRequest                        **
**                    (                                                       **
**                      const Adc_GroupCfgType *GrpPtr                        **
**                      const uint32 KernelId                                 **
**                    )                                                       **
**                                                                            **
** Description      : This function  stops the on-going Adc group conversion  **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Re-entrant(ReEntrant for different Kernel)**
**                                                                            **
** Parameters(in)   : GrpPtr  - Pointer to the Group configuration data       **
**                    KernelId  - ADC Group ID of the Kernel                  **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
static void Adc_lStopConvRequest(const Adc_GroupCfgType *GrpPtr,
                                 const uint32 KernelId)
{
  Ifx_EVADC_G_Q *lEvadcQPtr;

  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
   lEvadcQPtr = &MODULE_EVADC.G[KernelId].Q[GrpPtr->GrpReqSrc];

  /* Disable the GATE signal of the Queue */
  lEvadcQPtr->QMR.B.ENGT = 0U;

  /* Flush the RS queue and clear the valid flags  */
  lEvadcQPtr->QMR.U =(((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_FLUSH_OFF)|\
                      ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_CEV_OFF)|\
                      ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_CLRV_OFF));

  #if (ADC_HW_TRIGGER_API == STD_ON)
  /* Reset the HW trigger peripheral for a HW triggered Group */
  if(ADC_TRIGG_SRC_HW == GrpPtr->TriggerSource)
  {
    Adc_lResetHwTrigger(GrpPtr);
  }
  #endif
  /* Wait for stop conversion required */
  #if (ADC_MAX_CH_CONV_TIME > 0U)
  /* Wait for the ongoing conversion to stop */
  const Ifx_EVADC_G *lEvadcGroupPtr;
  uint32 lGrpReqSrc,lWaitCount,lCurrentRS,lBusyFlag;

   /* Get the base address of the Kernel SFR */
    /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
       object and integer type is permitted for special function registers*/
  lEvadcGroupPtr = &MODULE_EVADC.G[KernelId];
  lGrpReqSrc = (uint32)(GrpPtr->GrpReqSrc);

  lWaitCount = (uint32)ADC_MAX_CH_CONV_TIME;

  /* Get the currently converting RS */
  lCurrentRS = (uint32)lEvadcGroupPtr->ARBCFG.B.CSRC;
  /* Get the Converter Busy flag */
  lBusyFlag = (uint32)lEvadcGroupPtr->ARBCFG.B.BUSY;

  /*If BUSY flag is 1, CSRC bit indicates the current converting RS ,
    If Busy flag is 0, CRSC bit indicates the last converted RS,
    If BUSY flag is 1, while CSRC points to RS of the stopped AdcGroup,
      then the stopped conversion has not yet completed */
  while((lBusyFlag == (uint32)ADC_ONE_U) && (lCurrentRS == lGrpReqSrc) &&\
        (lWaitCount > (uint32)0U))
  {
    lWaitCount--;
    /* Get the currently converting RS */
    lCurrentRS = (uint32)lEvadcGroupPtr->ARBCFG.B.CSRC;
    /* Get the Converter Busy flag */
    lBusyFlag = (uint32)lEvadcGroupPtr->ARBCFG.B.BUSY;
  }
  #if (ADC_CONV_STOP_TIME_DEM_NOTIF == ADC_ENABLE_DEM_REPORT)
  if(lWaitCount != (uint32)0U)
  {
    Dem_ReportErrorStatus(ADC_E_CONV_STOP_TIME_FAILURE,\
                      DEM_EVENT_STATUS_PASSED);
  }
  else
  {
  /* Raise failure DEM, when stop count reaches 0 */
  Dem_ReportErrorStatus(ADC_E_CONV_STOP_TIME_FAILURE,\
                    DEM_EVENT_STATUS_FAILED);
  }
  #endif /* End for ADC_CONV_STOP_TIME_DEM_NOTIF */
  #endif /* Ebd for ADC_MAX_CH_CONV_TIME */
  /* Clear CHCTR, RCR and valid flags for the stopped group */
  Adc_lClearGroupSfr(GrpPtr,KernelId);
  /* Get the base address of the RS Queue SFR */
 }

/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : static void Adc_lClearGroupSfr                          **
**                    (                                                       **
**                      const Adc_GroupCfgType *GrpPtr                        **
**                      const uint32 KernelId                                 **
**                    )                                                       **
**                                                                            **
** Description      : This function Fclears all the Channel Control Registers,**
**                    Result Control Registers and Queue Control Register for **
** [/cover]                                                                   **
**                    the group ID.                                           **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Re-entrant(ReEntrant for different Kernel)**
**                                                                            **
** Parameters(in)   : GrpPtr  - Pointer to the Group configuration data       **
**                    KernelId  - ADC Group ID of the Kernel                  **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
static void Adc_lClearGroupSfr(const Adc_GroupCfgType *GrpPtr,\
                               const uint32 KernelId)
{
  Ifx_EVADC_G *lEvadcGroupPtr;
  Ifx_EVADC_G_Q *lEvadcQPtr;
  const Adc_GroupDefType *lGrpDefCfgPtr;
  Adc_ChannelType lAnChannelId;
  Adc_ResultRegType lResReg;
  uint8 lNoOfChannels,lChloopCount;

  /* Get the base address of the Kernel SFR */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
  lEvadcGroupPtr = &MODULE_EVADC.G[KernelId];
  /* Get the base address of the RS Queue SFR */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
  lEvadcQPtr = &MODULE_EVADC.G[KernelId].Q[GrpPtr->GrpReqSrc];
  /* Get the base address of the groups definition */
  lGrpDefCfgPtr = GrpPtr->GroupDefinition;

  /* Clear Queue mode register */
  lEvadcQPtr->QMR.U = (((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_FLUSH_OFF)|\
                      ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_CEV_OFF)|\
                      ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_CLRV_OFF));

  /*Clear Queue control register*/
  lEvadcQPtr->QCTRL.U = ADC_Q_CTRL_WRITE_PROTECT_MSK;

  /*Reset Alias configuration */
  lEvadcGroupPtr->ALIAS.U = ADC_ALIAS_DEFAULT_VALUE;

  /* Clear RS event, Channel event and result event flags */
  lEvadcGroupPtr->SEFCLR.U = ((uint32)ADC_ONE_U<<(GrpPtr->GrpReqSrc));
  lEvadcGroupPtr->CEFCLR.U = (uint32)GrpPtr->ChannelMask;
  lEvadcGroupPtr->REFCLR.U = (uint32)GrpPtr->ResultRegMask;
  /* Clear valid flags for all result registers */
  lEvadcGroupPtr->VFR.U = (uint32)GrpPtr->ResultRegMask;

  lChloopCount = (uint8)0U;
  lNoOfChannels = GrpPtr->NoOfChannels;
  do
  {
    /* Clear all channle control and result control register */
    lAnChannelId = lGrpDefCfgPtr[lChloopCount].AnalogChannelNo;
    lResReg = lGrpDefCfgPtr[lChloopCount].ResultReg;
    lEvadcGroupPtr->CHCTR[lAnChannelId].U &= ADC_CLR_CHCTR_EXCEPT_BWD;
    lEvadcGroupPtr->RCR[lResReg].U = (uint32)0U;
    lChloopCount++;
  }while(lChloopCount<lNoOfChannels);

  #if (ADC_ENABLE_LIMIT_CHECK==STD_ON)
  if(GrpPtr->LimitCheckGroup == (uint8)ADC_ONE_U)
  {
    /* Clear boundary value registers */
    lEvadcGroupPtr->BOUND.U = (uint32)0U;
  }
  #endif /*End for ADC_ENABLE_LIMIT_CHECK*/
}
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lRemoveActiveGroup                **
**                    (                                                       **
**                      Adc_GlobalDataType *KernelDataPtr                     **
**                      const Adc_GroupCfgType *GrpPtr                        **
**                    )                                                       **
**                                                                            **
** Description      : This Function removes the active group from the Kernel  **
**                    Data                                                    **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant                                 **
**                                                                            **
** Parameters(in)   : KernelDataPtr  - Pointer to the Kernel specific data    **
**                  : GrpPtr  - Pointer to the Group configuration data       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lRemoveActiveGroup(Adc_GlobalDataType *KernelDataPtr,\
                                          const Adc_GroupCfgType *GrpPtr)
{
  /*Assign Invalid Group ID to active group variable*/
  KernelDataPtr->RSData[GrpPtr->GrpReqSrc].ActiveGroupId =ADC_INVALID_GROUP_ID;
  #if (ADC_ENABLE_LIMIT_CHECK==STD_ON)
  if((uint8)ADC_ONE_U == GrpPtr->LimitCheckGroup)
  {
    KernelDataPtr->RSData[GrpPtr->GrpReqSrc].ActiveLimitChkCh =\
                                                       ADC_INVALID_CHANNEL_ID;
  }
  #endif
  #if (ADC_PRIORITY_IMPLEMENTATION != ADC_PRIORITY_NONE)
   /* Clear flags for used channels and result registers */
   KernelDataPtr->AllRunningChannels &= \
     (uint16)((~(GrpPtr->ChannelMask))& ADC_CHANNEL_RESULT_CLR_MASK);
   KernelDataPtr->AllRunningResReg &= \
     (uint16)((~(GrpPtr->ResultRegMask)) & ADC_CHANNEL_RESULT_CLR_MASK);
  #endif
}
#if (ADC_HW_TRIGGER_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lResetHwTrigger                   **
**                    (                                                       **
**                      const Adc_GroupCfgType *GrpPtr                        **
**                    )                                                       **
**                                                                            **
** Description      : This Function disables the GTM/ERU channel used by the  **
**                    group.                                                  **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant(Re-entrant for different        **
**                    Channel)                                                **
**                                                                            **
** Parameters(in)   : GrpPtr  - Pointer to the Group configuration data       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lResetHwTrigger(const Adc_GroupCfgType *GrpPtr)
{
  if(GrpPtr->GtmTrigCfg != NULL_PTR)
  {
    Adc_lGtmChannelDeInit(GrpPtr->GtmTrigCfg);
  }
  else if(GrpPtr->EruTrigCfg != NULL_PTR)
  {
    Adc_lEruChannelDeInit(GrpPtr->EruTrigCfg);
  }
  else
  {
    /*Do Nothing*/
  }

  if(GrpPtr->GtmGateCfg != NULL_PTR)
  {
    Adc_lGtmChannelDeInit(GrpPtr->GtmGateCfg);
  }
  else if(GrpPtr->EruGateCfg != NULL_PTR)
  {
    Adc_lEruChannelDeInit(GrpPtr->EruGateCfg);
  }
  else
  {
    /*Do Nothing*/
  }
}
#endif
#if (ADC_HW_TRIGGER_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lSetHwTrigger                     **
**                    (                                                       **
**                      const Adc_GroupCfgType *GrpPtr                        **
**                    )                                                       **
**                                                                            **
** Description      : This Function Enables the GTM/ERU channel used by the   **
** [/cover]                                                                   **
**                    group.                                                  **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant(Re-entrant for different        **
**                    Channel)                                                **
**                                                                            **
** Parameters(in)   : GrpPtr  - Pointer to the Group configuration data       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lSetHwTrigger(const Adc_GroupCfgType *GrpPtr)
{
  if(GrpPtr->GtmTrigCfg != NULL_PTR)
  {
    Adc_lGtmChannelInit(GrpPtr->GtmTrigCfg);
  }
  else if(GrpPtr->EruTrigCfg != NULL_PTR)
  {
    Adc_lEruChannelInit(GrpPtr->EruTrigCfg);
  }
  else
  {
    /*Do Nothing*/
  }

  if(GrpPtr->GtmGateCfg != NULL_PTR)
  {
    Adc_lGtmChannelInit(GrpPtr->GtmGateCfg);
  }
  else if(GrpPtr->EruGateCfg != NULL_PTR)
  {
    Adc_lEruChannelInit(GrpPtr->EruGateCfg);
  }
  else
  {
    /*Do Nothing*/
  }
}
#endif
#if (ADC_HW_TRIGGER_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lStartHwConversion                **
**                    (                                                       **
**                      const Adc_GroupCfgType *GrpPtr                        **
**                      const uint32 KernelId                                 **
**                    )                                                       **
**                                                                            **
** Description      : This function programs the Request Source Queue and     **
**                    triggers the start of conversion.                       **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant(Re-entrant for different Kernel)**
**                                                                            **
** Parameters(in)   : GrpPtr  - Pointer to the Group configuration data       **
**                    KernelId  - ADC Group ID of the Kernel                  **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lStartHwConversion(const Adc_GroupCfgType *GrpPtr,\
                                                     const uint32 KernelId)
{
  Ifx_EVADC_G *lEvadcGroupPtr;
  Ifx_EVADC_G_Q *lEvadcQPtr;
  const Adc_GroupDefType *lGrpDefCfgPtr;
  uint32 lConvMode,lRsIntpt,lWaitForTrigger;
  uint8 lNoOfChannels,lChloopCount;

  /* Get base address of the kernel SFR */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
  lEvadcGroupPtr = &MODULE_EVADC.G[KernelId];
  /* Get base address of the RS SFR */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
     object and integer type is permitted for special function registers*/
  lEvadcQPtr = &MODULE_EVADC.G[KernelId].Q[GrpPtr->GrpReqSrc];

  /* Flush the RS queue, before channels are queued up for conversion */
  lEvadcQPtr->QMR.U =(((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_FLUSH_OFF)|\
                      ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_CEV_OFF)|\
                      ((uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QMR_CLRV_OFF));

  /* Clear RS event, Channel event and result event flags */
  lEvadcGroupPtr->SEFCLR.U = ((uint32)ADC_ONE_U<<(GrpPtr->GrpReqSrc));
  lEvadcGroupPtr->CEFCLR.U = (uint32)GrpPtr->ChannelMask;
  lEvadcGroupPtr->REFCLR.U = (uint32)GrpPtr->ResultRegMask;
  /* Clear valid flag for all result registers */
  lEvadcGroupPtr->VFR.U = (uint32)GrpPtr->ResultRegMask;

  /* Queue is always programmed in refill mode for HW triggered groups */
  lConvMode = (uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QINR_RF_OFF;

  #if (ADC_ENABLE_LIMIT_CHECK==STD_ON)
  if(GrpPtr->LimitCheckGroup == (uint8)ADC_ONE_U)
  {
    lRsIntpt = (uint32)0U;
  }
  else
  #endif
  {
    /* If group is not LIMIT CHECKING, enable the RS interrupt */
    lRsIntpt = (uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QINR_ENSI_OFF;
  }

  /* Get the group definition configuration */
  lGrpDefCfgPtr = GrpPtr->GroupDefinition;

  lNoOfChannels = GrpPtr->NoOfChannels;
  lChloopCount = (uint8)0U;

  /* Update QCTRL from configuration directly */
  lEvadcQPtr->QCTRL.U =\
              (GrpPtr->GroupQCtrlCfg | ADC_Q_CTRL_WRITE_PROTECT_MSK);

  /* Enable wait for external trigger for the 1st entry in the queue */
  lWaitForTrigger = (uint32)ADC_ONE_U<<IFX_EVADC_G_Q_QINR_EXTR_OFF;

  /* Loop for all but the last entry in the queue*/
  while(lChloopCount<(lNoOfChannels-(uint8)1U))
  {
    /* Input the channels in the RS Queue one by one, alogn with refill mode */
    /* 1st channel is programmed to wait for a HW trigger event*/
    lEvadcQPtr->QINR.U =\
        (lConvMode | lWaitForTrigger |\
        (uint32)(lGrpDefCfgPtr[lChloopCount].AnalogChannelNo));
    /* Reset wait for trigger, for subsequent queue entries */
    lWaitForTrigger = (uint32)0U;
    lChloopCount++;
  }
  /* Input the last channel in the RS Queue,
     alogn with refill mode and RS interrput*/
  /* If there is only one channel in the group
     Wait for HW trigger event is enabled here */
  lEvadcQPtr->QINR.U =(lConvMode | lWaitForTrigger | lRsIntpt  |\
                      (uint32)(lGrpDefCfgPtr[lChloopCount].AnalogChannelNo));

  /* Set Up the HW trigger peripheral */
  Adc_lSetHwTrigger(GrpPtr);

  /* Program the QMR register from the configuration,
     wait for trigger event now to start conversions */
  lEvadcQPtr->QMR.U = GrpPtr->GroupQModeCfg;
}
#endif
#if (ADC_HW_TRIGGER_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lGtmChannelInit                   **
**                    (                                                       **
**                      const Mcal_GtmTomChConfigType *GtmChannelCfgPtr       **
**                    )                                                       **
**                                                                            **
** Description      : This function configures and triggers the start of the  **
**                    GTM channel.                                            **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant (Re-entrant for different       **
**                    channels)                                               **
**                                                                            **
** Parameters(in)   : GtmChannelCfgPtr  - Pointer to the GTM channel          **
**                    configuration structure.                                **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lGtmChannelInit(\
                           const Mcal_GtmTomChConfigType *GtmChannelCfgPtr)
{
  uint8 lGtmModuleNo, lGtmChNo;

  lGtmModuleNo = GtmChannelCfgPtr->TimerId.TimerModuleNumber;
  lGtmChNo =  GtmChannelCfgPtr->TimerId.TimerChannelNumber;

  if(GtmChannelCfgPtr->TimerType == MCAL_GTM_TIMER_TOM)
  {
    Mcal_GtmTomChannelInit(GtmChannelCfgPtr);
    Mcal_GtmTomChannelShadowTransfer(lGtmModuleNo,lGtmChNo);
    Mcal_GtmTomChannelEnable(lGtmModuleNo,lGtmChNo,MCAL_GTM_TIMER_OUT_ENABLE);
  }
  else
  {
    Mcal_GtmAtomChannelInit(GtmChannelCfgPtr);
    Mcal_GtmAtomChannelShadowTransfer(lGtmModuleNo,lGtmChNo);
    Mcal_GtmAtomChannelEnable(lGtmModuleNo,lGtmChNo,MCAL_GTM_TIMER_OUT_ENABLE);
  }
}
#endif
#if (ADC_HW_TRIGGER_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lGtmChannelDeInit                 **
**                    (                                                       **
**                      const Mcal_GtmTomChConfigType *GtmChannelCfgPtr       **
**                    )                                                       **
**                                                                            **
** Description      : This function stops and de-initializes a GTM channel.   **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant (Re-entrant for different       **
**                    channels)                                               **
**                                                                            **
** Parameters(in)   : GtmChannelCfgPtr  - Pointer to the GTM channel          **
**                    configuration structure.                                **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lGtmChannelDeInit(\
                           const Mcal_GtmTomChConfigType *GtmChannelCfgPtr)
{
  uint8 lGtmModuleNo, lGtmChNo;

  lGtmModuleNo = GtmChannelCfgPtr->TimerId.TimerModuleNumber;
  lGtmChNo =  GtmChannelCfgPtr->TimerId.TimerChannelNumber;

  if(GtmChannelCfgPtr->TimerType==MCAL_GTM_TIMER_TOM)
  {
    Mcal_GtmTomChannelDisable(lGtmModuleNo,lGtmChNo);
    Mcal_GtmTomChannelDeInit(lGtmModuleNo,lGtmChNo);
    Mcal_GtmTomChannelShadowTransfer(lGtmModuleNo,lGtmChNo);
  }
  else
  {
    Mcal_GtmAtomChannelDisable(lGtmModuleNo,lGtmChNo);
    Mcal_GtmAtomChannelDeInit(lGtmModuleNo,lGtmChNo);
    Mcal_GtmAtomChannelShadowTransfer(lGtmModuleNo,lGtmChNo);
  }
}
#endif
#if (ADC_HW_TRIGGER_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lEruChannelInit                   **
**                    (                                                       **
**                      const Adc_EruChannelCfgType *EruChannelCfgPtr         **
**                    )                                                       **
**                                                                            **
** Description      : This function configures and triggers the start of the  **
**                    ERU channel.                                            **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant (Re-entrant for different       **
**                    channels)                                               **
**                                                                            **
** Parameters(in)   : EruChannelCfgPtr  - Pointer to the ERU channel          **
**                    configuration structure.                                **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lEruChannelInit(\
                              const Adc_EruChannelCfgType *EruChannelCfgPtr)
{
  uint32 lEicrIndex,lIgcrIndex;
  uint8 lEicrPos,lIgcrPos;
  /* Each EICR register consists of 2 channels, hence index is div 2 */
  lEicrIndex = (((uint32)(EruChannelCfgPtr->ErsChannel)>>(uint32)ADC_ONE_U) &\
                                           (uint32)ADC_ERU_EICR_REG_SEL_MASK);
  /* Odd Channels are at bit position is 16,
    and for even channels bit position is 0*/
  lEicrPos = (uint8)(\
  ((uint32)(EruChannelCfgPtr->ErsChannel) & (uint32)ADC_ONE_U)<<\
                                         (uint32)ADC_ERU_CH_CFG_BIT_POS_SHIFT);

  /* Each IGCR register consists of 2 channels, hence index is div 2 */
  lIgcrIndex = (((uint32)(EruChannelCfgPtr->OguChannel)>>(uint32)ADC_ONE_U) &\
                                          (uint32)ADC_ERU_IGCR_REG_SEL_MASK);
  /* Odd Channels are at bit position is 16,
    and for even channels bit position is 0*/
  lIgcrPos = (uint8)(\
  ((uint32)(EruChannelCfgPtr->OguChannel) & (uint32)ADC_ONE_U)<<\
                                         (uint32)ADC_ERU_CH_CFG_BIT_POS_SHIFT);

  Mcal_SetBitAtomic((&MODULE_SCU.EICR[lEicrIndex]),\
                     lEicrPos,\
                     ADC_ERU_DATA_BITS,\
                     EruChannelCfgPtr->EruEicrCfg);

  Mcal_SetBitAtomic((&MODULE_SCU.IGCR[lIgcrIndex]),\
                     lIgcrPos,\
                     ADC_ERU_DATA_BITS,\
                     EruChannelCfgPtr->EruIgcrCfg);
  /* MISRA2012_RULE_2_2_JUSTIFICATION: Values are assigned in assembly 
     instructions  so they are actually used and not dead code.*/
  /* MISRA2012_RULE_2_2_JUSTIFICATION: Values are assigned in assembly 
     instructions so they are actually used and not dead code.*/
  /* MISRA2012_RULE_2_2_JUSTIFICATION: Values are assigned in assembly 
     instructions so they are actually used and not dead code.*/
  /* MISRA2012_RULE_2_2_JUSTIFICATION: Values are assigned in assembly 
     instructions so they are actually used and not dead code.*/
}
#endif
#if (ADC_HW_TRIGGER_API == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE void Adc_lEruChannelDeInit                 **
**                    (                                                       **
**                      const Adc_EruChannelCfgType *EruChannelCfgPtr         **
**                    )                                                       **
**                                                                            **
** Description      : This function de-initializes ERS and OGU pointed by     **
**                    EruChannelCfgPtr                                        **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant (Re-entrant for different       **
**                    channels)                                               **
**                                                                            **
** Parameters(in)   : EruChannelCfgPtr  - Pointer to the ERU channel          **
**                    configuration structure.                                **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE void Adc_lEruChannelDeInit(\
                                const Adc_EruChannelCfgType *EruChannelCfgPtr)
{
  uint32 lEicrIndex,lIgcrIndex;
  uint8 lEicrPos,lIgcrPos;

  /* Each EICR register consists of 2 channels, hence index is div 2 */
  lEicrIndex = (((uint32)(EruChannelCfgPtr->ErsChannel)>>(uint32)ADC_ONE_U) &\
                                           (uint32)ADC_ERU_EICR_REG_SEL_MASK);
  /* Odd Channels are at bit position is 16,
    and for even channels bit position is 0*/
  lEicrPos = (uint8)(\
  ((uint32)(EruChannelCfgPtr->ErsChannel) & (uint32)ADC_ONE_U)<<\
                                         (uint32)ADC_ERU_CH_CFG_BIT_POS_SHIFT);

  /* Each IGCR register consists of 2 channels, hence index is div 2 */
  lIgcrIndex = (((uint32)(EruChannelCfgPtr->OguChannel)>>(uint32)ADC_ONE_U) &\
                                          (uint32)ADC_ERU_IGCR_REG_SEL_MASK);
  /* Odd Channels are at bit position is 16,
    and for even channels bit position is 0*/
  lIgcrPos = (uint8)(\
  ((uint32)(EruChannelCfgPtr->OguChannel) & (uint32)ADC_ONE_U)<<\
                                         (uint32)ADC_ERU_CH_CFG_BIT_POS_SHIFT);

  Mcal_SetBitAtomic((&MODULE_SCU.EICR[lEicrIndex]),\
                     lEicrPos,\
                     ADC_ERU_DATA_BITS,\
                     (uint32)0U);

  Mcal_SetBitAtomic((&MODULE_SCU.IGCR[lIgcrIndex]),\
                     lIgcrPos,\
                     ADC_ERU_DATA_BITS,\
                     (uint32)0U);
  /* MISRA2012_RULE_2_2_JUSTIFICATION:Values are assigned in assembly 
     instructions so they are actually used and not dead code */
  /* MISRA2012_RULE_2_2_JUSTIFICATION:Values are assigned in assembly 
     instructions so they are actually used and not dead code */
  /* MISRA2012_RULE_2_2_JUSTIFICATION:Values are assigned in assembly 
     instructions so they are actually used and not dead code */
  /* MISRA2012_RULE_2_2_JUSTIFICATION:Values are assigned in assembly 
     instructions so they are actually used and not dead code */
}
#endif
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : static void Adc_lRSEventHandler                         **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const uint8 RequestSrc                                **
**                    )                                                       **
**                                                                            **
** Description      : This function updates the necessary result buffers and  **
**                    schedules the next group (if required) for conversion.  **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant(Re-entrant for different Kernel)**
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID for which the Interrupt handler    **
**                    is invoked                                              **
**                    RequestSrc - Request Source for which interrupt occured **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
static void Adc_lRSEventHandler(const uint32 KernelId, const uint8 RequestSrc)
{
  #if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
  const Adc_GlobalDataType *lKernelDataPtr;
  #else
  Adc_GlobalDataType *lKernelDataPtr;
  #endif
  Adc_GroupType lGroupId;

  /* Get global state data location for the Kernel */
  lKernelDataPtr = Adc_lGetKernelDataAddress(KernelId);
  if(lKernelDataPtr->RSData[RequestSrc].IsrNoServiceFlag == (uint8)0U)
  {
    lGroupId = lKernelDataPtr->RSData[RequestSrc].ActiveGroupId;

    #if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
    /*Update the results to application buffers */
    Adc_lUpdateResBuffer(KernelId,lGroupId);
    /* Check if new group has to scheduled for conversion */
    Adc_lGrpSequenceHandler(KernelId,lGroupId,RequestSrc);
    #else
    /*Set the flag for number of streaming samples completed,
    if the streaming sample set is completed*/
    Adc_lSetResBuffEndStatusAtomic(lKernelDataPtr,lGroupId);
    /* Set the flag for atleast one result sample avaialble */
    Adc_lSetGroupResultAtomic(lKernelDataPtr,lGroupId);
    #endif
    #if (ADC_GRP_NOTIF_CAPABILITY == STD_ON)
    const Adc_GroupCfgType *lGrpCfgPtr;
    /*Check if notification is enabled for the group */
    if(Adc_lGetGroupNotifStatus(lKernelDataPtr,lGroupId) == (uint32)ADC_ONE_U)
    {
      lGrpCfgPtr = &(Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->\
                                                        GrpCfgPtr[lGroupId]);
      if(lGrpCfgPtr->NotifyPtr != NULL_PTR)
      {
        /*Call the notification function */
        lGrpCfgPtr->NotifyPtr();
      }
    }
    #endif /* End for ADC_GRP_NOTIF_CAPABILITY */
  }

}
#if (ADC_ENABLE_LIMIT_CHECK==STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : static void Adc_lLimitChkEventHandler                   **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const Adc_GroupType GroupId                           **
**                    )                                                       **
**                                                                            **
** Description      : This function handles the channel event for a limit     **
**                    check group                                             **
** [/cover]                                                                   **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant(Re-entrant for different Kernel)**
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID for which the Interrupt handler    **
**                    is invoked                                              **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
static void Adc_lLimitChkEventHandler(const uint32 KernelId,\
                                      const Adc_GroupType GroupId)
{
  const Adc_GlobalDataType *lKernelDataPtr;
  const Adc_GroupCfgType *lGrpCfgPtr;
  uint8 lRequestSrc;

  /* Get global state data location for the Kernel */
  lKernelDataPtr = Adc_lGetKernelDataAddress(KernelId);
  /* Get Group Config pointer */
  lGrpCfgPtr = &(Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->GrpCfgPtr[GroupId]);
  /* Get Group Request Source */
  lRequestSrc = lGrpCfgPtr->GrpReqSrc;

  if(lKernelDataPtr->RSData[lRequestSrc].IsrNoServiceFlag == (uint8)0U)
  {
    /*Update the results to application buffers */
    Adc_lUpdateResBuffer(KernelId,GroupId);
    /*Check if new group has to scheduled for conversion*/
    Adc_lGrpSequenceHandler(KernelId,GroupId,lRequestSrc);

    #if (ADC_GRP_NOTIF_CAPABILITY == STD_ON)
    if(Adc_lGetGroupNotifStatus(lKernelDataPtr,GroupId) == (uint32)ADC_ONE_U)
    {
      if(lGrpCfgPtr->NotifyPtr!=NULL_PTR)
      {
        /*Call the notification function */
        lGrpCfgPtr->NotifyPtr();
      }
    }
    #endif /* End for ADC_GRP_NOTIF_CAPABILITY */
  }
}
#endif
#if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : static void Adc_lUpdateResBuffer                        **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const Adc_GroupType  GroupId                          **
**                    )                                                       **
**                                                                            **
** Description      : This function Updates the Group Result buffer on        **
**                    conversion completion                                   **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant(Re-entrant for different Kernel)**
**                                                                            **
** Parameters(in)   : KernelId  - ADC Kernel to which the group belongs       **
**                    GroupId   - ADC Group ID of the Kernel                  **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
static void Adc_lUpdateResBuffer(const uint32 KernelId,\
                                 const Adc_GroupType GroupId)
{
  /* MISRA2012_RULE_19_2_JUSTIFICATION:Usage of Union is done for special 
     function register access */
  /* MISRA2012_RULE_8_13_JUSTIFICATION: The same result register SFR is read 
     multiple times due to FIFO implementation, hence cannot declare the SFR 
     as a constant */
  volatile Ifx_EVADC_G_RES *lResRegPtr;
  Ifx_EVADC_G *lEvadcGroupPtr;
  Adc_GlobalDataType *lKernelDataPtr;
  const Adc_GroupCfgType *lGrpCfgPtr;
  Adc_ValueGroupType *lCurrentBufferPtr;
  Adc_StreamNumSampleType lNumOfSamples,lCurrentBufLocation;
  Adc_ResultRegType lResultRegFifoOutput;
  uint8 lNoOfChannels;

    /* MISRA2012_RULE_11_4_JUSTIFICATION: Conversion between pointer to 
       object and integer type is permitted for special function registers*/
  lEvadcGroupPtr = &MODULE_EVADC.G[KernelId];
  lKernelDataPtr = Adc_lGetKernelDataAddress(KernelId);

  /* Get group related confiuration data */
  lGrpCfgPtr = &(Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->GrpCfgPtr[GroupId]);
  lNumOfSamples = lGrpCfgPtr->NumOfSamples;
  lNoOfChannels = lGrpCfgPtr->NoOfChannels;

  /* Results registers are in FIFO mode, hence read from FIFO tail */
  lResultRegFifoOutput = lGrpCfgPtr->GroupDefinition[0U].ResultReg;
  lResRegPtr = &(lEvadcGroupPtr->RES[lResultRegFifoOutput]);
  /* Get the buffer location where results are to be written */
  lCurrentBufLocation = lKernelDataPtr->NumofValidConRes[GroupId];
  if(lCurrentBufLocation == lNumOfSamples)
  {
    lCurrentBufLocation = (Adc_StreamNumSampleType)0U;
  }
  /*
   Application Result Buffer organisation for
   - 5 Channels - CH9, CH1, CH2, CH3 and CH4
   - 3 streaming samples for each channel

    Buffer Start                                       Buffer End
    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
    |CH9|CH9|CH9|CH1|CH1|CH1|CH2|CH2|CH2|CH3|CH3|CH3|CH4|CH4|CH4|
    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  */
  /* Get the buffer address to store the current results */
  /* MISRA2012_RULE_18_4_JUSTIFICATION: Pointer arithmetic other than 
     array indexing used for ADC application buffers. The buffer layout for 
     result handling as defined by AUTOSAR forces to use pointer arithmetic. 
     The access range is within the boundaries of the buffer.*/
  lCurrentBufferPtr = lKernelDataPtr->GrpResBuffer[GroupId]+\
                      lCurrentBufLocation;
  do
  {
      /* HW alignment has issues (JIRA 0000049095-179),
       hence result alignment is done in SW.
       Conversion results are always right aligned in HW*/
    #if(ADC_RESULT_ALIGNMENT == ADC_ALIGN_RIGHT)
    *lCurrentBufferPtr = \
    (Adc_ValueGroupType)((uint32)(lResRegPtr->U) &\
                        (uint32)ADC_12BIT_RIGHT_ALIGN_RESULT_MASK);
    #else
    *lCurrentBufferPtr =\
    (Adc_ValueGroupType)(((uint32)(lResRegPtr->U) &\
                        (uint32)ADC_12BIT_RIGHT_ALIGN_RESULT_MASK)<<\
                        ADC_12BIT_LEFT_ALIGN_RESULT_SHIFT);
    #endif
    /* Increment buffer pointer to the Next Channels buffer position */
    /* MISRA2012_RULE_18_4_JUSTIFICATION: Pointer arithmetic other than 
       array indexing used for ADC application buffers. The buffer layout for 
       result handling as defined by AUTOSAR forces to use pointer arithmetic. 
       The access range is within the boundaries of the buffer.*/
    lCurrentBufferPtr = lCurrentBufferPtr + lNumOfSamples;
    lNoOfChannels--;
  }while(lNoOfChannels > (uint8)0U);

  /*Increment the number of valid conversions available */
  lCurrentBufLocation++;

  /*Set the next buffer position of the Application result buffer,
    also incidcates the number of result samples available */
  lKernelDataPtr->NumofValidConRes[GroupId] = lCurrentBufLocation;

  /* Set the flag for atleast one result sample avaialble */
  Adc_lSetGroupResultAtomic(lKernelDataPtr,GroupId);

  if(lCurrentBufLocation == lNumOfSamples)
  {
    /*Set the flag for number of streaming samples completed,
      if the streaming sample set is completed*/
    Adc_lSetResBuffEndStatusAtomic(lKernelDataPtr,GroupId);
  }
  /* MISRA2012_RULE_8_13_JUSTIFICATION: The same result register SFR is read 
     multiple times due to FIFO implementation, hence cannot declare the SFR 
     as a constant */
 }
#endif /* End for ADC_RESULT_HANDLING_IMPLEMENTATION */
#if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : static void Adc_lGrpSequenceHandler                     **
**                    (                                                       **
**                     const uint32 KernelId                                  **
**                     const Adc_GroupType  GroupId                           **
**                     const uint8 ReqSrc                                     **
**                    )                                                       **
**                                                                            **
** Description      : This function stops the conversion of Implicit stop     **
**                    groups and schedules the next group in the queue.       **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Conditionally Reentrant(Re-entrant for different Kernel)**
**                                                                            **
** Parameters(in)   : KernelId  - ADC Kernel to which the group belongs       **
**                    GroupId   - ADC Group ID of the Kernel                  **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
static void Adc_lGrpSequenceHandler(const uint32 KernelId,\
                                const Adc_GroupType GroupId,const uint8 ReqSrc)
{
  Adc_GlobalDataType *lKernelDataPtr;
  const Adc_GroupCfgType *lGrpCfgPtr;
  uint32 lStrmCompletedFlag;

  /* Get group configuration address */
  lGrpCfgPtr=&(Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->GrpCfgPtr[GroupId]);
  /* Get global state data location for the Kernel */
  lKernelDataPtr =  Adc_lGetKernelDataAddress(KernelId);
  lStrmCompletedFlag = Adc_lGetResBuffEndStatus(lKernelDataPtr,GroupId);

  /* Group to be checked for stopping in the RS ISR (Implicit Stop Groups)
    - SW TRIGGGER ONE SHOT
    - HW or SW trigger with LINEAR buffer and Streaming Samples completed */
  if( ((lGrpCfgPtr->TriggerSource == ADC_TRIGG_SRC_SW) &&\
       (lGrpCfgPtr->ConvMode == ADC_CONV_MODE_ONESHOT))||\
      ((lGrpCfgPtr->StreamMode == ADC_STREAM_BUFFER_LINEAR)&&\
       (lStrmCompletedFlag == (uint32)ADC_ONE_U))\
    )
  {
    lKernelDataPtr->RSData[ReqSrc].IsrNoServiceFlag = (uint8)ADC_ONE_U;

    /* SW TRIG ONE SHOT groups are not queued in refill mode,
       hence no need to stop them explicity.*/
    if((lGrpCfgPtr->TriggerSource == ADC_TRIGG_SRC_SW) &&\
       (lGrpCfgPtr->ConvMode == ADC_CONV_MODE_ONESHOT))
    {
      /*Only clearing of Channel and Result registers is sufficient */
      Adc_lClearGroupSfr(lGrpCfgPtr,KernelId);
    }
    else
    {
      /* Stop the conversio, flush the queue, reset registers for groups
         queued in refill mode */
      Adc_lStopConvRequest(lGrpCfgPtr,KernelId);
    }
    /* Clear Kernel Data variable */
    Adc_lRemoveActiveGroup(lKernelDataPtr,lGrpCfgPtr);
    /* Change groups status to not converting, only busy flag is reset.
      Result flags and count are not cleared, since results will be read later
      by application using ReadGroup or GetStreamLastPointer */
    Adc_lClrGroupStatusBusyAtomic(lKernelDataPtr,GroupId);

    #if(ADC_ENABLE_QUEUING == STD_ON)
    /* Remove the group from the queue*/
    Adc_lRemoveFromQueue(lKernelDataPtr,GroupId);

    /* If SW queue has more groups, schedule it for conversion*/
    if(lKernelDataPtr->PopGroupId != ADC_INVALID_GROUP_ID)
    {
      Adc_lScheduleFromQueue(KernelId);
    }
    #endif
  }
}
#endif /* End for ADC_RESULT_HANDLING_IMPLEMENTATION */
#if (ADC_DEV_ERROR_DETECT == STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lInitDetCheck                    **
**                    (                                                       **
**                       const Adc_ConfigType *ConfigPtr                      **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check all the DETs for Adc_Init API  **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : ConfigPtr - Pointer to the config root                  **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lInitDetCheck(const Adc_ConfigType *ConfigPtr)
{
  uint8 lErrVal = ADC_E_NO_ERR;
  if(ConfigPtr == NULL_PTR)
  {
    lErrVal = ADC_E_PARAM_CONFIG;
    Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                    ADC_SID_INIT,ADC_E_PARAM_CONFIG);
  }
  else if(Adc_InitStatus == ADC_INITIALIZED)
  {
    lErrVal = ADC_E_ALREADY_INITIALIZED;
    Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                    ADC_SID_INIT,ADC_E_ALREADY_INITIALIZED);
  }
  else
  {
    /*Do Nothing*/
  }
return(lErrVal);
}
#endif

#if ((ADC_DEV_ERROR_DETECT == STD_ON) &&\
     (ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lSetupResBufDetCheck             **
**                    (                                                       **
**                       const uint32 KernelId                                **
**                       const Adc_GroupType GroupId                          **
**                       const Adc_ValueGroupType *DataBufferPtr              **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check all the DETs for               **
**                   Adc_SetupResultBuffer  API                               **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                    DataBufferPtr - Pointer to the Result Buffer            **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lSetupResBufDetCheck(const uint32 KernelId,\
   const Adc_GroupType GroupId, const Adc_ValueGroupType *DataBufferPtr)
{

  uint8 lErrVal;
  lErrVal = Adc_lCheckUnInitDet(ADC_SID_SETUP_RESULT_BUFFER);
  if(lErrVal == ADC_E_NO_ERR)
  {
    lErrVal = Adc_lCheckParamGrpDet(KernelId,GroupId,\
                                    ADC_SID_SETUP_RESULT_BUFFER);
    if(lErrVal == ADC_E_NO_ERR)
    {
      if(DataBufferPtr == NULL_PTR)
      {
        Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                        ADC_SID_SETUP_RESULT_BUFFER,ADC_E_PARAM_POINTER);
        lErrVal = ADC_E_PARAM_POINTER;
      }
    }
  }
return(lErrVal);
}
#endif
#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_DEINIT_API ==STD_ON))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lDeInitDetCheck                  **
**                    (                                                       **
**                       void                                                 **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check all the DETs for Adc_DeInit API**
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Non-Reentrant                                           **
**                                                                            **
** Parameters(in)   : None                                                    **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lDeInitDetCheck(void)
{
  uint8 lErrVal;
  lErrVal = Adc_lCheckUnInitDet(ADC_SID_DEINIT);
  if(lErrVal == ADC_E_NO_ERR)
  {
    lErrVal = Adc_lCheckGrpBusyDet((uint32)0U,(Adc_GroupType)0U,\
                                                           ADC_SID_DEINIT);
  }
return(lErrVal);
}
#endif
#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_ENABLE_START_STOP_GROUP_API==STD_ON))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lStartGrpConvDetCheck            **
**                    (                                                       **
**                       const uint32 KernelId                                **
**                       const Adc_GroupType GroupId                          **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check all the DETs for               **
**                   Adc_StartGroupConversion API                             **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lStartGrpConvDetCheck(const uint32 KernelId,\
                                             const Adc_GroupType GroupId)
{
  uint8 lErrVal;
  lErrVal = Adc_lCheckUnInitDet(ADC_SID_START_GROUP_CONVERSION);
  if(lErrVal == ADC_E_NO_ERR)
  {
    lErrVal = Adc_lCheckParamGrpDet(KernelId,GroupId,\
                                ADC_SID_START_GROUP_CONVERSION);
    if(lErrVal == ADC_E_NO_ERR)
    {
      lErrVal = Adc_lCheckWrongTrigSrcDet(KernelId,GroupId,\
                               ADC_SID_START_GROUP_CONVERSION);
      #if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
      /* Buffer uninit DET is checked only for NON-DMA modes */
      if(lErrVal == ADC_E_NO_ERR)
      {
        lErrVal = Adc_lCheckBufferUnInitDet(KernelId,GroupId,\
                               ADC_SID_START_GROUP_CONVERSION);
      }
      #endif /*End for ADC_RESULT_HANDLING_IMPLEMENTATION */
    }
  }
return(lErrVal);
}
#endif
#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_ENABLE_START_STOP_GROUP_API==STD_ON))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lStopGrpConvDetCheck             **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const Adc_GroupType GroupId                           **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check all the DETs for               **
**                   Adc_StopGroupConversion API                              **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lStopGrpConvDetCheck(const uint32 KernelId,\
                                            const Adc_GroupType GroupId)
{
  uint8 lErrVal;
  lErrVal = Adc_lCheckUnInitDet(ADC_SID_STOP_GROUP_CONVERSION);
  if(lErrVal == ADC_E_NO_ERR)
  {
    lErrVal = Adc_lCheckParamGrpDet(KernelId,GroupId,\
                                ADC_SID_STOP_GROUP_CONVERSION);
    if(lErrVal == ADC_E_NO_ERR)
    {
      lErrVal = Adc_lCheckWrongTrigSrcDet(KernelId,GroupId,\
                               ADC_SID_STOP_GROUP_CONVERSION);
    }
  }
return(lErrVal);
}
#endif
#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_READ_GROUP_API==STD_ON))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lReadGrpDetCheck                 **
**                    (                                                       **
**                     const uint32 KernelId                                  **
**                     const Adc_GroupType GroupId                            **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check all the DETs for               **
**                   Adc_ReadGroup API                                        **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lReadGrpDetCheck(const uint32 KernelId,\
                                        const Adc_GroupType GroupId)
{
  uint8 lErrVal;
  lErrVal = Adc_lCheckUnInitDet(ADC_SID_READ_GROUP);
  if(lErrVal == ADC_E_NO_ERR)
  {
    lErrVal = Adc_lCheckParamGrpDet(KernelId,GroupId,ADC_SID_READ_GROUP);
  }
return(lErrVal);
}
#endif
#if(ADC_DEV_ERROR_DETECT==STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lGetGrpStatusDetCheck            **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const Adc_GroupType GroupId                           **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check all the DETs for               **
**                   Adc_GetGroupStatus API                                   **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lGetGrpStatusDetCheck(const uint32 KernelId,\
                                             const Adc_GroupType GroupId )
{
  uint8 lErrVal;
  lErrVal = Adc_lCheckUnInitDet(ADC_SID_GET_GROUP_STATUS);
  if(lErrVal == ADC_E_NO_ERR)
  {
    lErrVal = Adc_lCheckParamGrpDet(KernelId,GroupId,ADC_SID_GET_GROUP_STATUS);
  }
return(lErrVal);
}
#endif

#if ((ADC_DEV_ERROR_DETECT == STD_ON) &&\
     (ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lGetStrmPtrDetCheck              **
**                    (                                                       **
**                     const uint32 KernelId                                  **
**                     const Adc_GroupType GroupId                            **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check all the DETs for               **
**                   Adc_GetStreamLastPointer API                             **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lGetStrmPtrDetCheck(const uint32 KernelId,\
                                           const Adc_GroupType GroupId )
{
  uint8 lErrVal;
  lErrVal = Adc_lCheckUnInitDet(ADC_SID_GET_STREAM_LAST_POINTER);
  if(lErrVal == ADC_E_NO_ERR)
  {
    lErrVal = Adc_lCheckParamGrpDet(KernelId,GroupId,\
                                    ADC_SID_GET_STREAM_LAST_POINTER);
  }
return(lErrVal);
}
#endif
#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_GRP_NOTIF_CAPABILITY ==STD_ON))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lEnGrpNotifDetCheck              **
**                    (                                                       **
**                     const uint32 KernelId                                  **
**                     const Adc_GroupType GroupId                            **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check all the DETs for               **
**                   Adc_EnableGroupNotification API                          **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lEnGrpNotifDetCheck(const uint32 KernelId,\
                                           const Adc_GroupType GroupId )
{
  uint8 lErrVal;
  lErrVal = Adc_lCheckUnInitDet(ADC_SID_ENABLE_GROUP_NOTIFICATION);
  if(lErrVal == ADC_E_NO_ERR)
  {
    lErrVal = Adc_lCheckParamGrpDet(KernelId,GroupId,\
                                    ADC_SID_ENABLE_GROUP_NOTIFICATION);
    if(lErrVal == ADC_E_NO_ERR)
    {
      lErrVal = Adc_lCheckNotifCapableDet(KernelId,GroupId,\
                                         ADC_SID_ENABLE_GROUP_NOTIFICATION);
    }
  }
return(lErrVal);
}
#endif
#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_GRP_NOTIF_CAPABILITY ==STD_ON))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lDisGrpNotifDetCheck             **
**                    (                                                       **
**                     const uint32 KernelId                                  **
**                     const Adc_GroupType GroupId                            **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check all the DETs for               **
**                   Adc_DisableGroupNotification API                         **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lDisGrpNotifDetCheck(const uint32 KernelId,\
                                            const Adc_GroupType GroupId )
{
  uint8 lErrVal;
  lErrVal = Adc_lCheckUnInitDet(ADC_SID_DISABLE_GROUP_NOTIFICATION);
  if(lErrVal == ADC_E_NO_ERR)
  {
    lErrVal = Adc_lCheckParamGrpDet(KernelId,GroupId,\
                                    ADC_SID_DISABLE_GROUP_NOTIFICATION);
    if(lErrVal == ADC_E_NO_ERR)
    {
      lErrVal = Adc_lCheckNotifCapableDet(KernelId,GroupId,\
                                         ADC_SID_DISABLE_GROUP_NOTIFICATION);
    }
  }
return(lErrVal);
}
#endif
#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_HW_TRIGGER_API==STD_ON))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lEnHwTriggerDetCheck             **
**                    (                                                       **
**                       const uint32 KernelId                                **
**                       const Adc_GroupType GroupId                          **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check all the DETs for               **
**                   Adc_EnableHardwareTrigger  API                           **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lEnHwTriggerDetCheck(const uint32 KernelId,\
                                            const Adc_GroupType GroupId )
{
  uint8 lErrVal;
  lErrVal = Adc_lCheckUnInitDet(ADC_SID_ENABLE_HARDWARE_TRIGGER);
  if(lErrVal == ADC_E_NO_ERR)
  {
    lErrVal = Adc_lCheckParamGrpDet(KernelId,GroupId,\
                                ADC_SID_ENABLE_HARDWARE_TRIGGER);
    if(lErrVal == ADC_E_NO_ERR)
    {
      lErrVal = Adc_lCheckWrongTrigSrcDet(KernelId,GroupId,\
                               ADC_SID_ENABLE_HARDWARE_TRIGGER);
      if(lErrVal == ADC_E_NO_ERR)
      {
        #if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
        /* Buffer uninit DET is checked only for NON-DMA modes */
        lErrVal = Adc_lCheckBufferUnInitDet(KernelId,GroupId,\
                               ADC_SID_ENABLE_HARDWARE_TRIGGER);
        if(lErrVal == ADC_E_NO_ERR)
        #endif /* End for ADC_RESULT_HANDLING_IMPLEMENTATION */
        {
          lErrVal = Adc_lCheckWrongConvModeDet(KernelId,GroupId,\
                                 ADC_SID_ENABLE_HARDWARE_TRIGGER);
        }
      }
    }
  }
return(lErrVal);
}
#endif
#if((ADC_DEV_ERROR_DETECT==STD_ON)&&(ADC_HW_TRIGGER_API==STD_ON))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lDisHwTriggerDetCheck            **
**                    (                                                       **
**                     const uint32 KernelId                                  **
**                     const Adc_GroupType GroupId                            **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check all the DETs for               **
**                   Adc_DisableHardwareTrigger  API                          **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lDisHwTriggerDetCheck(const uint32 KernelId,\
                                             const Adc_GroupType GroupId )
{
  uint8 lErrVal;
  lErrVal = Adc_lCheckUnInitDet(ADC_SID_DISABLE_HARDWARE_TRIGGER);
  if(lErrVal == ADC_E_NO_ERR)
  {
    lErrVal = Adc_lCheckParamGrpDet(KernelId,GroupId,\
                                ADC_SID_DISABLE_HARDWARE_TRIGGER);
    if(lErrVal == ADC_E_NO_ERR)
    {
      lErrVal = Adc_lCheckWrongTrigSrcDet(KernelId,GroupId,\
                               ADC_SID_DISABLE_HARDWARE_TRIGGER);
      if(lErrVal == ADC_E_NO_ERR)
      {
        lErrVal = Adc_lCheckWrongConvModeDet(KernelId,GroupId,\
                              ADC_SID_DISABLE_HARDWARE_TRIGGER);
      }
    }
  }
return(lErrVal);
}
#endif

#if(ADC_DEV_ERROR_DETECT==STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lCheckUnInitDet                  **
**                    (                                                       **
**                      const uint8 ServiceId                                 **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check ADC_E_UNINIT DET for the       **
**                   ServiceId(API).                                          **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : ServiceId - Serive ID of the API                        **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lCheckUnInitDet(const uint8 ServiceId)
{
  uint8 lErrVal = ADC_E_NO_ERR;
  /* Check for Unitialized condition */
  if((Adc_InitStatus != ADC_INITIALIZED) ||
     (Adc_kConfigPtr == NULL_PTR))
  {
    Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                    ServiceId,ADC_E_UNINIT);
    lErrVal = ADC_E_UNINIT;
  }
return(lErrVal);
}
#endif
#if(ADC_DEV_ERROR_DETECT==STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lCheckParamGrpDet                **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const Adc_GroupType GroupId                           **
**                      const uint8 ServiceId                                 **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check ADC_E_PARAM_GROUP DET for the  **
**                   ServiceId(API).                                          **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                    ServiceId - Serive ID of the API                        **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lCheckParamGrpDet(const uint32 KernelId,\
                    const Adc_GroupType GroupId, const uint8 ServiceId)
{
  uint8 lErrVal;
  /*Check if the Kernel ID is less tha max kernel ID available in the device*/
  if(KernelId >= ADC_MAX_KERNEL_ID)
  {
    lErrVal = ADC_E_PARAM_GROUP;
  }
  /*Check if the kernel is configured during the Adc_Init */
  else if(Adc_kConfigPtr->HwUnitCfgPtr[KernelId] == NULL_PTR)
  {
    lErrVal = ADC_E_PARAM_GROUP;
  }
  /* Check if the Group ID is >= the groups configured for this kernel*/
  else if(GroupId >= (Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->NoOfGroups))
  {
    lErrVal = ADC_E_PARAM_GROUP;
  }
  else
  {
    lErrVal = ADC_E_NO_ERR;
  }

  if(lErrVal != ADC_E_NO_ERR)
  {
    Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                     ServiceId,ADC_E_PARAM_GROUP);
  }
  else
  {
    /* Do Nothing */
  }
return(lErrVal);
}
#endif
#if(ADC_DEV_ERROR_DETECT==STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lCheckWrongTrigSrcDet            **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const Adc_GroupType GroupId                           **
**                      const uint8 ServiceId                                 **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check ADC_E_WRONG_TRIGG_SRC DET for  **
**                   the ServiceId(API).                                      **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                    ServiceId - Serive ID of the API                        **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lCheckWrongTrigSrcDet(const uint32 KernelId,\
                           const Adc_GroupType GroupId, const uint8 ServiceId)
{
  Adc_TriggerSourceType lTrigSrc;
  uint8 lErrVal;
  lErrVal = ADC_E_NO_ERR;
  lTrigSrc = Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->\
                                      GrpCfgPtr[GroupId].TriggerSource;

  if((ServiceId == ADC_SID_START_GROUP_CONVERSION)||\
     (ServiceId == ADC_SID_STOP_GROUP_CONVERSION))
  {
    /* Check if the Triger Source is SW */
    if(lTrigSrc != ADC_TRIGG_SRC_SW)
    {
      Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                       ServiceId,ADC_E_WRONG_TRIGG_SRC);
      lErrVal = ADC_E_WRONG_TRIGG_SRC;
    }
  }
  else if((ServiceId == ADC_SID_ENABLE_HARDWARE_TRIGGER)||\
          (ServiceId == ADC_SID_DISABLE_HARDWARE_TRIGGER))
  {
    /* Check if the Triger Source is HW */
    if(lTrigSrc != ADC_TRIGG_SRC_HW)
    {
      Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                       ServiceId,ADC_E_WRONG_TRIGG_SRC);
      lErrVal = ADC_E_WRONG_TRIGG_SRC;
    }
  }
  else
  {
    lErrVal = ADC_E_WRONG_TRIGG_SRC;
  }
return(lErrVal);
}
#endif
#if((ADC_DEV_ERROR_DETECT==STD_ON) && \
    (ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lCheckBufferUnInitDet            **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const Adc_GroupType GroupId                           **
**                      const uint8 ServiceId                                 **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check ADC_E_BUFFER_UNINIT DET for the**
**                   ServiceId(API).                                          **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                    ServiceId - Serive ID of the API                        **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lCheckBufferUnInitDet(const uint32 KernelId,\
                       const Adc_GroupType GroupId, const uint8 ServiceId)
{
  const Adc_GlobalDataType *lKernelDataPtr;
  uint8 lErrVal = ADC_E_NO_ERR;

  /* Get global state data location for the Kernel */
  lKernelDataPtr = Adc_lGetKernelDataAddress(KernelId);

  /*Check if the buffer location for storing the conversion results is NULL*/
  if(lKernelDataPtr->GrpResBuffer[GroupId] == NULL_PTR)
  {
    Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                    ServiceId,ADC_E_BUFFER_UNINIT);
    lErrVal = ADC_E_BUFFER_UNINIT;
  }
return(lErrVal);
}
#endif
#if(ADC_DEV_ERROR_DETECT==STD_ON)
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lCheckGrpIdleDet                 **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const Adc_GroupType GroupId                           **
**                      const uint8 ServiceId                                 **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check ADC_E_IDLE DET for             **
**                   the ServiceId(API).                                      **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                    ServiceId - Serive ID of the API                        **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lCheckGrpIdleDet(const uint32 KernelId,\
                        const Adc_GroupType GroupId, const uint8 ServiceId)
{
  const Adc_GlobalDataType *lKernelDataPtr;
  uint32 lBusyFlag,lResultFlag;
  uint8 lErrVal = ADC_E_NO_ERR;

  /* Get global state data location for the Kernel */
  lKernelDataPtr = Adc_lGetKernelDataAddress(KernelId);

  lBusyFlag = Adc_lGetGroupStatus(lKernelDataPtr,GroupId);
  lResultFlag = Adc_lGetGroupResultStatus(lKernelDataPtr,GroupId);

  /* Check if Group has Stopped and not even 1 results set avaialble,
    - Group was never started OR
    - Group has implictly stopped and results are already read */
  if( (lBusyFlag == (uint32)0U)&&(lResultFlag == (uint32)0U) )
  {
    Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                     ServiceId,ADC_E_IDLE);
    lErrVal = ADC_E_IDLE;
  }

return(lErrVal);
}
#endif

#if(ADC_DEV_ERROR_DETECT==STD_ON)
/*CYCLOMATIC_Adc_lCheckGrpBusyDet_JUSTIFICATION: This Function has cyclomatic 
Complexity of 17 because it uses switch case, breaking the switch case in two 
functions will impact the readability. 
*/
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lCheckGrpBusyDet                 **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const Adc_GroupType GroupId                           **
**                      const uint8 ServiceId                                 **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check ADC_E_BUSY DET for             **
**                   the ServiceId(API).                                      **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                    ServiceId - Serive ID of the API                        **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lCheckGrpBusyDet(const uint32 KernelId,\
                            const Adc_GroupType GroupId, const uint8 ServiceId)
{
  const Adc_GlobalDataType *lKernelDataPtr;
  uint8 lErrVal = ADC_E_NO_ERR;

  /* Get global state data location for the Kernel */
  lKernelDataPtr = Adc_lGetKernelDataAddress(KernelId);

  switch (ServiceId)
  {
    case ADC_SID_DEINIT:
    {
      if(Adc_lGetAllGroupStatus() != (uint32)0U)
      {
        Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                        ADC_SID_DEINIT,ADC_E_BUSY);
        lErrVal = ADC_E_BUSY;
      }
    }
    break;
    #if(ADC_RESULT_HANDLING_IMPLEMENTATION != ADC_DMA_MODE_RESULT_HANDLING)
    case ADC_SID_SETUP_RESULT_BUFFER:
    {
      uint32 lResultFlag,lBusyFlag;
      lResultFlag = Adc_lGetGroupResultStatus(lKernelDataPtr,GroupId);
      lBusyFlag = Adc_lGetGroupStatus(lKernelDataPtr,GroupId);
      /*Check if group is BUSY, currently converting
      OR group has implictly stopped with valid results available in buffer.
      Since results are available in buffer, the new buffer address should not
      be updated, because a ReadGroup call after this would read results from
      unknown location*/
      if((lBusyFlag == (uint32)ADC_ONE_U ) ||\
         (lResultFlag == (uint32)ADC_ONE_U))
      {
        Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                        ADC_SID_SETUP_RESULT_BUFFER,ADC_E_BUSY);
        lErrVal = ADC_E_BUSY;
      }
    }
    break;
    #endif/* End for ADC_RESULT_HANDLING_IMPLEMENTATION */
    case ADC_SID_START_GROUP_CONVERSION:
    {
      #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW)
      /* FOR HW_PRIORITY MODE */
      uint8 lReqSrc;
      uint16 lChannelMask,lResRegMask;

      lReqSrc = Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->GrpCfgPtr[GroupId].\
                                                                   GrpReqSrc;
      lChannelMask = Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->\
                                           GrpCfgPtr[GroupId].ChannelMask;
      lResRegMask = Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->\
                                   GrpCfgPtr[GroupId].ResultRegMask;
      /*Raise Busy DET, if RS is already running or any channel/result register
        of the group is already running on another request source */
      if((lKernelDataPtr->RSData[lReqSrc].ActiveGroupId !=\
                                                    ADC_INVALID_GROUP_ID)||\
         ((lKernelDataPtr->AllRunningChannels & lChannelMask) != (uint16)0U)||\
         ((lKernelDataPtr->AllRunningResReg & lResRegMask)    != (uint16)0U) )
      #elif(ADC_ENABLE_QUEUING == STD_ON)
      /* FOR QUEUING MODE */
      /*Check if the groups is already in the queue*/
      if(Adc_lGetGroupStatus(lKernelDataPtr,GroupId) == (uint32)ADC_ONE_U )
      #else
      /* FOR NO PRIORITY MODE */
      /*Check if all groups for the kernel is currently IDLE */
      if((lKernelDataPtr->GrpStatus) != (uint32)0U)
      #endif
      {
        Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                        ADC_SID_START_GROUP_CONVERSION,ADC_E_BUSY);
        lErrVal = ADC_E_BUSY;
      }
    }
    break;
    case ADC_SID_ENABLE_HARDWARE_TRIGGER:
    {
      #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW)
      /* FOR HW_PRIORITY MODE */
      uint8 lReqSrc;
      uint16 lChannelMask,lResRegMask;
      lReqSrc = Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->GrpCfgPtr[GroupId].\
                                                                   GrpReqSrc;
      lChannelMask = Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->\
                                           GrpCfgPtr[GroupId].ChannelMask;
      lResRegMask = Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->\
                                   GrpCfgPtr[GroupId].ResultRegMask;
      /*Raise Busy DET, if RS is already running or any channel/result register
        of the group is already running on another request source */
      if((lKernelDataPtr->RSData[lReqSrc].ActiveGroupId !=\
                                                     ADC_INVALID_GROUP_ID)||\
         ((lKernelDataPtr->AllRunningChannels & lChannelMask) !=(uint16)0U)||\
         ((lKernelDataPtr->AllRunningResReg & lResRegMask) != (uint16)0U) )
      #else
      /*FOR NO_PRIORITY AND QUEUING MODE*/
      /*Check if all groups for the kernel is currently IDLE,
        HW triggered groups can only be started if no other groups are
        running / queue is empty  */
      if((lKernelDataPtr->GrpStatus) != (uint32)0U)
      #endif
      {
        Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                        ADC_SID_ENABLE_HARDWARE_TRIGGER,ADC_E_BUSY);
        lErrVal = ADC_E_BUSY;
      }
    }
    break;
    default:
    /*Do nothing*/
    break;
  }
return(lErrVal);
 /* MISRA2012_RULE_2_7_JUSTIFICATION:Parameter GroupId used based on 
    configuration chosen.*/
}
#endif


#if((ADC_DEV_ERROR_DETECT==STD_ON )&&(ADC_GRP_NOTIF_CAPABILITY ==STD_ON))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lCheckNotifCapableDet            **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const Adc_GroupType GroupId                           **
**                      const uint8 ServiceId                                 **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check ADC_E_NOTIF_CAPABILITY DET for **
**                   the ServiceId(API).                                      **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                    ServiceId - Serive ID of the API                        **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lCheckNotifCapableDet(const uint32 KernelId,\
                           const Adc_GroupType GroupId, const uint8 ServiceId)
{
  uint8 lErrVal = ADC_E_NO_ERR;
  Adc_NotifyFnPtrType lNotificationFn;

  lNotificationFn = Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->\
                                             GrpCfgPtr[GroupId].NotifyPtr;
  /* Check the notification function ptr is NULL  */
  if((Adc_NotifyFnPtrType)0U == lNotificationFn)
  {
    Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                     ServiceId,ADC_E_NOTIF_CAPABILITY);
    lErrVal = ADC_E_NOTIF_CAPABILITY;
  }
return(lErrVal);
}
#endif

#if((ADC_DEV_ERROR_DETECT==STD_ON )&&(ADC_HW_TRIGGER_API==STD_ON))
/*******************************************************************************
** Traceability: [cover parentID]                                             **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Adc_lCheckWrongConvModeDet           **
**                    (                                                       **
**                      const uint32 KernelId                                 **
**                      const Adc_GroupType GroupId                           **
**                      const uint8 ServiceId                                 **
**                    )                                                       **
**                                                                            **
** Description      :This function is to check ADC_E_WRONG_CONV_MODE DET for  **
**                   the ServiceId(API).                                      **
** [/cover]                                                                   **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Re-Entrant                                              **
**                                                                            **
** Parameters(in)   : KernelId - Kernel ID                                    **
**                    GroupId - Group ID for the Kernel                       **
**                    ServiceId - Serive ID of the API                        **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Error ID                                                **
**                                                                            **
*******************************************************************************/
LOCAL_INLINE uint8 Adc_lCheckWrongConvModeDet(const uint32 KernelId,\
                       const Adc_GroupType GroupId, const uint8 ServiceId)
{
  uint8 lErrVal = ADC_E_NO_ERR;
  Adc_GroupConvModeType lConversionMode;

  lConversionMode = Adc_kConfigPtr->HwUnitCfgPtr[KernelId]->\
                                       GrpCfgPtr[GroupId].ConvMode;
  /*Continuous conversion mode is not valid for HW Conversions*/
  if(lConversionMode == ADC_CONV_MODE_CONTINUOUS)
  {
    Det_ReportError(ADC_MODULE_ID,ADC_MODULE_INSTANCE,\
                     ServiceId,ADC_E_WRONG_CONV_MODE);
    lErrVal = ADC_E_WRONG_CONV_MODE;
  }
return(lErrVal);
}
#endif

#define ADC_STOP_SEC_CODE_QM_GLOBAL
/* MISRA2012_RULE_20_1_JUSTIFICATION: Memmap header usage as per Autosar
   guideline. */
/* MISRA2012_RULE_4_10_JUSTIFICATION: Memmap header is repeatedly included
   without safegaurd. It complies to Autosar guidelines. */
#include "Adc_MemMap.h"

