/*******************************************************************************
**                                                                            **
** Copyright (C) Infineon Technologies (2016)                                 **
**                                                                            **
** All rights reserved.                                                       **
**                                                                            **
** This document contains proprietary information belonging to Infineon       **
** Technologies. Passing on and copying of this document, and communication   **
** of its contents is not permitted without prior written authorization.      **
**                                                                            **
********************************************************************************
**                                                                            **
**  FILENAME     : GtmLib.c                                                   **
**                                                                            **
**  VERSION      : 4.0.0                                                      **
**                                                                            **
**  DATE         : 2017-02-21                                                 **
**                                                                            **
**  VARIANT      : Variant PC                                                 **
**                                                                            **
**  PLATFORM     : Infineon AURIX2G                                           **
**                                                                            **
**  AUTHOR       : DL-AUTOSAR-Engineering                                     **
**                                                                            **
**  VENDOR       : Infineon Technologies                                      **
**                                                                            **
**  DESCRIPTION  : GTM Library source file                                    **
**                                                                            **
**  SPECIFICATION(S) : NA                                                     **
**                                                                            **
**  MAY BE CHANGED BY USER : no                                               **
**                                                                            **
*******************************************************************************/

/*******************************************************************************
**                      Includes                                              **
*******************************************************************************/

#include "GtmLib.h"
#include "Schm_McalLib.h"
#include "IfxGtm_bf.h"


/*******************************************************************************
**                      Imported Compiler Switch Check                        **
*******************************************************************************/


/*******************************************************************************
**                      Private Macro Definitions                             **
*******************************************************************************/

#define GTM_ONE_U                             (0x1U)
#define GTM_ZERO_U                            (0x0U)
#define GTM_CH_NO_USER                        (0x0U)
#define MCAL_BIT_POS_8                        (0x8U)

/* Macros for GTM ICM registers */
#define GTM_TIM_ICM_BASE_ADDRESS              (&GTM_ICM_IRQG_2)
#define GTM_TOM_ICM_BASE_ADDRESS              (&GTM_ICM_IRQG_6)
#define GTM_ATOM_ICM_BASE_ADDRESS             (&GTM_ICM_IRQG_9)

#define GTM_BIT_SET                           (0x1U)
#define GTM_GET_TIM_INT_STATUS                (0x1U)
#define GTM_GET_TOM_INT_STATUS                (0x3U)
#define GTM_GET_ATOM_INT_STATUS               (0x3U)

/* Macros related to GTM timer user data table */
#define MCAL_USER_ID_MSK                      (0xFFU)
#define MCAL_LOG_CH_ID_MSK                    (0xFFU)
#define MCAL_LOG_CH_ID_BITPOS                 (0x8U)  /* Bit position 8 */
#define MCAL_CPU_ID_BITPOS                    (0x10U) /* Bit position 16 */


#define GTM_ATOM_CH_USERDATA_EMPTY            (0xFFFFFFFFU)
#define GTM_ATOM_MODULES_IN_ICM_REG           (0x4U)
#define GTM_CHANNELS_PER_ATOM_MODULE          (GTM_NO_OF_ATOM_CHANNELS)


#define GTM_TIM_CH_USERDATA_EMPTY             (0xFFFFFFFFU)
#define GTM_TIM_MODULES_IN_ICM_REG            (0x4U)
#define GTM_CHANNELS_PER_TIM_MODULE           (GTM_NO_OF_TIM_CHANNELS)

#define GTM_TOM_CH_USERDATA_EMPTY             (0xFFFFFFFFU)
#define GTM_TOM_MODULES_IN_ICM_REG            (0x2U)
#define GTM_CHANNELS_PER_TOM_MODULE           (GTM_NO_OF_TOM_CHANNELS)

/* MISRA2012_RULE_4_9_JUSTIFICATION: Function like macro
 * 'GTM_TOM_CH_POINTER' defined for easy readability in code.
 * No side effects foreseen by violating this MISRA rule. */

/* Macro to get the TOM channel base address*/
#define GTM_TOM_CH_POINTER(Module,Channel) \
               (&((*(Ifx_GTM_TOMx*)(volatile void *)(MODULE_GTM.TOM)).\
                                        TOM_CH[(Module)].CH[(Channel)]))

/* MISRA2012_RULE_4_9_JUSTIFICATION: Function like macro
 * 'GTM_TOM_TGC_POINTER' defined for easy readability in code.
 * No side effects foreseen by violating this MISRA rule. */

/* Macro to get the TOM TGCx base address*/
#define GTM_TOM_TGC_POINTER(Module,TomTgcIndex) \
               (&((*(Ifx_GTM_TOMx*)(volatile void*)(MODULE_GTM.TOM)).\
                                        TOM_TGC[(Module)].TGC[(TomTgcIndex)]))
/* MISRA2012_RULE_4_9_JUSTIFICATION: Function like macro
 * 'GTM_ATOM_CH_POINTER' defined for easy readability in code.
 * No side effects foreseen by violating this MISRA rule. */

/* Macro to get the ATOM channel base address*/
#define GTM_ATOM_CH_POINTER(Module,Channel) \
               (&((*(Ifx_GTM_ATOMx*)(volatile void *)(MODULE_GTM.ATOM)).\
                                        ATOM_CH[(Module)].CH[(Channel)]))

/* MISRA2012_RULE_4_9_JUSTIFICATION: Function like macro
 * 'GTM_ATOM_AGC_POINTER' defined for easy readability in code.
 * No side effects foreseen by violating this MISRA rule. */

/* Macro to get the ATOM AGC base address*/
#define GTM_ATOM_AGC_POINTER(Module) \
               (&((*(Ifx_GTM_ATOMx*)(volatile void*)(MODULE_GTM.ATOM)).\
                                       ATOM_AGC[(Module)]))

/* MISRA2012_RULE_4_9_JUSTIFICATION: Function like macro
 * 'GTM_TIM_CH_POINTER' defined for easy readability in code.
 * No side effects foreseen by violating this MISRA rule. */

/* Macro to get the TIM channel base address*/
#define GTM_TIM_CH_POINTER(Module,Channel) \
               (&((*(Ifx_GTM_TIMx*)(volatile void *)(MODULE_GTM.TIM)).\
                                          CH_TIM[(Module)].CH[(Channel)]))

/* MISRA2012_RULE_4_9_JUSTIFICATION: Function like macro
 * 'GTM_TIM_MODULE_RST_POINTER' defined for easy readability in code.
 * No side effects foreseen by violating this MISRA rule. */

/* Macro to get the TIM module reset register address*/
#define GTM_TIM_MODULE_RST_POINTER(Module) \
             (&((*(Ifx_GTM_TIMx*)(volatile void *)(MODULE_GTM.TIM)).\
                                          TIM_RST[(Module)]))

/*******************************************************************************
**                      Private Variable Definitions                          **
*******************************************************************************/

#define MCALLIB_START_SEC_VAR_INIT_QM_LOCAL_32
/* MISRA2012_RULE_4_10_JUSTIFICATION: 'McalLib_MemMap.h' is header file which
 * contains the memory sections for McalLib. It should not be guarded by
 * standard include. No side effects foreseen by violating this MISRA rule. */
#include "McalLib_MemMap.h"

static uint32 \
         Mcal_GtmTimChUserData[GTM_NO_OF_TIM_MODULES][GTM_NO_OF_TIM_CHANNELS] =
{
  /* TIM 0*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* TIM 1*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* TIM 2*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* TIM 3*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
   /* TIM 4*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* TIM 5*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* TIM 6*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* TIM 7*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY}
};

static uint32 \
         Mcal_GtmTomChUserData[GTM_NO_OF_TOM_MODULES][GTM_NO_OF_TOM_CHANNELS] =
{
  /* TOM 0*/
  {GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY},
  /* TOM 1*/
  {GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY},
  /* TOM 2*/
  {GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY},
  /* TOM 3*/
  {GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY},
  /* TOM 4*/
  {GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY},
    /* TOM 5*/
  {GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY,\
   GTM_TOM_CH_USERDATA_EMPTY,GTM_TOM_CH_USERDATA_EMPTY}

};


static uint32
   Mcal_GtmAtomChUserData[GTM_NO_OF_ATOM_MODULES][GTM_NO_OF_ATOM_CHANNELS] =
{
  /* ATOM 0*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* ATOM 1*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* ATOM 2*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* ATOM 3*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
   /* ATOM 4*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* ATOM 5*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* ATOM 6*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* ATOM 7*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
   /* ATOM 8*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* ATOM 9*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* ATOM 10*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY},
  /* ATOM 11*/
  {GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY,\
   GTM_TIM_CH_USERDATA_EMPTY,GTM_TIM_CH_USERDATA_EMPTY}
};

#define MCALLIB_STOP_SEC_VAR_INIT_QM_LOCAL_32
/* MISRA2012_RULE_4_10_JUSTIFICATION: 'McalLib_MemMap.h' is header file which
 * contains the memory sections for McalLib. It should not be guarded by
 * standard include. No side effects foreseen by violating this MISRA rule. */

/* MISRA2012_RULE_20_1_JUSTIFICATION: variable 'Mcal_GtmTimChUserData'
 * declared before MemMap header file. This variable needs to be placed in a
 * appropriate memory section. No side effects foreseen by violating
 * this MISRA rule */

#include "McalLib_MemMap.h"

/*******************************************************************************
**                      Private Constant Definitions                          **
*******************************************************************************/

#define MCALLIB_START_SEC_CONST_QM_UNSPECIFIED
/* MISRA2012_RULE_4_10_JUSTIFICATION: 'McalLib_MemMap.h' is header file which
 * contains the memory sections for McalLib. It should not be guarded by
 * standard include. No side effects foreseen by violating this MISRA rule. */

/* MISRA2012_RULE_20_1_JUSTIFICATION: variable 'Mcal_GtmTimChUserData'
 * declared before MemMap header file. This variable needs to be placed in a
 * appropriate memory section. No side effects foreseen by violating
 * this MISRA rule */
#include "McalLib_MemMap.h"

static const Mcal_GtmCallbackFuncPtrType \
                           Mcal_DriversFuncCallbackList[GTM_NO_OF_CALLBACK] =
{
  GTM_ADC_CALLBACK_NOTIF,
  GTM_WDG_CALLBACK_NOTIF,
  GTM_PWM_CALLBACK_NOTIF,
  GTM_GPT_CALLBACK_NOTIF,
  GTM_ICU_CALLBACK_NOTIF,
  GTM_OCU_CALLBACK_NOTIF,
  GTM_DSADC_CALLBACK_NOTIF
};

#define MCALLIB_STOP_SEC_CONST_QM_UNSPECIFIED
/* MISRA2012_RULE_4_10_JUSTIFICATION: 'McalLib_MemMap.h' is header file which
 * contains the memory sections for McalLib. It should not be guarded by
 * standard include. No side effects foreseen by violating this MISRA rule. */

/* MISRA2012_RULE_20_1_JUSTIFICATION: variable 'Mcal_GtmTimChUserData'
 * declared before MemMap header file. This variable needs to be placed in a
 * appropriate memory section. No side effects foreseen by violating
 * this MISRA rule */
#include "McalLib_MemMap.h"


/*******************************************************************************
**                      Private Type Definitions                              **
*******************************************************************************/

/*******************************************************************************
**                      Private Function Declarations                         **
*******************************************************************************/

#define MCALLIB_START_SEC_CODE_QM_GLOBAL
/* MISRA2012_RULE_4_10_JUSTIFICATION: 'McalLib_MemMap.h' is header file which
 * contains the memory sections for McalLib. It should not be guarded by
 * standard include. No side effects foreseen by violating this MISRA rule. */

/* MISRA2012_RULE_20_1_JUSTIFICATION: variable 'Mcal_GtmTimChUserData'
 * declared before MemMap header file. This variable needs to be placed in a
 * appropriate memory section. No side effects foreseen by violating
 * this MISRA rule */
#include "McalLib_MemMap.h"

LOCAL_INLINE uint8 Mcal_lGtmGetTimIrqStatus(uint8 Module,\
  uint8 Channel);

LOCAL_INLINE uint8 Mcal_lGtmGetTomIrqStatus(uint8 Module,
  uint8 Channel);

LOCAL_INLINE uint8 Mcal_lGtmGetAtomIrqStatus(uint8 Module,
  uint8 Channel);

LOCAL_INLINE uint8 Mcal_lGtmGetIntSource(uint32 Value, uint8 Index);

#define MCALLIB_STOP_SEC_CODE_QM_GLOBAL
/* MISRA2012_RULE_4_10_JUSTIFICATION: 'McalLib_MemMap.h' is header file which
 * contains the memory sections for McalLib. It should not be guarded by
 * standard include. No side effects foreseen by violating this MISRA rule. */

/* MISRA2012_RULE_20_1_JUSTIFICATION: variable 'Mcal_GtmTimChUserData'
 * declared before MemMap header file. This variable needs to be placed in a
 * appropriate memory section. No side effects foreseen by violating
 * this MISRA rule */
#include "McalLib_MemMap.h"


/*******************************************************************************
**                      Global Constant Definitions                           **
*******************************************************************************/

/*******************************************************************************
**                      Global Variable Definitions                           **
*******************************************************************************/


/*******************************************************************************
**                      Global Function Definitions                           **
*******************************************************************************/

#define MCALLIB_START_SEC_CODE_QM_GLOBAL
/* MISRA2012_RULE_4_10_JUSTIFICATION: 'McalLib_MemMap.h' is header file which
 * contains the memory sections for McalLib. It should not be guarded by
 * standard include. No side effects foreseen by violating this MISRA rule. */

/* MISRA2012_RULE_20_1_JUSTIFICATION: variable 'Mcal_GtmTimChUserData'
 * declared before MemMap header file. This variable needs to be placed in a
 * appropriate memory section. No side effects foreseen by violating
 * this MISRA rule */
#include "McalLib_MemMap.h"


/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmTomChannelInit                             **
**                    (                                                       **
**                     const Mcal_GtmTomChConfigType *ConfigPtr               **
**                    )                                                       **
**                                                                            **
** Description      : This interface configures an instance of TOM channel.   **
**                    Consumer of a TOM channel invokes this interface at the **
**                    time of channel initialization.                         **
**                                                                            **
** Service ID       : 0x15                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : ConfigPtr - Pointer to configuration data of a          **
**                    TOM channel                                             **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
void Mcal_GtmTomChannelInit(const Mcal_GtmTomChConfigType *ConfigPtr)
{
  uint8 Module;
  uint8 Channel;
  Ifx_GTM_TOM_CH_TYPE *TomChannelRegPtr; /* Pointer to TOM channel Register */


  /* Retrieve the TOM module index value */
  Module = ConfigPtr->TimerId.TimerModuleNumber;

  /* Retrieve the TOM module channel number */
  Channel = ConfigPtr->TimerId.TimerChannelNumber;

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TomChannelRegPtr = GTM_TOM_CH_POINTER(Module,Channel);

  /* Clear any pending interrupts associated with TOM channel register */
  TomChannelRegPtr->IRQ_NOTIFY.U = GTM_TOM_CLR_PENDING_IRQ;

  /* Disable all TOM interrupts */
  TomChannelRegPtr->IRQ_EN.U = GTM_TOM_REG_RESET;

  /* Configure the TOM Channel control register */
  TomChannelRegPtr->CTRL.U = ConfigPtr->TimerChCtrlReg;

  /* Configure the TOM Channel CCU0 counter register */
  TomChannelRegPtr->CN0.U = ConfigPtr->TimerChCN0Reg;

  /* Configure the TOM Channel CCU0 compare register */
  TomChannelRegPtr->CM0.U = ConfigPtr->TimerChCM0Reg;

  /* Configure the TOM Channel CCU1 compare register */
  TomChannelRegPtr->CM1.U = ConfigPtr->TimerChCM1Reg;

  /* Configure the TOM Channel CCU0 compare shadow register */
  TomChannelRegPtr->SR0.U = ConfigPtr->TimerChSR0Reg;

  /* Configure the TOM Channel CCU1 compare shadow register */
  TomChannelRegPtr->SR1.U = ConfigPtr->TimerChSR1Reg;

  /* Configure the Interrupt mode of  TOM Channel register */
  TomChannelRegPtr->IRQ_MODE.U = \
         (((uint32)ConfigPtr->TimerChIntEnMode >> GTM_TOM_IRQ_MODE_POS) \
         & (uint32)IFX_GTM_TOM_CH_IRQ_MODE_IRQ_MODE_MSK);

  /* Enable the interrupts associated with TOM Channel register */
  TomChannelRegPtr->IRQ_EN.U = \
      ((uint32)ConfigPtr->TimerChIntEnMode & (uint32)GTM_TOM_IRQ_EN_REG_MSK);

  /* Update the TOM user data table */
  Mcal_GtmTomChUserData[Module][Channel] = \
    (((uint32)ConfigPtr->TimerId.CpuId << (uint32)MCAL_CPU_ID_BITPOS) | \
    ((uint32)ConfigPtr->TimerId.UserChLogicalChannelId << \
                                            (uint32)MCAL_LOG_CH_ID_BITPOS) | \
    ((uint32)ConfigPtr->TimerId.TimerChUserId));

}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmTomChannelShadowTransfer                   **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
** Description      : This interface is used to initiate a copy of values in  **
**                    shadow registers, Compare values (duty, period) and     **
**                    Clock Source, of the specified TOM channel to its main  **
**                    timer registers.                                        **
**                                                                            **
** Service ID       : 0x16                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant                                           **
**                                                                            **
** Parameters(in)   : Module - TOM Module ID                                  **
**                    Channel - TOM Channel ID                                **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/

void Mcal_GtmTomChannelShadowTransfer(uint8 Module, uint8 Channel)
{
  uint8 TomTgcIndex = (uint8)(Channel/(uint8)GTM_TOM_CH_PER_TGC);
  uint32 EndisCtrlBackup;
  uint32 OutenCtrlBackup;
  uint32 FupdCtrlBackup;
  uint32 FupdDisableCh;
  Ifx_GTM_TOM_TGC_TYPE* TomTgcRegPtr;

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TomTgcRegPtr = GTM_TOM_TGC_POINTER(Module,TomTgcIndex);

  /* Enter critical section */
  SchM_Enter_McalLib_TomTgcReg();

  /* Backup of ENDIS_CTRL, OUTEN_CTRL and FUPD_CTRL registers */
  EndisCtrlBackup = TomTgcRegPtr->ENDIS_CTRL.U;
  OutenCtrlBackup = TomTgcRegPtr->OUTEN_CTRL.U;
  FupdCtrlBackup = TomTgcRegPtr->FUPD_CTRL.U;

  /* Disable the update of ENDIS_STAT and OUTEN_STAT on a trigger */
  TomTgcRegPtr->ENDIS_CTRL.U = GTM_TOM_DISABLE_STAT_UPDATE;
  TomTgcRegPtr->OUTEN_CTRL.U = GTM_TOM_DISABLE_STAT_UPDATE;

  /* Disable the Reset CN0 and force update of all channels */
  TomTgcRegPtr->FUPD_CTRL.U = GTM_DISABLE_RSTCN0_FUPD;

  /* Enable force update of CM0, CM1 and CRK_SRC registers for the
   * input TOM channel */
  TomTgcRegPtr->FUPD_CTRL.U = \
      ((uint32)GTM_TOM_FORCE_UPDATE_ENABLE << \
      ((uint32)GTM_TOM_BITS_PER_CHAN * \
                              ((uint32)Channel % (uint32)GTM_TOM_CH_PER_TGC)));

  /* Initiate Host trigger to update of CM0, CM1 and CLK_SRC
   * registers from their respective shadow registers.*/
  (TomTgcRegPtr->GLB_CTRL.U) |= GTM_TOM_HOST_TRIGGER_ENABLE;

  /* A delay is provided to allow the update of CM0, CM1 and CLK_SRC registers
   * on the next FXCLK. The delay should correspond to a minimum value of
   * 1 FXCLK clock tick, since the force update is execute synchronized to
   * FXCLK clock. This delay is realized using few NOP instruction,
   * which should provide sufficient delay,so that at least 1 FXCLK clock tick
   * to occur*/
  NOP();
  NOP();
  NOP();
  FupdDisableCh = ((uint32)GTM_TOM_FORCE_UPDATE_DISABLE << \
                  ((uint32)GTM_TOM_BITS_PER_CHAN * \
                         ((uint32)Channel % (uint32)GTM_TOM_CH_PER_TGC)));

  /* Disable force update of CM0, CM1 and CRK_SRC registers for the \
   * input TOM channel */
  TomTgcRegPtr->FUPD_CTRL.U = FupdDisableCh;

  /* Restore back the contents of FUPD_CTRL, ENDIS_STAT and
   * OUTEN_STAT registers */
  TomTgcRegPtr->FUPD_CTRL.U = (uint32)(FupdCtrlBackup ^ \
                                              (uint32)GTM_RESTORE_RSTCN0_FUPD);
  TomTgcRegPtr->ENDIS_CTRL.U = EndisCtrlBackup;
  TomTgcRegPtr->OUTEN_CTRL.U = OutenCtrlBackup;

  /* Exit critical section */
  SchM_Exit_McalLib_TomTgcReg();

}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmTomChannelDeInit                           **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
** Description      : This interface resets the TOM channel registers to its  **
**                    reset value.                                            **
**                                                                            **
** Service ID       : 0x17                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : Module - TOM Module ID                                  **
**                    Channel - TOM Channel ID                                **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
void Mcal_GtmTomChannelDeInit(uint8 Module, uint8 Channel)
{

  uint8 TomTgcIndex = (uint8)(Channel/(uint8)GTM_TOM_CH_PER_TGC);
  uint8 BitPos = \
                ((uint8)MCAL_BIT_POS_8 + (Channel % (uint8)GTM_TOM_CH_PER_TGC));

  Ifx_GTM_TOM_CH_TYPE *TomChannelRegPtr; /* Pointer to TOM channel Register */
  Ifx_GTM_TOM_TGC_TYPE* TomTgcRegPtr;    /* Ptr to TOM TGC Reg         */

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TomChannelRegPtr = GTM_TOM_CH_POINTER(Module,Channel);

  /* Clear any pending interrupts associated with TOM channel register */
  TomChannelRegPtr->IRQ_NOTIFY.U = GTM_TOM_CLR_PENDING_IRQ;

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TomTgcRegPtr = GTM_TOM_TGC_POINTER(Module,TomTgcIndex);

  /* Critical section for GLC_CTRL is taken care
   * by using an atomic instruction */
  Mcal_SetBitAtomic(&(TomTgcRegPtr->GLB_CTRL.U), \
                      BitPos, \
                      IFX_GTM_TOM_TGC0_GLB_CTRL_RST_CH0_LEN, \
                      GTM_TOM_CH_SW_RESET);

  /* Invalidate the TOM channel user data */
  Mcal_GtmTomChUserData[Module][Channel] = GTM_TOM_CH_USERDATA_EMPTY;
  /* MISRA2012_RULE_2_2_JUSTIFICATION: BitPos is used in Mcal_SetBitAtomic.
   * No side effects foreseen by violating this MISRA rule. */
  /* MISRA2012_RULE_8_13_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
}
/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmAtomChannelInit                            **
**                    (                                                       **
**                     const Mcal_GtmTomChConfigType *ConfigPtr               **
**                    )                                                       **
**                                                                            **
** Description      : This interface configures an instance of ATOM channel.  **
**                    Consumer of a ATOM channel invokes this interface at the**
**                    time of channel initialization.                         **
**                                                                            **
** Service ID       : 0x18                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : ConfigPtr - Pointer to configuration data of a          **
**                    ATOM channel                                            **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
void Mcal_GtmAtomChannelInit(const Mcal_GtmTomChConfigType *ConfigPtr)
{
  uint8 Module;
  uint8 Channel;
  /* Pointer to ATOM channel Register */
  Ifx_GTM_ATOM_CH_TYPE *AtomChannelRegPtr;

  /* Retrieve the TOM module index value */
  Module = ConfigPtr->TimerId.TimerModuleNumber;
  /* Retrieve the TOM module channel number */
  Channel = ConfigPtr->TimerId.TimerChannelNumber;

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  AtomChannelRegPtr = GTM_ATOM_CH_POINTER(Module,Channel);

  /* Clear any pending interrupts associated with ATOM channel register */
  AtomChannelRegPtr->IRQ_NOTIFY.U = GTM_ATOM_CLR_PENDING_IRQ;

  /* Disable all ATOM interrupts */
  AtomChannelRegPtr->IRQ_EN.U = GTM_ATOM_REG_RESET;

  /* Configure the ATOM Channel control register */
  AtomChannelRegPtr->CTRL.U = ConfigPtr->TimerChCtrlReg;

  /* Configure the ATOM Channel CCU0 counter register */
  AtomChannelRegPtr->CN0.U = ConfigPtr->TimerChCN0Reg;

  /* Configure the ATOM Channel CCU0 compare register */
  AtomChannelRegPtr->CM0.U = ConfigPtr->TimerChCM0Reg;

  /* Configure the ATOM Channel CCU1 compare register */
  AtomChannelRegPtr->CM1.U = ConfigPtr->TimerChCM1Reg;

  /* Configure the ATOM Channel CCU0 compare shadow register */
  AtomChannelRegPtr->SR0.U = ConfigPtr->TimerChSR0Reg;

  /* Configure the ATOM Channel CCU1 compare shadow register */
  AtomChannelRegPtr->SR1.U = ConfigPtr->TimerChSR1Reg;

  /* Configure the Interrupt mode of ATOM Channel register */
  AtomChannelRegPtr->IRQ_MODE.U = \
      (((uint32)ConfigPtr->TimerChIntEnMode >> GTM_ATOM_IRQ_MODE_POS) \
                      & (uint32)IFX_GTM_ATOM_CH_IRQ_MODE_IRQ_MODE_MSK);

  /* Enable the interrupts associated with ATOM Channel register */
  AtomChannelRegPtr->IRQ_EN.U = \
      ((uint32)ConfigPtr->TimerChIntEnMode & (uint32)GTM_ATOM_IRQ_EN_REG_MSK);

  /* Update the ATOM user data table */
  Mcal_GtmAtomChUserData[Module][Channel] = \
      (((uint32)ConfigPtr->TimerId.CpuId << (uint32)MCAL_CPU_ID_BITPOS) | \
      ((uint32)ConfigPtr->TimerId.UserChLogicalChannelId << \
                                             (uint32)MCAL_LOG_CH_ID_BITPOS) | \
      ((uint32)ConfigPtr->TimerId.TimerChUserId));

}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmAtomChannelShadowTransfer                  **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
** Description      : This interface is used to initiate a copy of values in  **
**                    shadow registers, Compare values (duty, period) and     **
**                    Clock Source, of the specified ATOM channel to its main **
**                    timer registers.                                        **
**                                                                            **
** Service ID       : 0x19                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant                                           **
**                                                                            **
** Parameters(in)   : Module - ATOM Module ID                                 **
**                    Channel - ATOM Channel ID                               **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
void Mcal_GtmAtomChannelShadowTransfer(uint8 Module, uint8 Channel)
{
  uint32 EndisCtrlBackup;
  uint32 OutenCtrlBackup;
  uint32 FupdCtrlBackup;
  uint32 FupdDisableCh;
  Ifx_GTM_ATOM_AGCx* AtomAgcRegPtr;   /* Ptr to ATOM AGC Reg         */

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  AtomAgcRegPtr = GTM_ATOM_AGC_POINTER(Module);

  /* Enter critical section */
  SchM_Enter_McalLib_AtomAgcReg();

  /* Backup of ENDIS_CTRL, OUTEN_CTRL and FUPD_CTRL registers */
  EndisCtrlBackup = AtomAgcRegPtr->ENDIS_CTRL.U;
  OutenCtrlBackup = AtomAgcRegPtr->OUTEN_CTRL.U;
  FupdCtrlBackup = AtomAgcRegPtr->FUPD_CTRL.U;

  /* Disable the Reset CN0 and force update of all channels */
  AtomAgcRegPtr->FUPD_CTRL.U = GTM_DISABLE_RSTCN0_FUPD;
  AtomAgcRegPtr->ENDIS_CTRL.U = GTM_ATOM_DISABLE_STAT_UPDATE;
  AtomAgcRegPtr->OUTEN_CTRL.U = GTM_ATOM_DISABLE_STAT_UPDATE;

  /* Enable force update of CM0, CM1 and CRK_SRC registers for
   * the input ATOM channel */
  AtomAgcRegPtr->FUPD_CTRL.U = ((uint32)GTM_ATOM_FORCE_UPDATE_ENABLE << \
      ((uint32)GTM_ATOM_BITS_PER_CHAN * (uint32)Channel));

  /* Initiate Host trigger to update of CM0, CM1 and CLK_SRC registers
   * from their respective shadow registers. Also ENDIS_STAT and OUTEN_STAT
   * are also updated */
  (AtomAgcRegPtr->GLB_CTRL.U) |= GTM_ATOM_HOST_TRIGGER_ENABLE;

  /* A delay is provided to allow the update of CM0, CM1 and CLK_SRC registers
   * on the next FXCLK. The delay should correspond to a minimum value of
   * 1 FXCLK clock tick, since the force update is execute synchronized to
   * FXCLK clock. This delay is realized using few NOP instruction,
   * which should provide sufficient delay,so that at least 1 FXCLK clock tick
   * to occur*/
  NOP();
  NOP();
  NOP();
  FupdDisableCh = ((uint32)GTM_ATOM_FORCE_UPDATE_DISABLE << \
                       ((uint32)GTM_ATOM_BITS_PER_CHAN * (uint32)Channel));

  /* Disable force update of CM0, CM1 and CRK_SRC registers for
   * the input ATOM channel */
  AtomAgcRegPtr->FUPD_CTRL.U = FupdDisableCh;

  /* Restore back the contents of ENDIS_STAT and OUTEN_STAT registers */
  AtomAgcRegPtr->FUPD_CTRL.U = (uint32)(FupdCtrlBackup ^ \
                                              (uint32)GTM_RESTORE_RSTCN0_FUPD);
  AtomAgcRegPtr->ENDIS_CTRL.U = EndisCtrlBackup;
  AtomAgcRegPtr->OUTEN_CTRL.U = OutenCtrlBackup;

  /* Exit critical section */
  SchM_Exit_McalLib_AtomAgcReg();

}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmAtomChannelDeInit                          **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      : This interface resets the ATOM channel registers to its **
**                    reset value.                                            **
**                                                                            **
** Service ID       : 0x1A                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : Module - ATOM Module ID                                 **
**                    Channel - ATOM Channel ID                               **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/

void Mcal_GtmAtomChannelDeInit(uint8 Module, uint8 Channel)
{

  uint8 BitPos = (uint8)MCAL_BIT_POS_8 + Channel;
  Ifx_GTM_ATOM_CH_TYPE *AtomChannelRegPtr; /* Pointer to ATOM CH Register */
  Ifx_GTM_ATOM_AGCx* AtomAgcRegPtr;        /* Pointer to ATOM AGC Register   */

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  AtomChannelRegPtr = GTM_ATOM_CH_POINTER(Module,Channel);

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  AtomAgcRegPtr = GTM_ATOM_AGC_POINTER(Module);

  /* Clear any pending interrupts associated with ATOM channel register */
  AtomChannelRegPtr->IRQ_NOTIFY.U = GTM_ATOM_CLR_PENDING_IRQ;

  /* Critical section for GLC_CTRL is taken care by using
   * an atomic instruction */
    Mcal_SetBitAtomic(&(AtomAgcRegPtr->GLB_CTRL.U),BitPos,\
        IFX_GTM_ATOM_AGC_GLB_CTRL_RST_CH0_LEN,GTM_ATOM_CH_SW_RESET);

  /* Invalidate the ATOM channel user data */
  Mcal_GtmAtomChUserData[Module][Channel] = GTM_ATOM_CH_USERDATA_EMPTY;

  /* MISRA2012_RULE_2_2_JUSTIFICATION: BitPos is used in Mcal_SetBitAtomic.
   * No side effects foreseen by violating this MISRA rule. */
  /* MISRA2012_RULE_8_13_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
}
/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmTimChannelInit                             **
**                    (                                                       **
**                    const Mcal_GtmTimChConfigType *ConfigPtr                **
**                    )                                                       **
**                                                                            **
** Description      : This interface configures an instance of TIM channel.   **
**                    Consumer of a TIM channel invokes this interface at the **
**                    time of channel initialization.                         **
**                                                                            **
** Service ID       : 0x1B                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : ConfigPtr - Pointer to configuration data of a          **
**                    TIM channel                                             **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
void Mcal_GtmTimChannelInit(const Mcal_GtmTimChConfigType *ConfigPtr)
{
  uint8 Module;
  uint8 Channel;
  Ifx_GTM_TIM_CH_TYPE *TimChannelRegPtr; /* Pointer to TIM channel Register */


  /* Retrieve the TIM module index value */
  Module = ConfigPtr->TimerId.TimerModuleNumber;
  /* Retrieve the TIM module channel number */
  Channel = ConfigPtr->TimerId.TimerChannelNumber;

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TimChannelRegPtr = GTM_TIM_CH_POINTER(Module,Channel);

  /* Clear any pending interrupts associated with TIM channel register */
  TimChannelRegPtr->IRQ_NOTIFY.U = GTM_TIM_CLR_PENDING_IRQ;

  /* Disable interrupts associated with TIM channel register */
  TimChannelRegPtr->IRQ_EN.U = GTM_TIM_REG_RESET;

  /* Configure the Rising Edge filter register */
  TimChannelRegPtr->FLT_RE.U = ConfigPtr->TimChFltRisingEdge;

  /* Configure the falling Edge filter register */
  TimChannelRegPtr->FLT_FE.U = ConfigPtr->TimChFltFallingEdge;

  /* Configure the Interrupt mode of  TIM Channel register */
  TimChannelRegPtr->IRQ_MODE.U = \
      (((uint32)ConfigPtr->TimChIntEnMode >> GTM_TIM_IRQ_MODE_POS) & \
           (uint32)IFX_GTM_TIM_CH_IRQ_MODE_IRQ_MODE_MSK);

  /* Enable the interrupts associated with TIM Channel register */
  TimChannelRegPtr->IRQ_EN.U = \
      ((uint32)ConfigPtr->TimChIntEnMode & (uint32)GTM_TIM_IRQ_EN_REG_MSK);

  /* Configure the TIM Channel extended control register */
  TimChannelRegPtr->ECTRL.U = ConfigPtr->TimChExtendedCtrlReg;

  /* Configure the TIM Channel control register */
  TimChannelRegPtr->CTRL.U = ConfigPtr->TimChCtrlReg;

  /* Update the TIM user data table */
  Mcal_GtmTimChUserData[Module][Channel] = \
      (((uint32)ConfigPtr->TimerId.CpuId << (uint32)MCAL_CPU_ID_BITPOS) | \
      ((uint32)ConfigPtr->TimerId.UserChLogicalChannelId << \
                                              (uint32)MCAL_LOG_CH_ID_BITPOS) | \
      ((uint32)ConfigPtr->TimerId.TimerChUserId));

}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmTimChannelDeInit                           **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      : This interface resets the TIM channel registers to its  **
**                    reset value.                                            **
**                                                                            **
** Service ID       : 0x1C                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : Module - TIM Module ID                                  **
**                    Channel - TIM Channel ID                                **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/

void Mcal_GtmTimChannelDeInit(uint8 Module, uint8 Channel)
{
  Ifx_GTM_TIM_RSTx *TimChannelResetPtr;
  Ifx_GTM_TIM_CH_TYPE *TimChannelRegPtr; /* Pointer to TIM channel Register */

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TimChannelRegPtr = GTM_TIM_CH_POINTER(Module,Channel);

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TimChannelResetPtr = GTM_TIM_MODULE_RST_POINTER(Module);

  /* Clear any pending interrupts associated with TIM channel register */
  TimChannelRegPtr->IRQ_NOTIFY.U = GTM_TIM_CLR_PENDING_IRQ;

  /* Reset the TIM channel */
  /* Critical section is not required for the TIM[x]_RST register since the
   * resetting for the input Channel, using an atomic operation
   */
  Mcal_SetBitAtomic(&(TimChannelResetPtr->RST.U),
                      Channel,
                      IFX_GTM_TIM_RST_RST_CH0_LEN,
                      GTM_TIM_CH_RESET);

  /* Invalidate the TIM channel user data */
  Mcal_GtmTimChUserData[Module][Channel] = GTM_TIM_CH_USERDATA_EMPTY;
  /* MISRA2012_RULE_2_2_JUSTIFICATION: BitPos is used in Mcal_SetBitAtomic.
   * No side effects foreseen by violating this MISRA rule. */
  /* MISRA2012_RULE_8_13_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmTomChannelEnable                           **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel,                                        **
**                      Mcal_GtmTimerOutType TimerOutputEn                    **
**                    )                                                       **
**                                                                            **
** Description      : This interface is used by application to enable or start**
**                    the input TOM channel. Based on the input argument      **
**                    TimerOutputEn, the application can decide to            **
**                    enable or disable TOM channel output. Applications which**
**                    use the timer for counting (time base) purposes can     **
**                    disable the output. The TOM channel timer starts        **
**                    running when the channel is enabled                     **
**                                                                            **
** Service ID       : 0x1D                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : Module -        TOM Module ID                           **
**                    Channel -       TOM Channel ID                          **
**                    TimerOutputEn - TOM Output enable configuration         **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/

void Mcal_GtmTomChannelEnable(uint8 Module, uint8 Channel,
                                      Mcal_GtmTimerOutType TimerOutputEn)
{
  uint8 TomTgcIndex = (Channel/(uint8)GTM_TOM_CH_PER_TGC);
  uint8 BitPos =      ((uint8)IFX_GTM_TOM_TGC0_ENDIS_STAT_ENDIS_STAT0_LEN * \
                       (Channel % (uint8)GTM_TOM_CH_PER_TGC));

  Ifx_GTM_TOM_TGC_TYPE* TomTgcRegPtr;

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TomTgcRegPtr = GTM_TOM_TGC_POINTER(Module,TomTgcIndex);

  /* Enable the TOM channel in ENDIS_STAT register*/
  Mcal_SetBitAtomic(&(TomTgcRegPtr->ENDIS_STAT.U),
                      BitPos,
                      IFX_GTM_TOM_TGC0_ENDIS_STAT_ENDIS_STAT0_LEN,\
                      GTM_TOM_CH_ENABLE);

  /* Write value 0x0 into TOM channel bitfield in ENDIS_CTRL register,
   * which prevents any update from ENDIS_CTRL to ENDIS_STAT
   * on an update trigger*/
  Mcal_SetBitAtomic(&(TomTgcRegPtr->ENDIS_CTRL.U),\
                      BitPos,\
                      IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_LEN,\
                      GTM_TOM_CH_STAT_NO_UPDATE);

  /* Is TOM channel output to be enabled */
  if(TimerOutputEn == MCAL_GTM_TIMER_OUT_ENABLE)
  {
  /* Enable the TOM channel output in OUTEN_STAT register*/
    Mcal_SetBitAtomic(&(TomTgcRegPtr->OUTEN_STAT.U),\
                        BitPos,\
                        IFX_GTM_TOM_TGC0_OUTEN_STAT_OUTEN_STAT0_LEN,\
                        GTM_TOM_CH_OUT_ENABLE);

    /* Write value 0x0 into TOM channel bitfield in OUTEN_CTRL register, which
     * prevents any update from OUTEN_CTRL to OUTEN_STAT on an update trigger*/
    Mcal_SetBitAtomic(&(TomTgcRegPtr->OUTEN_CTRL.U),\
                        BitPos,\
                        IFX_GTM_TOM_TGC0_OUTEN_CTRL_OUTEN_CTRL0_LEN,\
                        GTM_TOM_CH_STAT_NO_UPDATE);
  }
  /* MISRA2012_RULE_2_2_JUSTIFICATION: BitPos is used in Mcal_SetBitAtomic.
   * No side effects foreseen by violating this MISRA rule. */
  /* MISRA2012_RULE_8_13_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmTomChannelDisable                          **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel,                                        **
**                    )                                                       **
**                                                                            **
** Description      : This interface is used by application to stop or disable**
**                    the input TOM channel and also its channel output. The  **
**                    TOM channel timer stops running when the channel is     **
**                    disabled                                                **
**                                                                            **
** Service ID       : 0x1E                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : Module -        TOM Module ID                           **
**                    Channel -       TOM Channel ID                          **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/

void Mcal_GtmTomChannelDisable(uint8 Module, uint8 Channel)
{
  uint8 TomTgcIndex = (Channel/(uint8)GTM_TOM_CH_PER_TGC);
  uint8 BitPos =      ((uint8)IFX_GTM_TOM_TGC0_ENDIS_STAT_ENDIS_STAT0_LEN * \
                             (Channel % (uint8)GTM_TOM_CH_PER_TGC));

  Ifx_GTM_TOM_TGC_TYPE* TomTgcRegPtr;

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TomTgcRegPtr = GTM_TOM_TGC_POINTER(Module,TomTgcIndex);

  /* Disable the TOM channel in ENDIS_STAT register*/
  Mcal_SetBitAtomic(&(TomTgcRegPtr->ENDIS_STAT.U),
                      BitPos,
                      IFX_GTM_TOM_TGC0_ENDIS_STAT_ENDIS_STAT0_LEN,\
                      GTM_TOM_CH_DISABLE);

  /* Disable the TOM channel output in OUTEN_STAT register*/
  Mcal_SetBitAtomic(&(TomTgcRegPtr->OUTEN_STAT.U),\
                      BitPos,\
                      IFX_GTM_TOM_TGC0_OUTEN_STAT_OUTEN_STAT0_LEN,\
                      GTM_TOM_CH_OUT_DISABLE);

  /* Write value 0x0 into TOM channel bitfield in ENDIS_CTRL register,
   *  which prevents any update from ENDIS_CTRL to ENDIS_STAT on an update
   *  trigger*/
  Mcal_SetBitAtomic(&(TomTgcRegPtr->ENDIS_CTRL.U),\
                      BitPos,\
                      IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_LEN,\
                      GTM_TOM_CH_STAT_NO_UPDATE);

  /* Write value 0x0 into TOM channel bitfield in OUTEN_CTRL register, which
   *  prevents any update from OUTEN_CTRL to OUTEN_STAT on an update trigger*/
  Mcal_SetBitAtomic(&(TomTgcRegPtr->OUTEN_CTRL.U),\
                      BitPos,\
                      IFX_GTM_TOM_TGC0_OUTEN_CTRL_OUTEN_CTRL0_LEN,\
                      GTM_TOM_CH_STAT_NO_UPDATE);
  /* MISRA2012_RULE_2_2_JUSTIFICATION: BitPos is used in Mcal_SetBitAtomic.
   * No side effects foreseen by violating this MISRA rule. */
  /* MISRA2012_RULE_8_13_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : Mcal_GtmTimerStatusType Mcal_GtmIsTomChannelEnabled     **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      : This interface is used by applications to check if the  **
**                    input TOM channel is running or not. The interface      **
**                    returns the channel running status. The channel running **
**                    status is same as its enabled status i.e. channel       **
**                    starts running when the channel is enabled              **
**                                                                            **
** Service ID       : 0x1F                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Reentrant                                               **
**                                                                            **
** Parameters(in)   : Module -        TOM Module ID                           **
**                    Channel -       TOM Channel ID                          **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Mcal_GtmTimerStatusType-                                **
**                    MCAL_GTM_TIMER_STOPPED  Channel is not running         **
**                    MCAL_GTM_TIMER_RUNNING - Channel is running             **
**                                                                            **
**                                                                            **
*******************************************************************************/

Mcal_GtmTimerStatusType Mcal_GtmIsTomChannelEnabled(uint8 Module, \
                                                          uint8 Channel)
{
  uint8 TomChStatus;
  uint8 TomTgcIndex = (Channel/(uint8)GTM_TOM_CH_PER_TGC);

  uint8 BitPos = (((uint8)IFX_GTM_TOM_TGC0_ENDIS_STAT_ENDIS_STAT0_LEN)* \
                               (Channel % (uint8)GTM_TOM_CH_PER_TGC));
  const Ifx_GTM_TOM_TGC_TYPE* TomTgcRegPtr;

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TomTgcRegPtr = GTM_TOM_TGC_POINTER(Module,TomTgcIndex);

  /* Obtain the channel enabled status from ENDIS_STAT register
   * 0x3 - Channel enabled
   * 0x0 - Channel disabled
   */
  TomChStatus = (uint8)Mcal_GetBitAtomic
                              ( \
                              TomTgcRegPtr->ENDIS_STAT.U,
                              BitPos,
                              IFX_GTM_TOM_TGC0_ENDIS_STAT_ENDIS_STAT0_LEN);

  /* Right shift by 1U to fit into return format
   * 0x1 - Channel enabled/running
   * 0x0 - Channel disabled/stopped
   */
  return ((TomChStatus >> GTM_ONE_U));
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmAtomChannelEnable                          **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel,                                        **
**                      Mcal_GtmTimerOutType TimerOutputEn                    **
**                    )                                                       **
**                                                                            **
** Description      : This interface is used by application to enable or start**
**                    the input ATOM channel. Based on the input argument     **
**                    TimerOutputEn, the application can decide to            **
**                    enable or disable ATOM channel output. Application which**
**                    uses the timer for counting (time base) purposes can    **
**                    disable the output. The ATOM channel timer starts       **
**                    running when the channel is enabled                     **
**                                                                            **
** Service ID       : 0x20                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : Module -        ATOM Module ID                          **
**                    Channel -       ATOM Channel ID                         **
**                    TimerOutputEn - ATOM Output enable configuration        **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/

void Mcal_GtmAtomChannelEnable(uint8 Module, uint8 Channel, \
                           Mcal_GtmTimerOutType TimerOutputEn)
{
  uint8 BitPos = \
      (uint8)(((uint8)IFX_GTM_ATOM_AGC_ENDIS_STAT_ENDIS_CTRL0_LEN) * Channel);

  Ifx_GTM_ATOM_AGCx* AtomAgcRegPtr;           /* Ptr to ATOM AGC Reg         */

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  AtomAgcRegPtr =  GTM_ATOM_AGC_POINTER(Module);

  /* Enable the ATOM channel in ENDIS_STAT register*/
  Mcal_SetBitAtomic(&(AtomAgcRegPtr->ENDIS_STAT.U),\
                      BitPos,\
                      IFX_GTM_ATOM_AGC_ENDIS_STAT_ENDIS_CTRL0_LEN,\
                      GTM_ATOM_CH_ENABLE);

  /* Write value 0x0 into ATOM channel bitfield in ENDIS_CTRL register,which
   * prevents any update from ENDIS_CTRL to ENDIS_STAT on an update trigger*/
  Mcal_SetBitAtomic(&(AtomAgcRegPtr->ENDIS_CTRL.U),\
                      BitPos,\
                      IFX_GTM_ATOM_AGC_ENDIS_CTRL_ENDIS_CTRL0_LEN,\
                      GTM_ATOM_CH_STAT_NO_UPDATE);

  /* Is ATOM channel output to be enabled */
  if(TimerOutputEn == MCAL_GTM_TIMER_OUT_ENABLE)
  {
  /* Enable the ATOM channel output in OUTEN_STAT register*/
    Mcal_SetBitAtomic(&(AtomAgcRegPtr->OUTEN_STAT.U),\
                        BitPos,\
                        IFX_GTM_ATOM_AGC_OUTEN_STAT_OUTEN_STAT0_LEN,\
                        GTM_ATOM_CH_OUT_ENABLE);

    /* Write value 0x0 into ATOM channel bitfield in ENDIS_CTRL register,
     * which prevents any update from ENDIS_CTRL to ENDIS_STAT on
     * an update trigger*/
    Mcal_SetBitAtomic(&(AtomAgcRegPtr->OUTEN_CTRL.U), \
                        BitPos, \
                        IFX_GTM_ATOM_AGC_OUTEN_CTRL_OUTEN_CTRL0_LEN, \
                        GTM_ATOM_CH_STAT_NO_UPDATE);

  }
  /* MISRA2012_RULE_2_2_JUSTIFICATION: BitPos is used in Mcal_SetBitAtomic.
   * No side effects foreseen by violating this MISRA rule. */
  /* MISRA2012_RULE_8_13_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmAtomChannelDisable                         **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel,                                        **
**                    )                                                       **
**                                                                            **
** Description      : This interface is used by application to stop or disable**
**                    the input ATOM channel and also its channel output. The **
**                    ATOM channel timer stops running when the channel is    **
**                    disabled                                                **
**                                                                            **
** Service ID       : 0x21                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : Module -        ATOM Module ID                          **
**                    Channel -       ATOM Channel ID                         **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/

void Mcal_GtmAtomChannelDisable(uint8 Module, uint8 Channel)
{
  uint8 BitPos = \
    (uint8)((((uint8)IFX_GTM_ATOM_AGC_ENDIS_STAT_ENDIS_CTRL0_LEN) * Channel));

  Ifx_GTM_ATOM_AGCx* AtomAgcRegPtr;           /* Ptr to ATOM AGC Reg */

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  AtomAgcRegPtr =  GTM_ATOM_AGC_POINTER(Module);

  /* Disable the ATOM channel in ENDIS_STAT register*/
  Mcal_SetBitAtomic(&(AtomAgcRegPtr->ENDIS_STAT.U),\
                      BitPos,\
                      IFX_GTM_ATOM_AGC_ENDIS_STAT_ENDIS_CTRL0_LEN,\
                      GTM_ATOM_CH_DISABLE);

  /* Disable the ATOM channel output in OUTEN_STAT register*/
  Mcal_SetBitAtomic(&(AtomAgcRegPtr->OUTEN_STAT.U),\
                      BitPos,\
                      IFX_GTM_ATOM_AGC_OUTEN_STAT_OUTEN_STAT0_LEN,\
                      GTM_ATOM_CH_OUT_DISABLE);

  /* Write value 0x0 into ATOM channel bitfield in ENDIS_CTRL register, which
   * prevents any update from ENDIS_CTRL to ENDIS_STAT on an update trigger*/
  Mcal_SetBitAtomic(&(AtomAgcRegPtr->ENDIS_CTRL.U),\
                      BitPos,\
                      IFX_GTM_ATOM_AGC_ENDIS_CTRL_ENDIS_CTRL0_LEN,\
                      GTM_ATOM_CH_STAT_NO_UPDATE);

  /* Write value 0x0 into ATOM channel bitfield in ENDIS_CTRL register,
   * which prevents any update from ENDIS_CTRL to ENDIS_STAT on an
   * update trigger*/
  Mcal_SetBitAtomic(&(AtomAgcRegPtr->OUTEN_CTRL.U), \
                      BitPos, \
                      IFX_GTM_ATOM_AGC_OUTEN_CTRL_OUTEN_CTRL0_LEN,\
                      GTM_ATOM_CH_STAT_NO_UPDATE);
  /* MISRA2012_RULE_2_2_JUSTIFICATION: BitPos is used in Mcal_SetBitAtomic.
   * No side effects foreseen by violating this MISRA rule. */
  /* MISRA2012_RULE_8_13_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : Mcal_GtmTimerStatusType Mcal_GtmIsAtomChannelEnabled    **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      : This interface is used by applications to check if the  **
**                    input ATOM channel is running or not. The interface     **
**                    returns the channel running status. The channel running **
**                    status is same as its enabled status i.e. channel       **
**                    starts running when the channel is enabled              **
**                                                                            **
** Service ID       : 0x22                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Reentrant                                               **
**                                                                            **
** Parameters(in)   : Module -        ATOM Module ID                          **
**                    Channel -       ATOM Channel ID                         **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Mcal_GtmTimerStatusType-                                **
**                    MCAL_GTM_TIMER_STOPPED  Channel is not running         **
**                    MCAL_GTM_TIMER_RUNNING - Channel is running             **
**                                                                            **
*******************************************************************************/

Mcal_GtmTimerStatusType Mcal_GtmIsAtomChannelEnabled(uint8 Module, \
                                                     uint8 Channel)
{
  uint8 AtomChStatus;
  uint8 BitPos = \
   (uint8)((((uint8)IFX_GTM_ATOM_AGC_ENDIS_STAT_ENDIS_CTRL0_LEN) * Channel));
  /* Ptr to ATOM AGC Reg */
  const Ifx_GTM_ATOM_AGCx* AtomAgcRegPtr;

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  AtomAgcRegPtr =  GTM_ATOM_AGC_POINTER(Module);

  /* Obtain the channel enabled status from ENDIS_STAT register
   * 0x3 - Channel enabled
   * 0x0 - Channel disabled
   */
  AtomChStatus = (uint8)Mcal_GetBitAtomic(
                        AtomAgcRegPtr->ENDIS_STAT.U, \
                        BitPos,\
                        IFX_GTM_ATOM_AGC_ENDIS_STAT_ENDIS_CTRL0_LEN);

  /* Right shift by 1U to fit into return format
   * 0x1 - Channel enabled
   * 0x0 - Channel disabled
   */
  return ((AtomChStatus >> GTM_ONE_U));
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmTimChannelEnable                           **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      : This interface is used by applications to enable the    **
**                    inputTIM channel. The TIM channel timer starts running  **
**                    when the channel is enabled                             **
**                                                                            **
** Service ID       : 0x23                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : Module -        TIM Module ID                           **
**                    Channel -       TIM Channel ID                          **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
*******************************************************************************/

void Mcal_GtmTimChannelEnable(uint8 Module, uint8 Channel)
{
  Ifx_GTM_TIM_CH_TYPE *TimChannelRegPtr; /* Pointer to TIM channel Register */

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TimChannelRegPtr = GTM_TIM_CH_POINTER(Module,Channel);
  /* Enable the TIM channel by setting the TIM_EN bit in TIM_CTRL */
  Mcal_SetBitAtomic(&(TimChannelRegPtr->CTRL.U),\
                      IFX_GTM_TIM_CH_CTRL_TIM_EN_OFF,\
                      IFX_GTM_TIM_CH_CTRL_TIM_EN_LEN,\
                      GTM_TIM_CH_ENABLE);
  /* MISRA2012_RULE_2_2_JUSTIFICATION: BitPos is used in Mcal_SetBitAtomic.
   * No side effects foreseen by violating this MISRA rule. */
  /* MISRA2012_RULE_8_13_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmTimChannelDisable                          **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      : This interface is used by applications to disable the   **
**                    input TIM channel. The TIM channel timer stops running  **
**                    when the channel is disabled                            **
**                                                                            **
** Service ID       : 0x24                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : Module -        TIM Module ID                           **
**                    Channel -       TIM Channel ID                          **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/

void Mcal_GtmTimChannelDisable(uint8 Module, uint8 Channel)
{
  Ifx_GTM_TIM_CH_TYPE *TimChannelRegPtr; /* Pointer to TIM channel Register */

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TimChannelRegPtr = GTM_TIM_CH_POINTER(Module,Channel);

  /* Disable the TIM channel by resetting the TIM_EN bit in TIM_CTRL */
  Mcal_SetBitAtomic(&(TimChannelRegPtr->CTRL.U),\
                      IFX_GTM_TIM_CH_CTRL_TIM_EN_OFF,\
                      IFX_GTM_TIM_CH_CTRL_TIM_EN_LEN,\
                      GTM_TIM_CH_DISABLE);
  /* MISRA2012_RULE_2_2_JUSTIFICATION: BitPos is used in Mcal_SetBitAtomic.
   * No side effects foreseen by violating this MISRA rule. */
  /* MISRA2012_RULE_8_13_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : Mcal_GtmTimerStatusType Mcal_GtmIsTimChannelEnabled     **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      : This interface is used by applications to check if the  **
**                    input TIM channel is running or not. The interface      **
**                    returns the channel running status. The channel running **
**                    status is same as its enabled status i.e. channel       **
**                    starts running when the channel is enabled              **
**                                                                            **
** Service ID       : 0x25                                                    **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Reentrant                                               **
**                                                                            **
** Parameters(in)   : Module -        TIM Module ID                           **
**                    Channel -       TIM Channel ID                          **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Mcal_GtmTimerStatusType-                                **
**                    MCAL_GTM_TIMER_STOPPED  Channel is not running         **
**                    MCAL_GTM_TIMER_RUNNING - Channel is running             **
**                                                                            **
*******************************************************************************/

Mcal_GtmTimerStatusType Mcal_GtmIsTimChannelEnabled(uint8 Module, \
                                                   uint8 Channel)
{
  uint8 ChannelStatus;
  /* Pointer to TIM channel Register */
  const Ifx_GTM_TIM_CH_TYPE *TimChannelRegPtr;

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  TimChannelRegPtr = GTM_TIM_CH_POINTER(Module,Channel);

  /* Obtain the channel enabled status from TIM_CH_CTRL register
   * 0x1 - Channel enabled
   * 0x0 - Channel disabled
   */
  ChannelStatus = (uint8)Mcal_GetBitAtomic(TimChannelRegPtr->CTRL.U, \
                                           IFX_GTM_TIM_CH_CTRL_TIM_EN_OFF, \
                                           IFX_GTM_TIM_CH_CTRL_TIM_EN_LEN);

  return (ChannelStatus);
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmTimChannelIsr                              **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      : This is the interrupt service routine of a TIM channel  **
**                    and is invoked by the interrupt frame installed in the  **
**                    interrupt vector table. It identifies the user of the   **
**                    specified channel from the TIM channel user data table  **
**                    and invokes a known call back function associated       **
**                    with the user.                                          **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Concurrency safe                                        **
**                                                                            **
** Parameters(in)   : Module -        TIM Module ID                           **
**                    Channel -       TIM Channel ID                          **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/

void Mcal_GtmTimChannelIsr (uint8 Module, uint8 Channel)
{
  uint8  UserId;
  uint8 LogChId;
  uint32 UserData;
  Ifx_GTM_TIM_CH_TYPE *TimChannelRegPtr;

  /* Did the input TIM channel trigger the interrupt */
  if(Mcal_lGtmGetTimIrqStatus(Module,Channel) == (uint8)GTM_ONE_U)
  {

    /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
     * by violating this MISRA rule, as the pointer to the object type
     * it is getting cast into is a known type . */
    /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
     * by violating this MISRA rule. */
    /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
     * by violating this MISRA rule. */
    TimChannelRegPtr = GTM_TIM_CH_POINTER(Module,Channel);

    /* Clear any TIM channel pending interrupts */
    TimChannelRegPtr->IRQ_NOTIFY.U = GTM_TIM_CLR_PENDING_IRQ;

    /* Retrieve the user information from TIM channel user data table */
    UserData = Mcal_GtmTimChUserData[Module][Channel];
    UserId   = (uint8)(UserData & (uint32)MCAL_USER_ID_MSK);
    LogChId  = (uint8)((UserData >> (uint32)MCAL_LOG_CH_ID_BITPOS) & \
                                           (uint32)MCAL_LOG_CH_ID_MSK);

    /* Is UserId information a valid one */
    if((UserId != (uint8)GTM_CH_NO_USER) && \
                                     (UserId <= (uint8)GTM_NO_OF_CALLBACK))
    {
      /* Does the valid User ID have a callback function */
      if( Mcal_DriversFuncCallbackList[(UserId - (uint8)GTM_ONE_U)] != NULL_PTR)
      {
        Mcal_DriversFuncCallbackList[(UserId - (uint8)GTM_ONE_U)](LogChId);
      }
    }
  }
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmTomChannelIsr                              **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      : This is the interrupt service routine of a TOM channel  **
**                    and is invoked by the interrupt frame installed in the  **
**                    interrupt vector table. It identifies the user of the   **
**                    specified channel from the TOM channel user data table  **
**                    and invokes a known call back function associated       **
**                    with the user.                                          **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Concurrency safe                                        **
**                                                                            **
** Parameters(in)   : Module -        TOM Module ID                           **
**                    Channel -       TOM Channel ID                          **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/
void Mcal_GtmTomChannelIsr (uint8 Module, uint8 Channel)
{

  uint8 ChanIndex,UserId,IrqStatus;
  uint8 LogChId;
  uint32 UserData;
  Ifx_GTM_TOM_CH_TYPE *TomChannelRegPtr;

  /* Get the Irq Group status to detect the channel that has
  triggered the ISR*/
  IrqStatus = Mcal_lGtmGetTomIrqStatus(Module, Channel);

  /* Did the input TOM channel 'x' or 'x+1' trigger the interrupt */
  if(IrqStatus != (uint8)GTM_ZERO_U)
  {
    /* Initialize ChanIndex to the number of channels mapped to one
    TOM Interrupt Node */
    ChanIndex = GTM_TOM_CHAN_PER_SRN;

    /* Loop through both the channels */
    do
    {
      ChanIndex--;
      /* Check which the channel has triggered interrupt
                                        ( 2 TOM channel shares the same SRN)*/
      if(Mcal_lGtmGetIntSource((uint32)IrqStatus, ChanIndex) == \
                                                        (uint8)GTM_ONE_U)
      {

        /* Get the Channel Register Pointer */

        /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects
         * foreseen by violating this MISRA rule, as the pointer to the
         * object type it is getting cast into is a known type . */
        /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects
         * foreseen by violating this MISRA rule. */
        /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects
         * foreseen by violating this MISRA rule. */
        TomChannelRegPtr = GTM_TOM_CH_POINTER(Module,(Channel + ChanIndex));

        /* Clear any pending interrupts associated with TOM channel register */
        TomChannelRegPtr->IRQ_NOTIFY.U = GTM_TOM_CLR_PENDING_IRQ;

        /* Retrieve the user information from TOM channel user data table */
        UserData = Mcal_GtmTomChUserData[Module][Channel+ChanIndex];
        UserId =  (uint8)(UserData & (uint32)MCAL_USER_ID_MSK);
        LogChId = (uint8)((UserData >> (uint32)MCAL_LOG_CH_ID_BITPOS) & \
                                               (uint32)MCAL_LOG_CH_ID_MSK);

        /* Is UserId information a valid one */
        if((UserId != (uint8)GTM_CH_NO_USER) && \
            (UserId <= (uint8)GTM_NO_OF_CALLBACK))
        {
          /* Does the valid User ID have a callback function */
          if(Mcal_DriversFuncCallbackList[(UserId - (uint8)GTM_ONE_U)] != \
                                                                      NULL_PTR)
          {
            Mcal_DriversFuncCallbackList[(UserId - (uint8)GTM_ONE_U)](LogChId);
          }
        }
      }
    /* Span through both the channels */
    }while(ChanIndex > (uint8)GTM_ZERO_U);

  }
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : void Mcal_GtmAtomChannelIsr                             **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      : This is the interrupt service routine of a ATOM channel **
**                    and is invoked by the interrupt frame installed in the  **
**                    interrupt vector table. It identifies the user of the   **
**                    specified channel from the ATOM channel user data table **
**                    and invokes a known call back function associated       **
**                    with the user.                                          **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Concurrency safe                                        **
**                                                                            **
** Parameters(in)   : Module -        ATOM Module ID                          **
**                    Channel -       ATOM Channel ID                         **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : None                                                    **
**                                                                            **
*******************************************************************************/

void Mcal_GtmAtomChannelIsr(uint8 Module, uint8 Channel)
{

  uint8 ChanIndex,UserId,IrqStatus;
  uint8 LogChId;
  uint32 UserData;
  Ifx_GTM_ATOM_CH_TYPE *AtomChannelRegPtr;

  /* Get the Irq Group status to detect the channel that has
  triggered the ISR*/
  IrqStatus = Mcal_lGtmGetAtomIrqStatus(Module, Channel);

  /* Did the input ATOM channel 'x' or 'x+1' trigger the interrupt */
  if(IrqStatus != (uint8)GTM_ZERO_U)
  {
    /* Initialize ChanIndex to the number of channels mapped to one
    ATOM Interrupt Node */
    ChanIndex = GTM_ATOM_CHAN_PER_SRN;

    /* Loop through both the channels */
    do
    {
      ChanIndex--;
      /* Check which the channel has triggered interrupt
       *  ( 2 ATOM channel shares the same SRN)*/
      if(Mcal_lGtmGetIntSource((uint32)IrqStatus, ChanIndex) == \
                                                            (uint8)GTM_ONE_U)
      {
        /* Get the Channel Register Pointer */

        /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects
         * foreseen by violating this MISRA rule, as the pointer to the
         * object type it is getting cast into is a known type . */
        /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects
         * foreseen by violating this MISRA rule. */
        /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects
         * foreseen by violating this MISRA rule. */
        AtomChannelRegPtr = GTM_ATOM_CH_POINTER(Module,(Channel + ChanIndex));

        /* Clear any pending interrupts associated with TOM channel register */
        AtomChannelRegPtr->IRQ_NOTIFY.U = GTM_ATOM_CLR_PENDING_IRQ;

        /* Retrieve the user information from ATOM channel user data table */
        UserData = Mcal_GtmAtomChUserData[Module][Channel+ChanIndex];
        UserId =   (uint8)(UserData & (uint32)MCAL_USER_ID_MSK);
        LogChId =  (uint8)((UserData >> (uint32)MCAL_LOG_CH_ID_BITPOS) & \
                                       (uint32)MCAL_LOG_CH_ID_MSK);

        /* Is UserId information a valid one */
        if((UserId != (uint8)GTM_CH_NO_USER) && \
            (UserId <= (uint8)GTM_NO_OF_CALLBACK))
        {
          /* Does the valid User ID have a callback function */
          if(Mcal_DriversFuncCallbackList[(UserId - (uint8)GTM_ONE_U)] != \
                                                                     NULL_PTR)
          {
            Mcal_DriversFuncCallbackList[(UserId - (uint8)GTM_ONE_U)](LogChId);
          }
        }
      }
    /* Span through both the channels */
    }while(ChanIndex > (uint8)GTM_ZERO_U);

  }
}

/*******************************************************************************
**                      Private Function Definitions                          **
*******************************************************************************/


/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Mcal_lGtmGetIntSource                **
**                    (                                                       **
**                      uint32 Value,                                         **
**                      uint8 Index                                           **
**                    )                                                       **
**                                                                            **
** Description      : This function returns the value at the bitposition      **
**                    specified by Index in the data Value. Hence the     **
**                    return value can be 0/1                                 **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Concurrency Safe                                        **
**                                                                            **
** Parameters(in)   : Value - Data                                            **
**                    Index - Bitposition                                     **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : 0  Data in Bitposition(Index) is 0                   **
**                    1  Data in Bitposition(Index) is 1                   **
**                                                                            **
*******************************************************************************/

LOCAL_INLINE uint8 Mcal_lGtmGetIntSource(uint32 Value, uint8 Index)
{
  return((uint8)((Value >> Index) & (uint32)GTM_BIT_SET));

}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Mcal_lGtmGetTimIrqStatus             **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      : This function returns the extracted information         **
**                    containing the status of the interrupt for the input    **
**                    TIM channel. It informs whether the TIM[Module][Channel]**
**                    triggered the interrupt or not. The information is      **
**                    extracted from ICM register corresponding to TIM module **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : Module -        TIM Module ID                           **
**                    Channel -       TIM Channel ID                          **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Extracted information containing the interrupt status   **
**                    of the input TIM channel                                **
**                                                                            **

*******************************************************************************/

LOCAL_INLINE uint8 Mcal_lGtmGetTimIrqStatus(uint8 Module,uint8 Channel)
{
  uint8 IrqStatus;
  uint8 RegPos;
  uint32 RegVal;

  /* Ascertain the position of Interrupt status for the corresponding module
     and channel*/
  RegPos = (uint8)(((Module % (uint8)GTM_TIM_MODULES_IN_ICM_REG) * \
                 (uint8)GTM_CHANNELS_PER_TIM_MODULE) + Channel);

  /* Identify the ICM register corresponding to the Module number */

  /* MISRA2012_RULE_18_4_JUSTIFICATION: Different TIM modules are associated
   * with different ICM registers. To effectively calculate to which ICM
   * register the module belongs to, the base ICM register address for
   * TIM module is taken the , according to module number, the subsequent
   * ICM register is accessed. Since the Module and Channel values are
   * validated by the user, no side effects are foreseen */

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  RegVal = *(((volatile uint32*)(volatile void *)GTM_TIM_ICM_BASE_ADDRESS) + \
                        ((uint32)Module/(uint32)GTM_TIM_MODULES_IN_ICM_REG));

  /* Retrieve the IRQ status of the channel number */
  IrqStatus = (uint8)((RegVal >> RegPos) & (uint32)GTM_GET_TIM_INT_STATUS);
  return(IrqStatus);
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Mcal_lGtmGetTomIrqStatus             **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      : This function returns the extracted information         **
**                    containing the status of the interrupt for the input    **
**                    TOM channel. It informs whether the TOM[Module][Channel]**
**                    triggered the interrupt or not. The information is      **
**                    extracted from ICM register corresponding to TOM module **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Not Reentrant for the same channel                      **
**                                                                            **
** Parameters(in)   : Module -        TOM Module ID                           **
**                    Channel -       TOM Channel ID                          **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Extracted information containing the interrupt status   **
**                    of the input TOM channel                                **
**                                                                            **
*******************************************************************************/

LOCAL_INLINE uint8 Mcal_lGtmGetTomIrqStatus(uint8 Module,uint8 Channel)
{
  uint8 RegPos;
  uint8 IrqStatus;
  uint32 RegVal;

  /* Ascertain the position of Interrupt status for the corresponding module
     and channel*/
  RegPos = (uint8)(((Module % (uint8)GTM_TOM_MODULES_IN_ICM_REG) * \
                      (uint8)GTM_CHANNELS_PER_TOM_MODULE) + Channel);

  /* Identify the ICM register corresponding to the Module number */

  /* MISRA2012_RULE_18_4_JUSTIFICATION: Different TOM modules are associated
   * with different ICM registers. To effectively calculate to which ICM
   * register the module belongs to, the base ICM register address for
   * TOM module is taken the , according to module number, the subsequent
   * ICM register is accessed. Since the Module and Channel values are
   * validated by the user, no side effects are foreseen */

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  RegVal = *(((volatile uint32*)(volatile void *)GTM_TOM_ICM_BASE_ADDRESS) + \
                         ((uint32)Module/(uint32)GTM_TOM_MODULES_IN_ICM_REG));


  /* Retrieve the IRQ status of the channel number and the next channel */
  IrqStatus = (uint8)((RegVal >> RegPos) & (uint32)GTM_GET_TOM_INT_STATUS);
  return(IrqStatus);
}

/*******************************************************************************
** Traceability     :                                                         **
**                                                                            **
** Syntax           : LOCAL_INLINE uint8 Mcal_lGtmGetAtomIrqStatus            **
**                    (                                                       **
**                      uint8 Module,                                         **
**                      uint8 Channel                                         **
**                    )                                                       **
**                                                                            **
** Description      :This function returns the extracted information          **
**                   containing the status of the interrupt for the input     **
**                   ATOM channel.It informs whether the ATOM[Module][Channel]**
**                   triggered the interrupt or not. The information is       **
**                   extracted from ICM register corresponding to TOM module  **
**                                                                            **
** Service ID       : NA                                                      **
**                                                                            **
** Sync/Async       : Synchronous                                             **
**                                                                            **
** Reentrancy       : Concurrency Safe                                        **
**                                                                            **
** Parameters(in)   : Module -        ATOM Module ID                          **
**                    Channel -       ATOM Channel ID                         **
**                                                                            **
** Parameters (out) : None                                                    **
**                                                                            **
** Return value     : Extracted information containing the interrupt status   **
**                    of the input ATOM channel                               **
**                                                                            **
*******************************************************************************/

LOCAL_INLINE uint8 Mcal_lGtmGetAtomIrqStatus(uint8 Module, uint8 Channel)
{
  uint8 RegPos;
  uint8 IrqStatus;
  uint32 RegVal;

  /* Ascertain the position of Interrupt status for the corresponding module
     and channel*/
  RegPos = (uint8)(((Module % (uint8)GTM_ATOM_MODULES_IN_ICM_REG) * \
                     (uint8)GTM_CHANNELS_PER_ATOM_MODULE) + Channel);

  /* Identify the ICM register corresponding to the Module number */

  /* MISRA2012_RULE_18_4_JUSTIFICATION: Different ATOM modules are associated
   * with different ICM registers. To effectively calculate to which ICM
   * register the module belongs to, the base ICM register address for
   * ATOM module is taken the , according to module number, the subsequent
   * ICM register is accessed. Since the Module and Channel values are
   * validated by the user, no side effects are foreseen */

  /* MISRA2012_RULE_11_3_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule, as the pointer to the object type
   * it is getting cast into is a known type . */
  /* MISRA2012_RULE_11_4_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  /* MISRA2012_RULE_11_5_JUSTIFICATION: SFR access. No side effects foreseen
   * by violating this MISRA rule. */
  RegVal = *(((volatile uint32*)(volatile void *)GTM_ATOM_ICM_BASE_ADDRESS) + \
                       ((uint32)Module/(uint32)GTM_ATOM_MODULES_IN_ICM_REG));


  /* Retrieve the IRQ status of the channel number and the next channel */
  IrqStatus = (uint8)((RegVal >> RegPos) & (uint32)GTM_GET_ATOM_INT_STATUS);
  return(IrqStatus);
}

#define MCALLIB_STOP_SEC_CODE_QM_GLOBAL
/* MISRA2012_RULE_4_10_JUSTIFICATION: 'McalLib_MemMap.h' is header file which
 * contains the memory sections for McalLib. It should not be guarded by
 * standard include. No side effects foreseen by violating this MISRA rule. */

/* MISRA2012_RULE_20_1_JUSTIFICATION: variable 'Mcal_GtmTimChUserData'
 * declared before MemMap header file. This variable needs to be placed in a
 * appropriate memory section. No side effects foreseen by violating
 * this MISRA rule */

#include "McalLib_MemMap.h"
